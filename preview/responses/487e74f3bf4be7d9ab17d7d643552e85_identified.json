{
    "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?> <rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns=\"http://purl.org/rss/1.0/\" xmlns:taxo=\"http://purl.org/rss/1.0/modules/taxonomy/\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:syn=\"http://purl.org/rss/1.0/modules/syndication/\" xmlns:admin=\"http://webns.net/mvcb/\">   <channel rdf:about=\"http://blog.gmane.org/gmane.comp.compression.xz.devel\">     <title>gmane.comp.compression.xz.devel</title>     <link>http://blog.gmane.org/gmane.comp.compression.xz.devel</link>     <description/>     <syn:updatePeriod>hourly</syn:updatePeriod>     <syn:updateFrequency>1</syn:updateFrequency>     <syn:updateBase>1901-01-01T00:00+00:00</syn:updateBase>     <items>       <rdf:Seq>         <rdf:li rdf:resource=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/222\"/>         <rdf:li rdf:resource=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/216\"/>         <rdf:li rdf:resource=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/208\"/>         <rdf:li rdf:resource=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/207\"/>         <rdf:li rdf:resource=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/206\"/>         <rdf:li rdf:resource=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/205\"/>         <rdf:li rdf:resource=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/198\"/>         <rdf:li rdf:resource=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/192\"/>         <rdf:li rdf:resource=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/189\"/>         <rdf:li rdf:resource=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/187\"/>         <rdf:li rdf:resource=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/184\"/>         <rdf:li rdf:resource=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/177\"/>         <rdf:li rdf:resource=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/174\"/>         <rdf:li rdf:resource=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/168\"/>         <rdf:li rdf:resource=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/166\"/>         <rdf:li rdf:resource=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/163\"/>         <rdf:li rdf:resource=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/162\"/>         <rdf:li rdf:resource=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/161\"/>         <rdf:li rdf:resource=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/158\"/>         <rdf:li rdf:resource=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/156\"/>       </rdf:Seq>     </items>     <image rdf:resource=\"http://gmane.org/img/gmane-25t.png\"/>     <textinput rdf:resource=\"\"/>   </channel>   <image rdf:about=\"http://gmane.org/img/gmane-25t.png\">     <title>Gmane</title>     <url>http://gmane.org/img/gmane-25t.png</url>     <link>http://gmane.org</link>   </image>   <item rdf:about=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/222\">     <title>XZ Utils 5.2.1</title>     <link>http://comments.gmane.org/gmane.comp.compression.xz.devel/222</link>     <description>&lt;pre&gt;XZ Utils 5.2.1 is available at &amp;lt;http://tukaani.org/xz/&amp;gt;. Here is an  extract from the NEWS file:    * Fixed a compression-ratio regression in fast mode of LZMA1 and     LZMA2. The bug is present in 5.1.4beta and 5.2.0 releases.    * Fixed a portability problem in xz that affected at least OpenBSD.    * Fixed xzdiff to be compatible with FreeBSD's mktemp which differs     from most other mktemp implementations.    * Changed CPU core count detection to use cpuset_getaffinity() on     FreeBSD.  &lt;/pre&gt;</description>     <dc:creator>Lasse Collin</dc:creator>     <dc:date>2015-02-26T17:12:09</dc:date>   </item>   <item rdf:about=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/216\">     <title>Fairly Complete MSVC 2013 Solution/Project</title>     <link>http://comments.gmane.org/gmane.comp.compression.xz.devel/216</link>     <description>&lt;pre&gt;Hi,  I've created vs2013 based solution for lzma DLL, lzma static and most utils. It based on the works of Garen &amp;amp; M\\ufffd\\ufffdrti\\ufffd\\ufffd\\ufffd\\ufffd Mo\\ufffd\\ufffdeiko. It can be found at https://github.com/mindw/xz vs2013_520 branch.  The cmake branch has the build system ported to cmake (only for VS). It enabled me to build xz for Python 2.7 use. (Intel C++ Compiler targeted at VS2008).  Any interest?   -gabi   &lt;/pre&gt;</description>     <dc:creator>Gabi Davar</dc:creator>     <dc:date>2015-01-23T11:19:01</dc:date>   </item>   <item rdf:about=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/208\">     <title>How to compress a folder with xz ?</title>     <link>http://comments.gmane.org/gmane.comp.compression.xz.devel/208</link>     <description>&lt;pre&gt;Hi, all,  The forum webpage give an error. So I hope you will forgive me for sending to xz-devel, in the hope that someone may advice.  According to the man page of xz, it seems that xz folderName or xz folderName/ is enough. However, when running: xz /etc/ I get; xz: /etc/: Is a directory, skipping  I saw that it is possible with the tar command, with soem command options, but isn't it possible with xz ?  regards, Kevin   &lt;/pre&gt;</description>     <dc:creator>Kevin Wilson</dc:creator>     <dc:date>2014-11-09T18:24:07</dc:date>   </item>   <item rdf:about=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/207\">     <title>Optimizing lzma_memcmplen for non-x86 processors</title>     <link>http://comments.gmane.org/gmane.comp.compression.xz.devel/207</link>     <description>&lt;pre&gt;XZ Utils 5.1.4beta got a speed optimization for buffer comparisons which improves encoding speed. It works on systems that support unaligned memory access. The relevant code is in src/liblzma/common/memcmplen.h:      http://git.tukaani.org/?p=xz.git;a=blob;f=src/liblzma/common/memcmplen.h  Different architectures get the best performance with different code. The code should be decent for x86-64 and maybe also for 32-bit x86 (at least the SSE2 version). Those may still have some room left for improvement and help is welcome to improve them. However, no one has looked at how the code could be improved for non-x86 archs, so I'm especially interested in finding people to help with that.  I have heard that the generic versions work on little endian 32-bit ARM and 32-bit big endian PowerPC. On those the generic code is slightly faster than the byte-by-byte buffer comparison, but perhaps arch-specific code could do better. The method used for x86-64 could be good for other 64-bit CPUs too if __builtin_ctzll maps to a fast instruction.  Timing the speed of \"xz -e\" when compressing a fairly compressible file (many source code tarballs are such) is a good way to test different lzma_memcmplen implementations. The reason for using -e is that the relative improvement tends to be bigger when that option is used. On x86-64 I've seen even 25 % faster compression with some files compared to the byte-by-byte method.  &lt;/pre&gt;</description>     <dc:creator>Lasse Collin</dc:creator>     <dc:date>2014-10-13T19:28:10</dc:date>   </item>   <item rdf:about=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/206\">     <title>XZ Utils 5.0.7</title>     <link>http://comments.gmane.org/gmane.comp.compression.xz.devel/206</link>     <description>&lt;pre&gt;XZ Utils 5.0.7 is available at &amp;lt;http://tukaani.org/xz/&amp;gt;. Here is an  extract from the NEWS file:      * Fix regressions introduced in 5.0.6:          - Fix building with non-GNU make.          - Fix invalid Libs.private value in liblzma.pc which broke           static linking against liblzma if the linker flags were           taken from pkg-config.  &lt;/pre&gt;</description>     <dc:creator>Lasse Collin</dc:creator>     <dc:date>2014-09-20T18:04:06</dc:date>   </item>   <item rdf:about=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/205\">     <title>XZ Utils 5.0.6 and 5.1.4beta</title>     <link>http://comments.gmane.org/gmane.comp.compression.xz.devel/205</link>     <description>&lt;pre&gt;XZ Utils 5.0.6 and 5.1.4beta are available at &amp;lt;http://tukaani.org/xz/&amp;gt;. Here is an extract from the NEWS file:  5.0.6 (2014-09-14)      * xzgrep now exits with status 0 if at least one file matched.      * A few minor portability and build system fixes  5.1.4beta (2014-09-14)      * All fixes from 5.0.6      * liblzma: Fixed the use of presets in threaded encoder       initialization.      * xz --block-list and --block-size can now be used together       in single-threaded mode. Previously the combination only       worked in multi-threaded mode.      * Added support for LZMA_IGNORE_CHECK to liblzma and made it       available in xz as --ignore-check.      * liblzma speed optimizations:          - Initialization of a new LZMA1 or LZMA2 encoder has been           optimized. (The speed of reinitializing an already-allocated           encoder isn't affected.) This helps when compressing many           small buffers with lzma_stream_buffer_encode() and other           similar situations where an already-allocated encoder state           isn't reused. This speed-up is visible in xz too if one           compresses many small files one at a time instead running xz           once and giving all files as command-line arguments.          - Buffer comparisons are now much faster when unaligned access           is allowed (configured with --enable-unaligned-access). This           speeds up encoding significantly. There is arch-specific code           for 32-bit and 64-bit x86 (32-bit needs SSE2 for the best           results and there's no run-time CPU detection for now).           For other archs there is only generic code which probably           isn't as optimal as arch-specific solutions could be.          - A few speed optimizations were made to the SHA-256 code.           (Note that the builtin SHA-256 code isn't used on all           operating systems.)      * liblzma can now be built with MSVC 2013 update 2 or later       using windows/config.h.      * Vietnamese translation was added.  &lt;/pre&gt;</description>     <dc:creator>Lasse Collin</dc:creator>     <dc:date>2014-09-14T19:46:01</dc:date>   </item>   <item rdf:about=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/198\">     <title>Disabling CRC/SHA-256 checks on decompression</title>     <link>http://comments.gmane.org/gmane.comp.compression.xz.devel/198</link>     <description>&lt;pre&gt;Would it be possible to add a flag to disable these checks during  decompression?  I have data format and lots of data encoded in it (RPMs,  in case you wonder) which has its own integrity checking, and  unfortunately, all the existing XZ streams have been built with SHA-256  hashing.  Being able to disable hashing would result in a nice speed-up  for me (based on preliminary tests using hand-crafted RPMs).  &lt;/pre&gt;</description>     <dc:creator>Florian Weimer</dc:creator>     <dc:date>2014-07-31T14:40:05</dc:date>   </item>   <item rdf:about=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/192\">     <title>xzgrep should success if at least one file matches</title>     <link>http://comments.gmane.org/gmane.comp.compression.xz.devel/192</link>     <description>&lt;pre&gt;Hi, in RHBZ, there was reported problem with xzgrep, we should exit 0 when at lest one file contains matching string.  Grep behaves similarly.  Original bugreport: https://bugzilla.redhat.com/show_bug.cgi?id=1108085  Patch is attached, Pavel &lt;/pre&gt;</description>     <dc:creator>Pavel Raiskup</dc:creator>     <dc:date>2014-06-11T14:22:51</dc:date>   </item>   <item rdf:about=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/189\">     <title>XZ for Java 1.5</title>     <link>http://comments.gmane.org/gmane.comp.compression.xz.devel/189</link>     <description>&lt;pre&gt;XZ for Java 1.5 is available at &amp;lt;http://tukaani.org/xz/java.html&amp;gt; and in the Maven Central (groupId = org.tukaani, artifactId = xz). Here is an extract from the NEWS file:      * Fix a wrong assertion in BCJ decoders.      * Use a field instead of reallocating a temporary one-byte buffer       in read() and write() implementations in several classes.  &lt;/pre&gt;</description>     <dc:creator>Lasse Collin</dc:creator>     <dc:date>2014-03-08T11:43:54</dc:date>   </item>   <item rdf:about=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/187\">     <title>Solaris packages (done) and C99 code removal</title>     <link>http://comments.gmane.org/gmane.comp.compression.xz.devel/187</link>     <description>&lt;pre&gt;Hi folks,  I've compiled up xz 5.0.4 on the following machines:  xz.5.0.4.SPARC.32bit.Solaris.10.pkg xz.5.0.4.SPARC.32bit.Solaris.8.pkg xz.5.0.4.SPARC.32bit.Solaris.9.pkg xz.5.0.4.SPARC.64bit.Solaris.10.pkg xz.5.0.4.SPARC.64bit.Solaris.11.pkg xz.5.0.4.SPARC.64bit.Solaris.7.pkg xz.5.0.4.SPARC.64bit.Solaris.8.pkg xz.5.0.4.SPARC.64bit.Solaris.9.pkg xz.5.0.4.i86pc.64bit.Solaris.11.pkg xz.5.0.4.i86pc.Solaris.10.pkg xz.5.0.4.i86pc.Solaris.11.pkg  Compilers used (the highest version that will work on that O.S.): Solaris 7: Sun Studio 8 Solaris 8: Sun Studio 11  Solaris 9: Solaris Studio 12 Solaris 10 and Solaris 11: Sun Studio 12.3  The Solaris 7 was more problematic, the C99 support is very minimal in Sun Studio 8. I took out the C99 specific code in the xz source tree, making it C89 friendly (and thus portable to a lot more compilers - you should do this to the main code base IMHO). See the attached diff. I didn't do this in the test/* files.  The packages are now on: http://www.ibiblio.org/pub/packages/solaris/sparc/  ta, Mark. diff -ruN xz-5.0.4.orig/configure xz-5.0.4/configure --- xz-5.0.4.orig/configure2012-06-22 11:56:05.000000000 +0000 +++ xz-5.0.4/configure2014-03-02 02:03:07.921913000 +0000 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -5661,22 +5661,6 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    for (int i = 0; i &amp;lt; ia-&amp;gt;datasize; ++i)      ia-&amp;gt;data[i] = i * 1.234;   -  // Check named initializers. -  struct named_init ni = { -    .number = 34, -    .name = L\"Test wide string\", -    .average = 543.34343, -  }; - -  ni.number = 58; - -  int dynamic_array[ni.number]; -  dynamic_array[ni.number - 1] = 543; - -  // work around unused variable warnings -  return (!success || bignum == 0LL || ubignum == 0uLL || newvar[0] == 'x' -  || dynamic_array[ni.number - 1] != 543); -    ;    return 0;  } diff -ruN xz-5.0.4.orig/debug/known_sizes.c xz-5.0.4/debug/known_sizes.c --- xz-5.0.4.orig/debug/known_sizes.c2012-06-22 06:22:30.000000000 +0000 +++ xz-5.0.4/debug/known_sizes.c2014-03-02 03:28:57.714970000 +0000 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -47,19 +47,19 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    lzma_filter filters[] = {  { -.id = LZMA_FILTER_LZMA2, -.options = &amp;amp;opt_lzma +LZMA_FILTER_LZMA2, +&amp;amp;opt_lzma  },  { -.id = LZMA_VLI_UNKNOWN +LZMA_VLI_UNKNOWN  }  };    lzma_block block = { -.check = LZMA_CHECK_CRC32, -.compressed_size = BUFFER_SIZE, // Worst case reserve -.uncompressed_size = in_size, -.filters = filters, +LZMA_CHECK_CRC32, +BUFFER_SIZE, // Worst case reserve +in_size, +filters,  };    lzma_stream strm = LZMA_STREAM_INIT; diff -ruN xz-5.0.4.orig/src/liblzma/common/alone_decoder.c xz-5.0.4/src/liblzma/common/alone_decoder.c --- xz-5.0.4.orig/src/liblzma/common/alone_decoder.c2012-06-22 06:22:30.000000000 +0000 +++ xz-5.0.4/src/liblzma/common/alone_decoder.c2014-03-02 02:37:02.687316000 +0000 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -126,10 +126,10 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    lzma_filter_info filters[2] = {  { -.init = &amp;amp;lzma_lzma_decoder_init, -.options = &amp;amp;coder-&amp;gt;options, +&amp;amp;lzma_lzma_decoder_init, +&amp;amp;coder-&amp;gt;options,  }, { -.init = NULL, +NULL,  }  };   diff -ruN xz-5.0.4.orig/src/liblzma/common/alone_encoder.c xz-5.0.4/src/liblzma/common/alone_encoder.c --- xz-5.0.4.orig/src/liblzma/common/alone_encoder.c2012-06-22 06:22:30.000000000 +0000 +++ xz-5.0.4/src/liblzma/common/alone_encoder.c2014-03-02 02:25:40.335544000 +0000 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -122,12 +122,12 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  memset(next-&amp;gt;coder-&amp;gt;header + 1 + 4, 0xFF, 8);    // Initialize the LZMA encoder. -const lzma_filter_info filters[2] = { +lzma_filter_info filters[2] = {  { -.init = &amp;amp;lzma_lzma_encoder_init, -.options = (void *)(options), +&amp;amp;lzma_lzma_encoder_init, +(void *)(options),  }, { -.init = NULL, +NULL,  }  };   diff -ruN xz-5.0.4.orig/src/liblzma/common/block_buffer_encoder.c xz-5.0.4/src/liblzma/common/block_buffer_encoder.c --- xz-5.0.4.orig/src/liblzma/common/block_buffer_encoder.c2012-06-22 06:22:30.000000000 +0000 +++ xz-5.0.4/src/liblzma/common/block_buffer_encoder.c2014-03-02 02:26:09.805622000 +0000 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -89,7 +89,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  // all, but LZMA2 always requires a dictionary, so use the minimum  // value to minimize memory usage of the decoder.  lzma_options_lzma lzma2 = { -.dict_size = LZMA_DICT_SIZE_MIN, +LZMA_DICT_SIZE_MIN,  };    lzma_filter filters[2]; diff -ruN xz-5.0.4.orig/src/liblzma/common/common.h xz-5.0.4/src/liblzma/common/common.h --- xz-5.0.4.orig/src/liblzma/common/common.h2012-06-22 06:22:30.000000000 +0000 +++ xz-5.0.4/src/liblzma/common/common.h2014-03-02 02:13:17.033574000 +0000 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -155,18 +155,28 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  const lzma_filter *reversed_filters);  };   +///(lzma_next_coder){ \\\\ +///.coder = NULL, \\\\ +///.id = LZMA_VLI_UNKNOWN, \\\\ +///.init = (uintptr_t)(NULL), \\\\ +///.code = NULL, \\\\ +///.end = NULL, \\\\ +///.get_check = NULL, \\\\ +///.memconfig = NULL, \\\\ +///.update = NULL, \\\\ +///}    /// Macro to initialize lzma_next_coder structure  #define LZMA_NEXT_CODER_INIT \\\\  (lzma_next_coder){ \\\\ -.coder = NULL, \\\\ -.init = (uintptr_t)(NULL), \\\\ -.id = LZMA_VLI_UNKNOWN, \\\\ -.code = NULL, \\\\ -.end = NULL, \\\\ -.get_check = NULL, \\\\ -.memconfig = NULL, \\\\ -.update = NULL, \\\\ +NULL, \\\\ +LZMA_VLI_UNKNOWN, \\\\ +(uintptr_t)(NULL), \\\\ +NULL, \\\\ +NULL, \\\\ +NULL, \\\\ +NULL, \\\\ +NULL, \\\\  }     diff -ruN xz-5.0.4.orig/src/liblzma/common/filter_common.c xz-5.0.4/src/liblzma/common/filter_common.c --- xz-5.0.4.orig/src/liblzma/common/filter_common.c2012-06-22 06:22:30.000000000 +0000 +++ xz-5.0.4/src/liblzma/common/filter_common.c2014-03-02 02:20:29.894746000 +0000 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -36,87 +36,91 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  } features[] = {  #if defined (HAVE_ENCODER_LZMA1) || defined(HAVE_DECODER_LZMA1)  { -.id = LZMA_FILTER_LZMA1, -.options_size = sizeof(lzma_options_lzma), -.non_last_ok = false, -.last_ok = true, -.changes_size = true, +LZMA_FILTER_LZMA1, +sizeof(lzma_options_lzma), +false, +true, +true,  },  #endif  #if defined(HAVE_ENCODER_LZMA2) || defined(HAVE_DECODER_LZMA2)  { -.id = LZMA_FILTER_LZMA2, -.options_size = sizeof(lzma_options_lzma), -.non_last_ok = false, -.last_ok = true, -.changes_size = true, +LZMA_FILTER_LZMA2, +sizeof(lzma_options_lzma), +false, +true, +true,  },  #endif  #if defined(HAVE_ENCODER_X86) || defined(HAVE_DECODER_X86)  { -.id = LZMA_FILTER_X86, -.options_size = sizeof(lzma_options_bcj), -.non_last_ok = true, -.last_ok = false, -.changes_size = false, +LZMA_FILTER_X86, +sizeof(lzma_options_bcj), +true, +false, +false,  },  #endif  #if defined(HAVE_ENCODER_POWERPC) || defined(HAVE_DECODER_POWERPC)  { -.id = LZMA_FILTER_POWERPC, -.options_size = sizeof(lzma_options_bcj), -.non_last_ok = true, -.last_ok = false, -.changes_size = false, +LZMA_FILTER_POWERPC, +sizeof(lzma_options_bcj), +true, +false, +false,  },  #endif  #if defined(HAVE_ENCODER_IA64) || defined(HAVE_DECODER_IA64)  { -.id = LZMA_FILTER_IA64, -.options_size = sizeof(lzma_options_bcj), -.non_last_ok = true, -.last_ok = false, -.changes_size = false, +LZMA_FILTER_IA64, +sizeof(lzma_options_bcj), +true, +false, +false,  },  #endif  #if defined(HAVE_ENCODER_ARM) || defined(HAVE_DECODER_ARM)  { -.id = LZMA_FILTER_ARM, -.options_size = sizeof(lzma_options_bcj), -.non_last_ok = true, -.last_ok = false, -.changes_size = false, +LZMA_FILTER_ARM, +sizeof(lzma_options_bcj), +true, +false, +false,  },  #endif  #if defined(HAVE_ENCODER_ARMTHUMB) || defined(HAVE_DECODER_ARMTHUMB)  { -.id = LZMA_FILTER_ARMTHUMB, -.options_size = sizeof(lzma_options_bcj), -.non_last_ok = true, -.last_ok = false, -.changes_size = false, +LZMA_FILTER_ARMTHUMB, +sizeof(lzma_options_bcj), +true, +false, +false,  },  #endif  #if defined(HAVE_ENCODER_SPARC) || defined(HAVE_DECODER_SPARC)  { -.id = LZMA_FILTER_SPARC, -.options_size = sizeof(lzma_options_bcj), -.non_last_ok = true, -.last_ok = false, -.changes_size = false, +LZMA_FILTER_SPARC, +sizeof(lzma_options_bcj), +true, +false, +false,  },  #endif  #if defined(HAVE_ENCODER_DELTA) || defined(HAVE_DECODER_DELTA)  { -.id = LZMA_FILTER_DELTA, -.options_size = sizeof(lzma_options_delta), -.non_last_ok = true, -.last_ok = false, -.changes_size = false, +LZMA_FILTER_DELTA, +sizeof(lzma_options_delta), +true, +false, +false,  },  #endif  { -.id = LZMA_VLI_UNKNOWN +LZMA_VLI_UNKNOWN, +NULL, +0, +0, +0,  }  };   diff -ruN xz-5.0.4.orig/src/liblzma/common/filter_decoder.c xz-5.0.4/src/liblzma/common/filter_decoder.c --- xz-5.0.4.orig/src/liblzma/common/filter_decoder.c2012-06-22 06:22:30.000000000 +0000 +++ xz-5.0.4/src/liblzma/common/filter_decoder.c2014-03-02 02:38:01.287487000 +0000 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -44,74 +44,74 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  static const lzma_filter_decoder decoders[] = {  #ifdef HAVE_DECODER_LZMA1  { -.id = LZMA_FILTER_LZMA1, -.init = &amp;amp;lzma_lzma_decoder_init, -.memusage = &amp;amp;lzma_lzma_decoder_memusage, -.props_decode = &amp;amp;lzma_lzma_props_decode, +LZMA_FILTER_LZMA1, +&amp;amp;lzma_lzma_decoder_init, +&amp;amp;lzma_lzma_decoder_memusage, +&amp;amp;lzma_lzma_props_decode,  },  #endif  #ifdef HAVE_DECODER_LZMA2  { -.id = LZMA_FILTER_LZMA2, -.init = &amp;amp;lzma_lzma2_decoder_init, -.memusage = &amp;amp;lzma_lzma2_decoder_memusage, -.props_decode = &amp;amp;lzma_lzma2_props_decode, +LZMA_FILTER_LZMA2, +&amp;amp;lzma_lzma2_decoder_init, +&amp;amp;lzma_lzma2_decoder_memusage, +&amp;amp;lzma_lzma2_props_decode,  },  #endif  #ifdef HAVE_DECODER_X86  { -.id = LZMA_FILTER_X86, -.init = &amp;amp;lzma_simple_x86_decoder_init, -.memusage = NULL, -.props_decode = &amp;amp;lzma_simple_props_decode, +LZMA_FILTER_X86, +&amp;amp;lzma_simple_x86_decoder_init, +NULL, +&amp;amp;lzma_simple_props_decode,  },  #endif  #ifdef HAVE_DECODER_POWERPC  { -.id = LZMA_FILTER_POWERPC, -.init = &amp;amp;lzma_simple_powerpc_decoder_init, -.memusage = NULL, -.props_decode = &amp;amp;lzma_simple_props_decode, +LZMA_FILTER_POWERPC, +&amp;amp;lzma_simple_powerpc_decoder_init, +NULL, +&amp;amp;lzma_simple_props_decode,  },  #endif  #ifdef HAVE_DECODER_IA64  { -.id = LZMA_FILTER_IA64, -.init = &amp;amp;lzma_simple_ia64_decoder_init, -.memusage = NULL, -.props_decode = &amp;amp;lzma_simple_props_decode, +LZMA_FILTER_IA64, +&amp;amp;lzma_simple_ia64_decoder_init, +NULL, +&amp;amp;lzma_simple_props_decode,  },  #endif  #ifdef HAVE_DECODER_ARM  { -.id = LZMA_FILTER_ARM, -.init = &amp;amp;lzma_simple_arm_decoder_init, -.memusage = NULL, -.props_decode = &amp;amp;lzma_simple_props_decode, +LZMA_FILTER_ARM, +&amp;amp;lzma_simple_arm_decoder_init, +NULL, +&amp;amp;lzma_simple_props_decode,  },  #endif  #ifdef HAVE_DECODER_ARMTHUMB  { -.id = LZMA_FILTER_ARMTHUMB, -.init = &amp;amp;lzma_simple_armthumb_decoder_init, -.memusage = NULL, -.props_decode = &amp;amp;lzma_simple_props_decode, +LZMA_FILTER_ARMTHUMB, +&amp;amp;lzma_simple_armthumb_decoder_init, +NULL, +&amp;amp;lzma_simple_props_decode,  },  #endif  #ifdef HAVE_DECODER_SPARC  { -.id = LZMA_FILTER_SPARC, -.init = &amp;amp;lzma_simple_sparc_decoder_init, -.memusage = NULL, -.props_decode = &amp;amp;lzma_simple_props_decode, +LZMA_FILTER_SPARC, +&amp;amp;lzma_simple_sparc_decoder_init, +NULL, +&amp;amp;lzma_simple_props_decode,  },  #endif  #ifdef HAVE_DECODER_DELTA  { -.id = LZMA_FILTER_DELTA, -.init = &amp;amp;lzma_delta_decoder_init, -.memusage = &amp;amp;lzma_delta_coder_memusage, -.props_decode = &amp;amp;lzma_delta_props_decode, +LZMA_FILTER_DELTA, +&amp;amp;lzma_delta_decoder_init, +&amp;amp;lzma_delta_coder_memusage, +&amp;amp;lzma_delta_props_decode,  },  #endif  }; diff -ruN xz-5.0.4.orig/src/liblzma/common/filter_encoder.c xz-5.0.4/src/liblzma/common/filter_encoder.c --- xz-5.0.4.orig/src/liblzma/common/filter_encoder.c2012-06-22 06:22:30.000000000 +0000 +++ xz-5.0.4/src/liblzma/common/filter_encoder.c2014-03-02 02:34:20.856903000 +0000 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -53,98 +53,104 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  } lzma_filter_encoder;     -static const lzma_filter_encoder encoders[] = { +lzma_filter_encoder encoders[] = {  #ifdef HAVE_ENCODER_LZMA1  { -.id = LZMA_FILTER_LZMA1, -.init = &amp;amp;lzma_lzma_encoder_init, -.memusage = &amp;amp;lzma_lzma_encoder_memusage, -.chunk_size = NULL, // FIXME -.props_size_get = NULL, -.props_size_fixed = 5, -.props_encode = &amp;amp;lzma_lzma_props_encode, +LZMA_FILTER_LZMA1, +&amp;amp;lzma_lzma_encoder_init, +&amp;amp;lzma_lzma_encoder_memusage, +NULL, // FIXME +NULL, +5, +&amp;amp;lzma_lzma_props_encode,  },  #endif  #ifdef HAVE_ENCODER_LZMA2  { -.id = LZMA_FILTER_LZMA2, -.init = &amp;amp;lzma_lzma2_encoder_init, -.memusage = &amp;amp;lzma_lzma2_encoder_memusage, -.chunk_size = NULL, // FIXME -.props_size_get = NULL, -.props_size_fixed = 1, -.props_encode = &amp;amp;lzma_lzma2_props_encode, +LZMA_FILTER_LZMA2, +&amp;amp;lzma_lzma2_encoder_init, +&amp;amp;lzma_lzma2_encoder_memusage, +NULL, // FIXME +NULL, +1, +&amp;amp;lzma_lzma2_props_encode,  },  #endif  #ifdef HAVE_ENCODER_X86  { -.id = LZMA_FILTER_X86, -.init = &amp;amp;lzma_simple_x86_encoder_init, -.memusage = NULL, -.chunk_size = NULL, -.props_size_get = &amp;amp;lzma_simple_props_size, -.props_encode = &amp;amp;lzma_simple_props_encode, +LZMA_FILTER_X86, +&amp;amp;lzma_simple_x86_encoder_init, +NULL, +NULL, +&amp;amp;lzma_simple_props_size, +1, +&amp;amp;lzma_simple_props_encode,  },  #endif  #ifdef HAVE_ENCODER_POWERPC  { -.id = LZMA_FILTER_POWERPC, -.init = &amp;amp;lzma_simple_powerpc_encoder_init, -.memusage = NULL, -.chunk_size = NULL, -.props_size_get = &amp;amp;lzma_simple_props_size, -.props_encode = &amp;amp;lzma_simple_props_encode, +LZMA_FILTER_POWERPC, +&amp;amp;lzma_simple_powerpc_encoder_init, +NULL, +NULL, +&amp;amp;lzma_simple_props_size, +1, +&amp;amp;lzma_simple_props_encode,  },  #endif  #ifdef HAVE_ENCODER_IA64  { -.id = LZMA_FILTER_IA64, -.init = &amp;amp;lzma_simple_ia64_encoder_init, -.memusage = NULL, -.chunk_size = NULL, -.props_size_get = &amp;amp;lzma_simple_props_size, -.props_encode = &amp;amp;lzma_simple_props_encode, +LZMA_FILTER_IA64, +&amp;amp;lzma_simple_ia64_encoder_init, +NULL, +NULL, +&amp;amp;lzma_simple_props_size, +1, +&amp;amp;lzma_simple_props_encode,  },  #endif  #ifdef HAVE_ENCODER_ARM  { -.id = LZMA_FILTER_ARM, -.init = &amp;amp;lzma_simple_arm_encoder_init, -.memusage = NULL, -.chunk_size = NULL, -.props_size_get = &amp;amp;lzma_simple_props_size, -.props_encode = &amp;amp;lzma_simple_props_encode, +LZMA_FILTER_ARM, +&amp;amp;lzma_simple_arm_encoder_init, +NULL, +NULL, +&amp;amp;lzma_simple_props_size, +1, +&amp;amp;lzma_simple_props_encode,  },  #endif  #ifdef HAVE_ENCODER_ARMTHUMB  { -.id = LZMA_FILTER_ARMTHUMB, -.init = &amp;amp;lzma_simple_armthumb_encoder_init, -.memusage = NULL, -.chunk_size = NULL, -.props_size_get = &amp;amp;lzma_simple_props_size, -.props_encode = &amp;amp;lzma_simple_props_encode, +LZMA_FILTER_ARMTHUMB, +&amp;amp;lzma_simple_armthumb_encoder_init, +NULL, +NULL, +&amp;amp;lzma_simple_props_size, +1, +&amp;amp;lzma_simple_props_encode,  },  #endif  #ifdef HAVE_ENCODER_SPARC  { -.id = LZMA_FILTER_SPARC, -.init = &amp;amp;lzma_simple_sparc_encoder_init, -.memusage = NULL, -.chunk_size = NULL, -.props_size_get = &amp;amp;lzma_simple_props_size, -.props_encode = &amp;amp;lzma_simple_props_encode, +LZMA_FILTER_SPARC, +&amp;amp;lzma_simple_sparc_encoder_init, +NULL, +NULL, +&amp;amp;lzma_simple_props_size, +1, +&amp;amp;lzma_simple_props_encode,  },  #endif  #ifdef HAVE_ENCODER_DELTA  { -.id = LZMA_FILTER_DELTA, -.init = &amp;amp;lzma_delta_encoder_init, -.memusage = &amp;amp;lzma_delta_coder_memusage, -.chunk_size = NULL, -.props_size_get = NULL, -.props_size_fixed = 1, -.props_encode = &amp;amp;lzma_delta_props_encode, +LZMA_FILTER_DELTA, +&amp;amp;lzma_delta_encoder_init, +&amp;amp;lzma_delta_coder_memusage, +NULL, +NULL, +1, +&amp;amp;lzma_delta_props_encode,  },  #endif  }; diff -ruN xz-5.0.4.orig/src/liblzma/common/index.c xz-5.0.4/src/liblzma/common/index.c --- xz-5.0.4.orig/src/liblzma/common/index.c2012-06-22 06:22:30.000000000 +0000 +++ xz-5.0.4/src/liblzma/common/index.c2014-03-02 02:23:35.705250000 +0000 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -834,12 +834,12 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    // Add all the Streams from src to dest. Update the base offsets  // of each Stream from src. -const index_cat_info info = { -.uncompressed_size = dest-&amp;gt;uncompressed_size, -.file_size = dest_file_size, -.stream_number_add = dest-&amp;gt;streams.count, -.block_number_add = dest-&amp;gt;record_count, -.streams = &amp;amp;dest-&amp;gt;streams, +index_cat_info info= { +dest-&amp;gt;uncompressed_size, +dest_file_size, +dest-&amp;gt;streams.count, +dest-&amp;gt;record_count, +&amp;amp;dest-&amp;gt;streams,  };  index_cat_helper(&amp;amp;info, (index_stream *)(src-&amp;gt;streams.root));   diff -ruN xz-5.0.4.orig/src/liblzma/common/index_hash.c xz-5.0.4/src/liblzma/common/index_hash.c --- xz-5.0.4.orig/src/liblzma/common/index_hash.c2012-06-22 06:22:30.000000000 +0000 +++ xz-5.0.4/src/liblzma/common/index_hash.c2014-03-02 02:38:25.717558000 +0000 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -130,7 +130,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  + lzma_vli_size(uncompressed_size);  ++info-&amp;gt;count;   -const lzma_vli sizes[2] = { unpadded_size, uncompressed_size }; +lzma_vli sizes[2] = { unpadded_size, uncompressed_size };  lzma_check_update(&amp;amp;info-&amp;gt;check, LZMA_CHECK_BEST,  (const uint8_t *)(sizes), sizeof(sizes));   diff -ruN xz-5.0.4.orig/src/liblzma/common/stream_buffer_encoder.c xz-5.0.4/src/liblzma/common/stream_buffer_encoder.c --- xz-5.0.4.orig/src/liblzma/common/stream_buffer_encoder.c2012-06-22 06:22:30.000000000 +0000 +++ xz-5.0.4/src/liblzma/common/stream_buffer_encoder.c2014-03-02 02:35:03.147014000 +0000 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -74,8 +74,8 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    // Encode the Stream Header.  lzma_stream_flags stream_flags = { -.version = 0, -.check = check, +0, +check,  };    if (lzma_stream_header_encode(&amp;amp;stream_flags, out + out_pos) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -86,9 +86,9 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    // Encode a Block but only if there is at least one byte of input.  lzma_block block = { -.version = 0, -.check = check, -.filters = filters, +0, +check, +filters,  };    if (in_size &amp;gt; 0) diff -ruN xz-5.0.4.orig/src/liblzma/common/stream_encoder.c xz-5.0.4/src/liblzma/common/stream_encoder.c --- xz-5.0.4.orig/src/liblzma/common/stream_encoder.c2012-06-22 06:22:30.000000000 +0000 +++ xz-5.0.4/src/liblzma/common/stream_encoder.c2014-03-02 02:36:12.297188000 +0000 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -184,10 +184,10 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  return ret;    // Encode the Stream Footer into coder-&amp;gt;buffer. -const lzma_stream_flags stream_flags = { -.version = 0, -.backward_size = lzma_index_size(coder-&amp;gt;index), -.check = coder-&amp;gt;block_options.check, +lzma_stream_flags stream_flags = { +0, +lzma_index_size(coder-&amp;gt;index), +coder-&amp;gt;block_options.check,  };    if (lzma_stream_footer_encode(&amp;amp;stream_flags, coder-&amp;gt;buffer) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -299,8 +299,8 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    // Encode the Stream Header  lzma_stream_flags stream_flags = { -.version = 0, -.check = check, +0, +check,  };  return_if_error(lzma_stream_header_encode(  &amp;amp;stream_flags, next-&amp;gt;coder-&amp;gt;buffer)); Binary files xz-5.0.4.orig/src/liblzma/core and xz-5.0.4/src/liblzma/core differ diff -ruN xz-5.0.4.orig/src/liblzma/lz/lz_decoder.h xz-5.0.4/src/liblzma/lz/lz_decoder.h --- xz-5.0.4.orig/src/liblzma/lz/lz_decoder.h2012-06-22 06:22:30.000000000 +0000 +++ xz-5.0.4/src/liblzma/lz/lz_decoder.h2014-03-02 02:40:50.077977000 +0000 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -74,11 +74,11 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    #define LZMA_LZ_DECODER_INIT \\\\  (lzma_lz_decoder){ \\\\ -.coder = NULL, \\\\ -.code = NULL, \\\\ -.reset = NULL, \\\\ -.set_uncompressed = NULL, \\\\ -.end = NULL, \\\\ +NULL, \\\\ +NULL, \\\\ +NULL, \\\\ +NULL, \\\\ +NULL, \\\\  }     diff -ruN xz-5.0.4.orig/src/liblzma/lz/lz_encoder.c xz-5.0.4/src/liblzma/lz/lz_encoder.c --- xz-5.0.4.orig/src/liblzma/lz/lz_encoder.c2012-06-22 06:22:30.000000000 +0000 +++ xz-5.0.4/src/liblzma/lz/lz_encoder.c2014-03-02 02:39:29.177754000 +0000 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -443,10 +443,10 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  {  // Old buffers must not exist when calling lz_encoder_prepare().  lzma_mf mf = { -.buffer = NULL, -.hash = NULL, -.hash_size_sum = 0, -.sons_count = 0, +NULL, +NULL, +0, +0,  };    // Setup the size information into mf. diff -ruN xz-5.0.4.orig/src/liblzma/lzma/lzma_decoder.c xz-5.0.4/src/liblzma/lzma/lzma_decoder.c --- xz-5.0.4.orig/src/liblzma/lzma/lzma_decoder.c2012-06-22 06:22:30.000000000 +0000 +++ xz-5.0.4/src/liblzma/lzma/lzma_decoder.c2014-03-02 03:16:38.853062000 +0000 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -853,6 +853,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  static void  lzma_decoder_reset(lzma_coder *coder, const void *opt)  { +uint32_t num_pos_states;  const lzma_options_lzma *options = opt;    // NOTE: We assume that lc/lp/pb are valid since they were &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -900,7 +901,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  bittree_reset(coder-&amp;gt;pos_align, ALIGN_BITS);    // Len decoders (also bit/bittree) -const uint32_t num_pos_states = 1U &amp;lt;&amp;lt; options-&amp;gt;pb; +num_pos_states = 1U &amp;lt;&amp;lt; options-&amp;gt;pb;  bit_reset(coder-&amp;gt;match_len_decoder.choice);  bit_reset(coder-&amp;gt;match_len_decoder.choice2);  bit_reset(coder-&amp;gt;rep_len_decoder.choice); diff -ruN xz-5.0.4.orig/src/liblzma/lzma/lzma_encoder_optimum_normal.c xz-5.0.4/src/liblzma/lzma/lzma_encoder_optimum_normal.c --- xz-5.0.4.orig/src/liblzma/lzma/lzma_encoder_optimum_normal.c2012-06-22 06:22:30.000000000 +0000 +++ xz-5.0.4/src/liblzma/lzma/lzma_encoder_optimum_normal.c2014-03-02 03:15:47.112926000 +0000 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -276,6 +276,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  {  const uint32_t nice_len = mf-&amp;gt;nice_len;   +uint32_t len;  uint32_t len_main;  uint32_t matches_count;   &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -384,7 +385,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  for (uint32_t i = 0; i &amp;lt; REP_DISTANCES; ++i)  coder-&amp;gt;opts[0].backs[i] = coder-&amp;gt;reps[i];   -uint32_t len = len_end; +len = len_end;  do {  coder-&amp;gt;opts[len].price = RC_INFINITY_PRICE;  } while (--len &amp;gt;= 2); &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -456,6 +457,12 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  uint32_t new_len = coder-&amp;gt;longest_match_length;  uint32_t pos_prev = coder-&amp;gt;opts[cur].pos_prev;  lzma_lzma_state state; +uint32_t cur_price; +uint32_t pos_state; +uint32_t cur_and_1_price; +uint8_t current_byte; +uint8_t match_byte; +bool next_is_literal;    if (coder-&amp;gt;opts[cur].prev_1_is_literal) {  --pos_prev; &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -521,19 +528,19 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  for (uint32_t i = 0; i &amp;lt; REP_DISTANCES; ++i)  coder-&amp;gt;opts[cur].backs[i] = reps[i];   -const uint32_t cur_price = coder-&amp;gt;opts[cur].price; +cur_price = coder-&amp;gt;opts[cur].price;   -const uint8_t current_byte = *buf; -const uint8_t match_byte = *(buf - reps[0] - 1); +current_byte = *buf; +match_byte = *(buf - reps[0] - 1);   -const uint32_t pos_state = position &amp;amp; coder-&amp;gt;pos_mask; +pos_state = position &amp;amp; coder-&amp;gt;pos_mask;   -const uint32_t cur_and_1_price = cur_price +cur_and_1_price = cur_price  + rc_bit_0_price(coder-&amp;gt;is_match[state][pos_state])  + get_literal_price(coder, position, buf[-1],  !is_literal_state(state), match_byte, current_byte);   -bool next_is_literal = false; +next_is_literal = false;    if (cur_and_1_price &amp;lt; coder-&amp;gt;opts[cur + 1].price) {  coder-&amp;gt;opts[cur + 1].price = cur_and_1_price; diff -ruN xz-5.0.4.orig/src/liblzma/simple/ia64.c xz-5.0.4/src/liblzma/simple/ia64.c --- xz-5.0.4.orig/src/liblzma/simple/ia64.c2012-06-22 06:22:30.000000000 +0000 +++ xz-5.0.4/src/liblzma/simple/ia64.c2014-03-02 03:18:04.443290000 +0000 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -19,6 +19,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  uint32_t now_pos, bool is_encoder,  uint8_t *buffer, size_t size)  { +uint64_t inst_norm;  static const uint32_t BRANCH_TABLE[32] = {  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -45,7 +46,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  buffer[i + j + byte_pos])  &amp;lt;&amp;lt; (8 * j);   -uint64_t inst_norm = instruction &amp;gt;&amp;gt; bit_res; +inst_norm = instruction &amp;gt;&amp;gt; bit_res;    if (((inst_norm &amp;gt;&amp;gt; 37) &amp;amp; 0xF) == 0x5  &amp;amp;&amp;amp; ((inst_norm &amp;gt;&amp;gt; 9) &amp;amp; 0x7) == 0 diff -ruN xz-5.0.4.orig/src/lzmainfo/lzmainfo.c xz-5.0.4/src/lzmainfo/lzmainfo.c --- xz-5.0.4.orig/src/lzmainfo/lzmainfo.c2012-06-22 06:22:30.000000000 +0000 +++ xz-5.0.4/src/lzmainfo/lzmainfo.c2014-03-02 03:25:41.314446000 +0000 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -100,6 +100,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  static bool  lzmainfo(const char *name, FILE *f)  { +lzma_options_lzma *opt;  uint8_t buf[13];  const size_t size = fread(buf, 1, sizeof(buf), f);  if (size != 13) { &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -109,7 +110,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  return true;  }   -lzma_filter filter = { .id = LZMA_FILTER_LZMA1 }; +lzma_filter filter = { LZMA_FILTER_LZMA1 };    // Parse the first five bytes.  switch (lzma_properties_decode(&amp;amp;filter, NULL, buf, 5)) { &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -152,7 +153,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  / (1024 * 1024),  uncompressed_size);   -lzma_options_lzma *opt = filter.options; +opt = filter.options;    printf(\"\\ Dictionary size:               \"  \"%\" PRIu32 \" MB (2^%\" PRIu32 \" bytes)\\ \" diff -ruN xz-5.0.4.orig/src/xz/coder.c xz-5.0.4/src/xz/coder.c --- xz-5.0.4.orig/src/xz/coder.c2012-06-22 06:22:30.000000000 +0000 +++ xz-5.0.4/src/xz/coder.c2014-03-02 03:19:34.523542000 +0000 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -116,6 +116,8 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  coder_set_compression_settings(void)  {  // Options for LZMA1 or LZMA2 in case we are using a preset. +uint64_t memory_limit; +uint64_t memory_usage;  static lzma_options_lzma opt_lzma;    if (filters_count == 0) { &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -171,8 +173,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  // If using --format=raw, we can be decoding. The memusage function  // also validates the filter chain and the options used for the  // filters. -const uint64_t memory_limit = hardware_memlimit_get(opt_mode); -uint64_t memory_usage; +memory_limit = hardware_memlimit_get(opt_mode);  if (opt_mode == MODE_COMPRESS)  memory_usage = lzma_raw_encoder_memusage(filters);  else &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -300,7 +301,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  return false;    // Decode the LZMA1 properties. -lzma_filter filter = { .id = LZMA_FILTER_LZMA1 }; +lzma_filter filter = { LZMA_FILTER_LZMA1 };  if (lzma_properties_decode(&amp;amp;filter, NULL, in_buf.u8, 5) != LZMA_OK)  return false;   diff -ruN xz-5.0.4.orig/src/xz/file_io.c xz-5.0.4/src/xz/file_io.c --- xz-5.0.4.orig/src/xz/file_io.c2012-06-22 06:22:30.000000000 +0000 +++ xz-5.0.4/src/xz/file_io.c2014-03-02 03:19:58.713609000 +0000 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -518,13 +518,13 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  static file_pair pair;    pair = (file_pair){ -.src_name = src_name, -.dest_name = NULL, -.src_fd = -1, -.dest_fd = -1, -.src_eof = false, -.dest_try_sparse = false, -.dest_pending_sparse = 0, +src_name, +NULL, +-1, +-1, +false, +false, +0,  };    // Block the signals, for which we have a custom signal handler, so diff -ruN xz-5.0.4.orig/src/xz/options.c xz-5.0.4/src/xz/options.c --- xz-5.0.4.orig/src/xz/options.c2012-06-22 06:22:30.000000000 +0000 +++ xz-5.0.4/src/xz/options.c2014-03-02 03:20:31.943696000 +0000 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -173,8 +173,8 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  lzma_options_delta *options = xmalloc(sizeof(lzma_options_delta));  *options = (lzma_options_delta){  // It's hard to give a useful default for this. -.type = LZMA_DELTA_TYPE_BYTE, -.dist = LZMA_DELTA_DIST_MIN, +LZMA_DELTA_TYPE_BYTE, +LZMA_DELTA_DIST_MIN,  };    parse_options(str, opts, &amp;amp;set_delta, options); &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -215,7 +215,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    lzma_options_bcj *options = xmalloc(sizeof(lzma_options_bcj));  *options = (lzma_options_bcj){ -.start_offset = 0, +0,  };    parse_options(str, opts, &amp;amp;set_bcj, options); diff -ruN xz-5.0.4.orig/src/xz/signals.c xz-5.0.4/src/xz/signals.c --- xz-5.0.4.orig/src/xz/signals.c2012-06-22 06:22:30.000000000 +0000 +++ xz-5.0.4/src/xz/signals.c2014-03-02 03:24:28.314262000 +0000 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -49,6 +49,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  signals_init(void)  {  // List of signals for which we establish the signal handler. +struct sigaction mysa;  static const int sigs[] = {  SIGINT,  SIGTERM, &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -77,17 +78,16 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  sigaddset(&amp;amp;hooked_signals, message_progress_sigs[i]);  #endif   -struct sigaction sa;    // All the signals that we handle we also blocked while the signal  // handler runs. -sa.sa_mask = hooked_signals; +mysa.sa_mask = hooked_signals;    // Don't set SA_RESTART, because we want EINTR so that we can check  // for user_abort and cleanup before exiting. We block the signals  // for which we have established a handler when we don't want EINTR. -sa.sa_flags = 0; -sa.sa_handler = &amp;amp;signal_handler; +mysa.sa_flags = 0; +mysa.sa_handler = &amp;amp;signal_handler;    for (size_t i = 0; i &amp;lt; ARRAY_SIZE(sigs); ++i) {  // If the parent process has left some signals ignored, &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -98,7 +98,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  continue;    // Establish the signal handler. -if (sigaction(sigs[i], &amp;amp;sa, NULL)) +if (sigaction(sigs[i], &amp;amp;mysa, NULL))  message_signal_handler();  }   diff -ruN xz-5.0.4.orig/stdbool.h xz-5.0.4/stdbool.h --- xz-5.0.4.orig/stdbool.h1970-01-01 00:00:00.000000000 +0000 +++ xz-5.0.4/stdbool.h2014-03-02 02:03:08.061926000 +0000 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -0,0 +1,5 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; +#if !defined(bool) +#define bool int +#endif +#define false 0 +#define true 1 diff -ruN xz-5.0.4.orig/tests/test_block_header.c xz-5.0.4/tests/test_block_header.c --- xz-5.0.4.orig/tests/test_block_header.c2012-06-22 06:22:30.000000000 +0000 +++ xz-5.0.4/tests/test_block_header.c2014-03-02 03:28:09.384859000 +0000 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -21,58 +21,58 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    static lzma_filter filters_none[1] = {  { -.id = LZMA_VLI_UNKNOWN, +LZMA_VLI_UNKNOWN,  },  };      static lzma_filter filters_one[2] = {  { -.id = LZMA_FILTER_LZMA2, -.options = &amp;amp;opt_lzma, +LZMA_FILTER_LZMA2, +&amp;amp;opt_lzma,  }, { -.id = LZMA_VLI_UNKNOWN, +LZMA_VLI_UNKNOWN,  }  };      static lzma_filter filters_four[5] = {  { -.id = LZMA_FILTER_X86, -.options = NULL, +LZMA_FILTER_X86, +NULL,  }, { -.id = LZMA_FILTER_X86, -.options = NULL, +LZMA_FILTER_X86, +NULL,  }, { -.id = LZMA_FILTER_X86, -.options = NULL, +LZMA_FILTER_X86, +NULL,  }, { -.id = LZMA_FILTER_LZMA2, -.options = &amp;amp;opt_lzma, +LZMA_FILTER_LZMA2, +&amp;amp;opt_lzma,  }, { -.id = LZMA_VLI_UNKNOWN, +LZMA_VLI_UNKNOWN,  }  };      static lzma_filter filters_five[6] = {  { -.id = LZMA_FILTER_X86, -.options = NULL, +LZMA_FILTER_X86, +NULL,  }, { -.id = LZMA_FILTER_X86, -.options = NULL, +LZMA_FILTER_X86, +NULL,  }, { -.id = LZMA_FILTER_X86, -.options = NULL, +LZMA_FILTER_X86, +NULL,  }, { -.id = LZMA_FILTER_X86, -.options = NULL, +LZMA_FILTER_X86, +NULL,  }, { -.id = LZMA_FILTER_LZMA2, -.options = &amp;amp;opt_lzma, +LZMA_FILTER_LZMA2, +&amp;amp;opt_lzma,  }, { -.id = LZMA_VLI_UNKNOWN, +LZMA_VLI_UNKNOWN,  }  };   &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -110,10 +110,10 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  test1(void)  {  known_options = (lzma_block){ -.check = LZMA_CHECK_NONE, -.compressed_size = LZMA_VLI_UNKNOWN, -.uncompressed_size = LZMA_VLI_UNKNOWN, -.filters = NULL, +LZMA_CHECK_NONE, +LZMA_VLI_UNKNOWN, +LZMA_VLI_UNKNOWN, +NULL,  };    expect(lzma_block_header_size(&amp;amp;known_options) == LZMA_PROG_ERROR); diff -ruN xz-5.0.4.orig/tests/test_filter_flags.c xz-5.0.4/tests/test_filter_flags.c --- xz-5.0.4.orig/tests/test_filter_flags.c2012-06-22 06:22:30.000000000 +0000 +++ xz-5.0.4/tests/test_filter_flags.c2014-03-02 03:26:34.004613000 +0000 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -117,8 +117,8 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    // Test 2  lzma_options_delta options = { -.type = LZMA_DELTA_TYPE_BYTE, -.dist = 0 +LZMA_DELTA_TYPE_BYTE, +0  };  known_flags.options = &amp;amp;options;  expect(encode(99)); &lt;/pre&gt;</description>     <dc:creator>Mark Ashley</dc:creator>     <dc:date>2014-03-02T06:06:00</dc:date>   </item>   <item rdf:about=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/184\">     <title>[java] assert in SimpleInputStream's constructor</title>     <link>http://comments.gmane.org/gmane.comp.compression.xz.devel/184</link>     <description>&lt;pre&gt;Hi,  I'm in the process of adding BCJ support to Apache Commons Compress' 7z package.  Basically I do something like     X86Options.getInputStream(stream)   with XZ's X86Options class.  Which leads to an AssertionError.  X86Options does      public InputStream getInputStream(InputStream in) {         return new SimpleInputStream(in, new X86(false, startOffset));     }  and SimpleInputStream does      SimpleInputStream(InputStream in, SimpleFilter simpleFilter) {         ...         assert simpleFilter == null;  which is obviously wrong.  I think != is intended (and matches the comment right in front of the assert).  Cheers          Stefan   &lt;/pre&gt;</description>     <dc:creator>Stefan Bodewig</dc:creator>     <dc:date>2014-02-28T11:32:08</dc:date>   </item>   <item rdf:about=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/177\">     <title>Inserting Compressed Data Into Compressed File</title>     <link>http://comments.gmane.org/gmane.comp.compression.xz.devel/177</link>     <description>&lt;pre&gt;Hello, I am trying to make a compressed map file for a game I'm working  on but I'm having a bit of trouble with making changes to the compressed  file. The map files that my game creates are very big but a lot of that  data is repetitive so I what I do is I create a big empty map and then  compress it. This allows me to have massive maps within tiny files. Now  I realize they are only small because it is compressing repeated 0's but  even when the actual values of the tiles of the map are implemented they  will still be rather repetitive so the size should still remain somewhat  small.  With that being said I've been trying to find out how to write  compressed data to a compressed file. My game's map structure is  formatted in a way such that a collection of tiles is grouped into a  block. So each XZ Block contains a certain amount of tiles. What I would  like to do is when a player changes tiles of the map the map would find  the XZ Block that the modified tile is in and rewrite that entire  compressed block but with the new compressed data. From my understanding  of how the block compression works, rewriting an entire block shouldn't  be any trouble since each block is compressed separately. However, there  doesn't seem to be any way to do this. Something like  SeekableXZInputStream's \"seekToBlock(int blockNumber)\" function would be  perfect. Is there any reason a SeekableXZOutputStream was not made or  needed?  So my question is how possible is this and hard would it be? Are there  indexes of the locations of the XZ Blocks somewhere that would have to  be updated?  Thank you  &lt;/pre&gt;</description>     <dc:creator>Brandon Fergerson</dc:creator>     <dc:date>2014-02-02T22:12:33</dc:date>   </item>   <item rdf:about=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/174\">     <title>LZMA documentation</title>     <link>http://comments.gmane.org/gmane.comp.compression.xz.devel/174</link>     <description>&lt;pre&gt;Hello there!  I am currently working on a project that will utilize liblzma. I found it first inside XZ Utils and I really like its performance. But then I was kinda surprised to not find any LZMA documentation, although a lzma.h file is installed into the sytem\\ufffd\\ufffd\\ufffds default include path.  I also couldn\\ufffd\\ufffd\\ufffdt find any link on the offical xz utils site. So if anyone could link me to the correct place with the documentation, that\\ufffd\\ufffd\\ufffdd be nice.  My workstation is Mac OS X 10.9  Kind regardsm Ingwie  &lt;/pre&gt;</description>     <dc:creator>Kevin Ingwersen</dc:creator>     <dc:date>2013-12-16T20:55:14</dc:date>   </item>   <item rdf:about=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/168\">     <title>Creating an archive without timestamps</title>     <link>http://comments.gmane.org/gmane.comp.compression.xz.devel/168</link>     <description>&lt;pre&gt;How do I create an XZ compressed archive, which could be compared by md5?  Right now, running \"tar cJfp\" creates a tarball, gives it a timestamp and the rest is history, because the timestamp is always different and I cannot compare such an archive... Is it possible to avoid it?  gzip has -n, what about XZ and it's implementation on Tar?  Ernestas &lt;/pre&gt;</description>     <dc:creator>Ernestas Luko\\ufffd\\ufffdevi\\ufffd\\ufffdius</dc:creator>     <dc:date>2013-11-10T12:42:11</dc:date>   </item>   <item rdf:about=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/166\">     <title>xz: Make --block-list and --block-size work together in</title>     <link>http://comments.gmane.org/gmane.comp.compression.xz.devel/166</link>     <description>&lt;pre&gt;This makes --block-list and --block-size work together in single-thread mode, as per the FIXME  I've verified this works by testing with --block-size=3000  --block-list=1024,2048,4096 as well as stepping through the block decoder in the debugger.  For some reason, the single threaded mode still yields smaller files. I'm looking into that.    &lt;/pre&gt;</description>     <dc:creator>James M Leddy</dc:creator>     <dc:date>2013-11-02T21:55:54</dc:date>   </item>   <item rdf:about=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/163\">     <title>XZ Utils 5.1.3alpha</title>     <link>http://comments.gmane.org/gmane.comp.compression.xz.devel/163</link>     <description>&lt;pre&gt;XZ Utils 5.1.3alpha is available at &amp;lt;http://tukaani.org/xz/&amp;gt;. Here is an extract from the NEWS file:    * All fixes from 5.0.5    * liblzma:        - Fixed a deadlock in the threaded encoder.        - Made the uses of lzma_allocator const correct.        - Added lzma_block_uncomp_encode() to create uncompressed         .xz Blocks using LZMA2 uncompressed chunks.        - Added support for native threads on Windows and the ability         to detect the number of CPU cores.    * xz:        - Fixed a race condition in the signal handling. It was         possible that e.g. the first SIGINT didn't make xz exit         if reading or writing blocked and one had bad luck. The fix         is non-trivial, so as of writing it is unknown if it will be         backported to the v5.0 branch.        - Made the progress indicator work correctly in threaded mode.        - Threaded encoder now works together with --block-list=SIZES.        - Added preliminary support for --flush-timeout=TIMEOUT.         It can be useful for (somewhat) real-time streaming. For         now the decompression side has to be done with something         else than the xz tool due to how xz does buffering, but this         should be fixed.  &lt;/pre&gt;</description>     <dc:creator>Lasse Collin</dc:creator>     <dc:date>2013-10-26T14:16:34</dc:date>   </item>   <item rdf:about=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/162\">     <title>Parallel xzcat</title>     <link>http://comments.gmane.org/gmane.comp.compression.xz.devel/162</link>     <description>&lt;pre&gt;Here is a parallel implementation of xzcat:  http://git.annexia.org/?p=pxzcat.git;a=tree  Some test results:    4 cores:  xzcat: 23.8 s  pxzcat: 8.1 s   speed up: 2.9   8 cores:  xzcat: 26.8 s  pxzcat: 10.5 s  speed up: 2.55  I just wrote this as a quick hack in a couple of hours, so while it may be of interest it's not a long term solution.  (It would be better to get the xzcat -T flag working).  Notes on functionality/limitations:  (1) Unless the xz file was built using the --block-size parameter with a smallish block size (eg. 16 megabytes) then pxzcat **WILL NOT WORK**.  (2) I have not tested it with multi-stream files, but it should work with them.  (3) It requires that the input and output files are real files.  It does not work for streaming.  Notes on performance:  - Scalability is not too bad on my laptop (4 core machine above) but much worse on a theoretically higher performing machine with SSDs (8 core machine above).  I don't really understand why that is.  - For reasons I don't understand, both regular xzcat and pxzcat cause the output file to be flushed to disk after the program exits.  This causes any program which consumes the output of the file to slow down. Indeed, virt-builder (for which I wrote this) actually slows down a lot when using pxzcat.  Rich.  &lt;/pre&gt;</description>     <dc:creator>Richard W.M. Jones</dc:creator>     <dc:date>2013-10-21T21:46:25</dc:date>   </item>   <item rdf:about=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/161\">     <title>XZ for Java 1.4</title>     <link>http://comments.gmane.org/gmane.comp.compression.xz.devel/161</link>     <description>&lt;pre&gt;XZ for Java 1.4 is available at &amp;lt;http://tukaani.org/xz/java.html&amp;gt; and in the Maven Central (groupId = org.tukaani, artifactId = xz). Here is an extract from the NEWS file:    * Add LZMAInputStream for decoding .lzma files and raw LZMA streams.  &lt;/pre&gt;</description>     <dc:creator>Lasse Collin</dc:creator>     <dc:date>2013-09-22T10:22:56</dc:date>   </item>   <item rdf:about=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/158\">     <title>XZ Utils 5.0.5</title>     <link>http://comments.gmane.org/gmane.comp.compression.xz.devel/158</link>     <description>&lt;pre&gt;XZ Utils 5.0.5 is available at &amp;lt;http://tukaani.org/xz/&amp;gt;. Here is an  extract from the NEWS file:    * lzmadec and liblzma's lzma_alone_decoder(): Support decompressing     .lzma files that have less common settings in the headers     (dictionary size other than 2^n or 2^n + 2^(n-1), or uncompressed     size greater than 256 GiB). The limitations existed to avoid false     positives when detecting .lzma files. The lc + lp &amp;lt;= 4 limitation     still remains since liblzma's LZMA decoder has that limitation.      NOTE: xz's .lzma support or liblzma's lzma_auto_decoder() are NOT     affected by this change. They still consider uncommon .lzma     headers as not being in the .lzma format. Changing this would     give way too many false positives.    * xz:        - Interaction of preset and custom filter chain options was         made less illogical. This affects only certain less typical         uses cases so few people are expected to notice this change.          Now when a custom filter chain option (e.g. --lzma2) is         specified, all preset options (-0 ... -9, -e) earlier are on         the command line are completely forgotten. Similarly, when         a preset option is specified, all custom filter chain options         earlier on the command line are completely forgotten.          Example 1: \"xz -9 --lzma2=preset=5 -e\" is equivalent to \"xz         -e\" which is equivalent to \"xz -6e\". Earlier -e didn't put xz         back into preset mode and thus the example command was         equivalent to \"xz --lzma2=preset=5\".          Example 2: \"xz -9e --lzma2=preset=5 -7\" is equivalent to         \"xz -7\". Earlier a custom filter chain option didn't make         xz forget the -e option so the example was equivalent to         \"xz -7e\".        - Fixes and improvements to error handling.        - Various fixes to the man page.    * xzless: Fixed to work with \"less\" versions 448 and later.    * xzgrep: Made -h an alias for --no-filename.    * Include the previously missing debug/translation.bash which can     be useful for translators.    * Include a build script for Mac OS X. This has been in the Git     repository since 2010 but due to a mistake in Makefile.am the     script hasn't been included in a release tarball before.  &lt;/pre&gt;</description>     <dc:creator>Lasse Collin</dc:creator>     <dc:date>2013-06-30T17:02:01</dc:date>   </item>   <item rdf:about=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/156\">     <title>xz-utils streaming patch</title>     <link>http://comments.gmane.org/gmane.comp.compression.xz.devel/156</link>     <description>&lt;pre&gt;Hi,  Attached is a patch that enables 'streaming' support for xz output, in short LZMA_SYNC_FLUSH is  called every X milliseconds.  We find it helpful so that we can effectively do: ---- tail -f foobar.log.xz | nc w.x.y.z 1234 ----  Meanwhile foobar.log.xz is effectively being generated with: ---- tail -f foobar.log | xz -c --select-timeout 500 &amp;gt; foobar.log.xz ----  This means the receiver then gets something that is decodeable in X milliseconds rather than  having to wait for a whole block to be generated and flushed, which might be a considerable time  if whatever is writing to foobar.log is low volume (100 bytes per second for example).  The patch is for 5.0.0 (what is currently in Debian 'oldstable/squeeze') but if the community  likes the look of the patch, I can roll a version for whatever is at the HEAD of the git tree.  Feedback welcomed.  Cheers  &lt;/pre&gt;</description>     <dc:creator>Alexander Clouter</dc:creator>     <dc:date>2013-06-26T18:18:11</dc:date>   </item>   <item rdf:about=\"http://comments.gmane.org/gmane.comp.compression.xz.devel/152\">     <title>Random access to xz files</title>     <link>http://comments.gmane.org/gmane.comp.compression.xz.devel/152</link>     <description>&lt;pre&gt;Hi,  I'm trying to write an NBD driver for XZ files.  This requires random access to the files.  So far I've have loaded the index from the file, and I'm using lzma_index_iter_locate (successfully) to locate the block and uncompressed offset that contains the byte of interest.  However I'm stuck as to where I go from there.  I am able to decode the block header using lzma_block_header_decode. But should I need to do that?  Isn't the block already \"loaded\" in the index?  I'm also able to read the data from the block (although decoding fails at the end of the block -- I don't understand why).  Here is my current code -- see especially the function 'xzfile_pread' in the first file:  http://oirase.annexia.org/tmp/xzfile.c http://oirase.annexia.org/tmp/xzfile.h http://oirase.annexia.org/tmp/xz.c  I suppose the answer is \"no\", but is this stuff documented anywhere?  Rich.  &lt;/pre&gt;</description>     <dc:creator>Richard W.M. Jones</dc:creator>     <dc:date>2013-06-23T10:25:05</dc:date>   </item>   <textinput rdf:about=\"http://search.gmane.org/?group=$group=gmane.comp.compression.xz.devel\">     <title>Search Engine</title>     <description>Search the mailing list at Gmane</description>     <name>query</name>     <link>http://search.gmane.org/?group=$group=gmane.comp.compression.xz.devel</link>   </textinput> </rdf:RDF> ", 
    "identity": {
        "subtype": "dataset", 
        "is_error": false, 
        "version": "", 
        "protocol": "RDF", 
        "language": "", 
        "service": "", 
        "has_dataset": false, 
        "has_metadata": false
    }, 
    "digest": "487e74f3bf4be7d9ab17d7d643552e85", 
    "source_url": "http://rss.gmane.org/topics/complete/gmane.comp.compression.xz.devel"
}