{
    "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?> <!DOCTYPE spec PUBLIC \"-//W3C//DTD Specification V2.6//EN\"                \"http://www.w3.org/2002/xmlspec/dtd/2.6/xmlspec.dtd\" [   <!-- ================================================================ -->   <!ENTITY draft.day \"14\">   <!ENTITY draft.month \"01\">   <!ENTITY draft.monthname \"January\">   <!ENTITY draft.year \"2004\">   <!ENTITY iso6.doc.date \"&draft.year;-&draft.month;-&draft.day;\">   <!ENTITY http-ident \"http://www.w3.org/2001/tag/doc/qnameids\"> ]> <spec w3c-doctype='other'> <?CVS $Id: qnameids.xml,v 1.12 2004/01/14 18:58:16 NormanWalsh Exp $?> <header> <title>Using Qualified Names (QNames) as Identifiers in Content</title> <w3c-designation>&http-ident;-&iso6.doc.date;</w3c-designation> <w3c-doctype>[Editor\\ufffd\\ufffd\\ufffds Draft] TAG Finding</w3c-doctype> <pubdate><day>&draft.day;</day> <month>&draft.monthname;</month> <year>&draft.year;</year> </pubdate> <publoc> <loc href=\"&http-ident;-&iso6.doc.date;\">&http-ident;-&iso6.doc.date;</loc> </publoc> <altlocs> <loc href=\"&http-ident;-&iso6.doc.date;.xml\">XML</loc> <loc href=\"&http-ident;-&iso6.doc.date;-diff.html\">2003-11-06 Diff</loc> </altlocs> <latestloc> <loc href=\"&http-ident;\">&http-ident;</loc> </latestloc> <prevlocs> <loc href=\"&http-ident;-2003-01-06\">&http-ident;-2004-01-06</loc> <loc href=\"&http-ident;-2003-11-03\">&http-ident;-2003-11-03</loc> <loc href=\"&http-ident;-2002-07-15\">&http-ident;-2002-07-15</loc> </prevlocs> <authlist> <author><name>Norman Walsh</name> <affiliation>Sun Microsystems, Inc.</affiliation> <email href=\"mailto:Norman.Walsh@Sun.COM\">Norman.Walsh@Sun.COM</email></author> </authlist> <copyright> <p> <loc href=\"http://www.w3.org/Consortium/Legal/ipr-notice-20000612#Copyright\">Copyright</loc> &#xA9; 2004 <loc href=\"http://www.w3.org/\">W3C</loc><sup>&#xAE;</sup> (<loc href=\"http://www.lcs.mit.edu/\">MIT</loc>, <loc href=\"http://www.inria.fr/\">INRIA</loc>, <loc href=\"http://www.keio.ac.jp/\">Keio</loc>), All Rights Reserved. W3C <loc href=\"http://www.w3.org/Consortium/Legal/ipr-notice-20000612#Legal_Disclaimer\">liability</loc>, <loc href=\"http://www.w3.org/Consortium/Legal/ipr-notice-20000612#W3C_Trademarks\">trademark</loc>, <loc href=\"http://www.w3.org/Consortium/Legal/copyright-documents-19990405\">document use</loc>, and <loc href=\"http://www.w3.org/Consortium/Legal/copyright-software-19980720\">software licensing</loc> rules apply. </p></copyright>  <abstract> <p>The question that prompted this finding was \"are QNames acceptable replacements for URIs as identifiers within specifications?\" This finding documents the TAG's opinion on the use of QNames as identifiers.</p> </abstract>  <status> <p>This document has been developed for discussion by the <loc href=\"/2001/tag/\">W3C Technical Architecture Group</loc>. This finding addresses <loc href=\"http://www.w3.org/2001/tag/ilist#qnameAsId-18\">issue qnameAsId-18</loc>.</p>  <p>This finding was drafted by the editor for discussion by the TAG and has no normative status at this time.</p>  <p><loc href=\"/2001/tag/findings\">Additional TAG findings</loc>, both approved and in draft state, may also be available. The TAG expects to incorporate this and other findings into a Web Architecture Document that will be published according to the process of the <loc href=\"/Consortium/Process-20010719/tr#Recs\">W3C Recommendation Track</loc>.</p>  <p>Please send comments on this finding to the publicly archived TAG mailing list <loc href=\"mailto:www-tag@w3.org\">www-tag@w3.org</loc> (<loc href=\"http://lists.w3.org/Archives/Public/www-tag/\">archive</loc>).</p>  </status> <pubstmt> <p>Chicago, Vancouver, Mountain View, et al.: World-Wide Web Consortium, Draft TAG Finding, 2004.</p> </pubstmt> <sourcedesc> <p>Created in electronic form.</p> </sourcedesc> <langusage> <language id=\"EN\">English</language> </langusage> <revisiondesc> <slist> <sitem>2002-04-30: Published draft</sitem> </slist> </revisiondesc> </header> <body>  <div1 id=\"preface\"> <head>Preface</head>  <p>This TAG Finding documents a portion of the web architecture where conflicting requirements and design goals intersect. It is a simple matter of fact that specifications which have chosen one set of design criteria interoperate less well with specifications that have chosen a different set.</p>  <p>Given that there are existing specifications which exhibit incompatible designs and strong arguments in favor of each design, the TAG elects not to assert architectural principles that would be in direct conflict with some significant set of specifications.</p>  <p>It's possible that these issues could be addressed in the scope of some larger, more global redesign of, for example, XML, but no short-term solution presents itself</p> </div1>  <div1 id=\"sec-qnamesids\"> <head>QNames as Identifiers</head>  <p>This finding is concerned with the use of qualified names (QNames) as identifiers. That is, the contexts in which a colonized name can be understood to be a QName.</p>  <p>A related TAG issue, <loc href=\"http://www.w3.org/2001/tag/ilist#rdfmsQnameUriMapping-6\">rdfmsQnameUriMapping-6</loc>, concerns the mechanism by which one can (or can not) construct a URI for a particular QName. We do not consider that issue in this finding.</p>  </div1>  <div1 id=\"sec-qnames-xml\"> <head>QNames in XML</head>  <p>Qualified names were introduced by <bibref ref=\"xml-names\"/>. They were defined for element and attribute <emph>names</emph> (only) and provide a mechanism for concisely identifying a {URI, local-name} pair. For example, in the following document:</p>  <eg><![CDATA[ <?xml version='1.0'?> <doc xmlns:x=\"http://example.com/ns/foo\"> <x:p/> </doc>]]></eg>  <p>The QName <quote><code>x:p</code></quote> is a concise, unambiguous name for the {URI, local-name} pair <code>{\"http://example.com/ns/foo\", \"p\"}</code>.</p>  <p>When used solely in element and attribute names, all QNames are identified by the XML processor and can logically be replaced by the URI/local-name pair they identify.</p> </div1>  <div1 id=\"sec-cname-ids\"> <head>QNames in Other Contexts</head>  <p>At the request of the XML Schema Working Group, the XML Core Working Group is producing <loc href=\"http://www.w3.org/XML/xml-names-19990114-errata#NE08\">an erratum</loc> to <bibref ref=\"xml-names\"/> to clarify the meaning of colons in other contexts.</p>  <p>In particular, this erratum makes it clear that entity names, processing instruction targets, and notation names are not QNames and they may not include colons. Documents that do not satisfy this constraint are not namespace well-formed. Furthermore, the <emph>values</emph> of attributes of type ID, IDREF(S), ENTITY(IES), and NOTATION are also forbidden from containing colons. Documents that do not satisfy this constraint are not namespace valid. </p>  <p>A colon that introduces a namespace validity or namespace well-formedness error into a document <emph>does not</emph> introduce a QName. In other words, the term \"identifier\" in this finding is not related to XML identifiers of type ID since they cannot be QNames.</p>  <div2 id=\"sec-qnames-other\"> <head>QNames in Other Specifications</head>  <p>Other specifications, starting with <bibref ref=\"xslt\"/>, have taken QNames and employed them in contexts other than element and attribute names. Specifically, QNames have been used in attribute <emph>values</emph> and element <emph>content</emph>. </p>  <p>For example, in the following document, <quote><code>x:p</code></quote> is understood to be a QName even though it appears in an attribute value, not an element or attribute name.</p>  <eg><![CDATA[ <?xml version='1.0'?> <xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"                 xmlns:x=\"http://example.com/ns/foo\"                 version=\"1.0\">  <xsl:output method=\"html\"/>  <xsl:template match=\"x:p\">   <p>     <xsl:apply-templates/>   </p> </xsl:template>  </xsl:stylesheet> </doc>]]></eg>  <p>In attribute values and element content, QNames are often used to identify a particular element type; they are, in principle, using QNames as they were intended. However, some specifications use QNames as shortcuts for unique identifiers derived from a {URI, local-name} pair that have no relationship to element or attribute types.</p>  <p>The <bibref ref=\"fando\"/> specification, for example, uses QNames to identify functions. This is motivated partly by backwards compatibility with XPath 1.0, but also by the fact that function names share some characteristics with element and attribute names. In particular, the names need to be globally unique so that name collisions don\\ufffd\\ufffd\\ufffdt occur either between independently developed functions or different versions of the specification.</p>  <p>Using a QName as a shortcut for a {URI, local-name} pair is often convenient, but it carries a price. There is no single, accepted way to convert QNames into {URI, local-name} pairs or vice versa. Different specifications have chosen different algorithms. This means that even if a QName can be identified in content, it may be difficult or impossible to determine what {URI, local-name} it represents. The mapping depends on the context in which it occurs, therefore, at the very least, it is important for specifications to identify the mapping algorithm that they have chosen.</p>  <p role=\"principle\">Specifications that use QNames to represent {URI, local-name} pairs <rfc2119>MUST</rfc2119> describe the algorithm that is used to map between them.</p>  <p>We observe also that there is an overlap in the lexical space of QNames and URIs.</p>  <p role=\"practice\">Specifications that use QNames to represent {URI, local-name} pairs <rfc2119>SHOULD NOT</rfc2119> allow both forms in attribute values or element content where they would be indistinguishable.</p> </div2>  <div2 id=\"bindings\"> <head>Namespace Bindings</head>  <p>Specifications for XML-based languages usually rely on the in-scope namespace bindings in the XML document to associate prefixes with namespace names.</p>  <p>Using the in-scope namespace bindings has the advantage that it theoretically allows a generic processor to interpret QNames in content without having to be aware of any application-specific mechanisms. The alternative, where every specification defines its own mechansism, could clearly lead to a badly fragmented web.</p>  <p>However, there is at least one application where a compelling argument has been made for <emph>requiring</emph> an alternative mechanism for defining namespace bindings. That application is <bibref ref=\"xpointer-framework\"/>. </p>  <p>It is an architectural principle of URIs that they be context-independent. It follows that the QNames that appear in an XPointer must not refer to in-scope namespaces as this would make transcription impossible in the general case.</p>  <p>We must therefore accept that there are some applications which use in-scope namespaces and some which use their own mechanisms.</p> </div2> </div1>  <div1 id=\"sec-archobs\"> <head>Architectural Observations</head>  <p>The TAG makes the following observations:</p>  <ulist>  <item><p>Whatever the architectural ramifications of using QNames as identifiers in contexts other than XML element and attribute names, it is already established practice.</p>  <p>It is simply not practical to suggest that this usage should be forbidden on architectural grounds.</p> </item>  <item><p>Using QNames in untyped (<code>#PCDATA</code> or <code>xs:string</code>) attribute values or element content places an additional burden on the processor that was not anticipated by <bibref ref=\"xml-names\"/>. </p>  <p>If QNames are only used in element and attribute <emph>names</emph>, the processor can fully resolve all of the prefixes as it parses. This gives it the freedom to discard the prefix-to-URI mappings when they go out of scope. A serializer, presented with an object model that conforms to <bibref ref=\"xml-names\"/> can manufacture new prefixes on the fly. (In practice, users expect most prefixes to be preserved through transformations, so things aren't quite this simple for most developers, but this is still theoretically the case.)</p>  <p>As soon as QNames may appear in element or attribute <emph>values</emph>, the processor must retain all of the prefix-to-URI mappings (and any API must expose these mappings). This is necessary because some subsequent micro-parser, in the course of examining some content, may encounter a token that it recognizes as a QName and need to find its {URI, local-name}.</p>  <p>In our previous XSL example, from the perspective of the XML processor, there are no qualified names that use the <code>x:</code> prefix. However, when the <emph>XSL</emph> processor examines the <att>match</att> attribute on <el>xsl:template</el>, it must be able to resolve the <code>x:</code> prefix.</p>  </item> <item><p>QNames in attribute values or element content <emph>by themselves</emph>, in other words, in contexts that could be typed as <code>xs:QName</code> (<bibref ref=\"xmlschema-2\"/>) in a schema, could in principle be identified by the schema processor.</p>  <p>For example, given:</p>  <eg><![CDATA[<elem ref=\"data:myInteger\"/>]]></eg>  <p>If schema validation reveals that the following component applies to this instance of the <el>elem</el> element:</p>  <eg><![CDATA[<xs:complexType name=\"elemType\">   <xs:complexContent>     <xs:restriction base=\"xs:anyType\">       <xs:attribute name=\"ref\" type=\"xs:QName\"/>     </xs:restriction>   </xs:complexContent> </xs:complexType>]]></eg>  <p>The schema processor can determine that <code>data:myInteger</code> is a QName and must therefore be a concise name for the {URI, local-name} pair consisting of the in-scope namespace URI for the prefix <code>data</code> and the local-name <code>myInteger</code>.</p> </item>  <item><p>Perhaps the most common use of QNames in untyped values at the moment is in locations where XPath expressions may occur. As XPath is reused in more and more specifications, it may eventually be reasonable to define an XPath data type to identify all of these values in a way that makes them accessible to higher-level parsers.</p> </item>  <item><p>Some specifications rely on mechanisms other than in-scope namespaces to associate prefixes with namespace names. In general, therefore, even when <emph>all</emph> of the in-scope namespace declarations are available, there may still be prefixes which can only be known in an application-dependent manner.</p> </item>  <item><p>Almost every specification that has wrestled with what XML documents mean or how two putatively identical documents can be compared has stumbled over the issues associated with QNames in content. Some of these issues are described in detail in <bibref ref=\"canonical-xml\"/>, but they are also known to have occurred in the development of RDF, XML Query, security specifications such as <bibref ref=\"xml-dsig\"/>, and elsewhere. </p></item> </ulist> </div1>  <div1 id=\"sec-archrec\"> <head>Architectural Statement</head>  <p>In so far as the identification mechanism of the Web is the URI and QNames are not URIs, it is a mistake to use a QName for identification when a URI would serve equally well.</p>  <p>That said, the TAG recognizes that there are sometimes pragmatic reasons for chosing short, lexical representations of more complex names and accepts that QNames are an established mechanism for doing so. Further, it must be observed that some things <emph>are</emph> identified by QNames: element and attribute names, types in W3C XML Schema, etc.</p>  <p>Where there is a compelling reason to use QNames instead of URIs for identification, it is imperative that specifications provide a mapping between QNames and URIs, if such a mapping is possible.</p>  <p>Finally, we observe that a whole class of interpretation problems can be avoided if the use of QNames can be restricted to contexts where their identification is natural and unambiguous (element and attribute names, simple content of type <code>xs:QName</code>, etc.) and we encourage developers to employ such restrictions wherever possible.</p>  </div1>  <div1 id=\"references\"> <head>References</head>  <blist> <bibl id=\"canonical-xml\" href=\"http://www.w3.org/TR/xml-c14n\" key=\"Canonical XML\">John Boyer, editor. <titleref>Canonical XML Version 1.0</titleref>. World Wide Web Consortium, 2001.</bibl>  <bibl id=\"xpointer-framework\" href=\"http://www.w3.org/TR/xptr-framework/\" key=\"XPointer Framework\">Paul Grosso, Eve Maler, Jonathan Marsh, Norman Walsh, editors. <titleref>XPointer Framework</titleref>. World Wide Web Consortium, 2002.</bibl>  <bibl id=\"xmlschema-2\" href=\"http://www.w3.org/TR/xmlschema-2/\" key=\"XML Datatypes\">Paul V. Biron and Ashok Malhotra, editors. <titleref>XML Schema Part 2: Datatypes</titleref>. World Wide Web Consortium, 2000. </bibl>  <bibl id=\"xml-names\" href=\"http://www.w3.org/TR/REC-xml-names/\" key=\"XML Namespaces\">Tim Bray, Dave Hollander, Andrew Layman, editors. <titleref>Namespaces in XML</titleref>. World Wide Web Consortium, 1999.</bibl>  <bibl id=\"xml-dsig\" href=\"http://www.w3.org/TR/xmldsig-core/\" key=\"XML-DSig Core\">Donald Eastlake, Joseph Reagle, and David Solo, editors. <titleref>XML-Signature Syntax and Processing</titleref>. World Wide Web Consortium, 2002.</bibl>  <bibl id=\"xslt\" href=\"http://www.w3.org/TR/xslt\" key=\"XSLT\">James Clark, editor. <titleref>XML Transformations (XSLT) Version 1.0</titleref>. World Wide Web Consortium, 1999.</bibl>  <bibl id=\"fando\" href=\"http://www.w3.org/TR/xpath-functions/\" key=\"Functions and Operators\">Ashok Malhotra, Jim Melton, and Norman Walsh, editors. <titleref>XQuery 1.0 and XPath 2.0 Functions and Operators</titleref>. World Wide Web Consortium, 2003. </bibl> </blist> </div1> </body> <back> <inform-div1 id=\"c14n-use-case\"> <head>Use Case: XML Canonicalization</head>  <p>Suppose you want to answer the question, \\ufffd\\ufffd\\ufffdare two XML documents the same?\\ufffd\\ufffd\\ufffd One way to attempt to answer this question is to define a canonical representation for an XML document and then compare the two canonical representations to see if they are the same. This use case provides a nice demonstration of the issues discussed in this finding. </p>  <p>Imagine for a moment that we aren\\ufffd\\ufffd\\ufffdt concerned with QNames in content and consider these two documents:</p>  <example id=\"d1\"><head>Document A</head> <eg><![CDATA[<doc xmlns=\"http://example.org/ns/one\">   <t:title xmlns:t=\"http://example.org/ns/one\">     Title   </t:title>   <div xmlns:t=\"http://example.org/ns/two\"        xmlns:u=\"http://example.org/ns/three\">     <title u:attr=\"1\">       Division Title     </title>     <t:para xmlns:u=\"http://example.org/ns/three\"             u:a1=\"one\" u:a2='two'    u:a3='three'>Text</t:para>   </div> </doc>]]></eg> </example>  <example id=\"d2\"><head>Document B</head> <eg><![CDATA[ <r:doc xmlns:r=\"http://example.org/ns/one\"        xmlns:z=\"http://example.org/ns/four\">   <a:title xmlns:a=\"http://example.org/ns/one\">     Title   </a:title>   <r:div xmlns:u=\"http://example.org/ns/three\"          xmlns:a=\"http://example.org/ns/two\">     <r:title u:attr=\"1\">       Division Title     </r:title>     <a:para x:a1=\"one\" x:a3='three' x:a2='two'             xmlns:x=\"http://example.org/ns/three\">Text</a:para>   </r:div> </r:doc>]]></eg> </example>  <p>Are they the same? At first glance, it probably isn\\ufffd\\ufffd\\ufffdt clear if they\\ufffd\\ufffd\\ufffdre the same or not. Two make the problem easier, we can define some rules for canonicalization:</p>  <ulist> <item><p>Normalize insignificant whitespace.</p></item> <item><p>Normalize attribute order (lexicographically)</p></item> <item><p>Normalize attribute quote marks.</p></item> <item><p>Discard unnecessary and duplicate namespace declarations.</p></item> <item><p>Assign standard prefixes to namespace names.</p></item> <item><p>etc.</p></item> </ulist>  <p>Under these rules, Document A would be transformed to:</p>  <example id=\"d1c\"><head>Canonical Document A</head> <eg><![CDATA[<a1:doc xmlns:a1=\"http://example.org/ns/one\">   <a1:title>     Title   </a1:title>   <a1:div xmlns:a2=\"http://example.org/ns/three\"           xmlns:a3=\"http://example.org/ns/two\">     <a1:title a2:attr=\"1\">       Division Title     </a1:title>     <a3:para a2:a1=\"one\" a2:a2=\"two\" a2:a3=\"three\">Text</a3:para>   </a1:div> </a1:doc>]]></eg> </example>  <p>And, in fact, so would Document B, demonstrating that they are the same.</p>  <p>Now consider the case where QNames may occur in content. Suppose we begin with this document:</p>  <example id=\"d3\"><head>Document C</head> <eg><![CDATA[<doc xmlns=\"http://example.org/ns/one\">   <t:title xmlns:t=\"http://example.org/ns/one\">     Title {t:title}   </t:title>   <div xmlns:t=\"http://example.org/ns/two\"        xmlns:u=\"http://example.org/ns/three\">     <title u:attr=\"1\" t:attr=\"u:expr\">       Division Title     </title>     <t:para xmlns:u=\"http://example.org/ns/three\"             u:a1=\"one\" u:a2='two'    u:a3='three'>Text</t:para>   </div> </doc>]]></eg> </example>  <p>By our canonicalization rules, this would become:</p>  <example id=\"d3c-broken\"><head>Badly Canonical Document C</head> <eg><![CDATA[<a1:doc xmlns:a1=\"http://example.org/ns/one\">   <a1:title>     Title {t:title}   </a1:title>   <a1:div xmlns:a2=\"http://example.org/ns/three\"           xmlns:a3=\"http://example.org/ns/two\">     <title a2:attr=\"1\" a3:attr=\"u:expr\">       Division Title     </title>     <a3:para a2:a1=\"one\" a2:a2=\"two\" a2:a3=\"three\">Text</a3:para>   </a1:div> </a1:doc>]]></eg> </example>  <p>Unfortunately, we\\ufffd\\ufffd\\ufffdve destroyed the information content of the document.</p>  <p>If we wish to preserve the information content of the document, we must be much more conservative. It\\ufffd\\ufffd\\ufffds no longer appropriate to throw away duplicate namespace declarations (unless they declare the same prefix and URI) or change prefixes:</p>  <example id=\"d3c\"><head>Canonical Document C</head> <eg><![CDATA[<doc xmlns=\"http://example.org/ns/one\">   <t:title xmlns:t=\"http://example.org/ns/one\">     Title {t:title}   </t:title>   <div xmlns:t=\"http://example.org/ns/two\"        xmlns:u=\"http://example.org/ns/three\">     <title u:attr=\"1\" t:attr=\"u:expr\">       Division Title     </title>     <t:para u:a1=\"one\" u:a2=\"two\" u:a3=\"three\">Text</t:para>   </div> </doc>]]></eg> </example>  <p>Under these rules, differences in the canonical representations of two documents do not necessarily constitute real differences. (Comparison of different documents is not the only use case for canonicalization, however, so it is not without value.)</p>  <p>For a much more complete discussion of these issues, see <bibref ref=\"canonical-xml\"/> where they are addressed in detail and a complete description of reasonable \\ufffd\\ufffd\\ufffdconservative\\ufffd\\ufffd\\ufffd algorithm is described.</p>  </inform-div1> </back> </spec> ", 
    "identity": {
        "subtype": "", 
        "is_error": false, 
        "version": "", 
        "protocol": "", 
        "language": "", 
        "service": "", 
        "has_dataset": false, 
        "has_metadata": false
    }, 
    "digest": "20be6481d1a22568f637c4499506920d", 
    "source_url": "http://www.w3.org/2001/tag/doc/qnameids-2004-01-14.xml"
}