{
    "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?> <rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns=\"http://purl.org/rss/1.0/\" xmlns:taxo=\"http://purl.org/rss/1.0/modules/taxonomy/\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:syn=\"http://purl.org/rss/1.0/modules/syndication/\" xmlns:admin=\"http://webns.net/mvcb/\">   <channel rdf:about=\"http://blog.gmane.org/gmane.comp.lib.agar.scm\">     <title>gmane.comp.lib.agar.scm</title>     <link>http://blog.gmane.org/gmane.comp.lib.agar.scm</link>     <description/>     <syn:updatePeriod>hourly</syn:updatePeriod>     <syn:updateFrequency>1</syn:updateFrequency>     <syn:updateBase>1901-01-01T00:00+00:00</syn:updateBase>     <items>       <rdf:Seq>         <rdf:li rdf:resource=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1969\"/>         <rdf:li rdf:resource=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1968\"/>         <rdf:li rdf:resource=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1967\"/>         <rdf:li rdf:resource=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1966\"/>         <rdf:li rdf:resource=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1965\"/>         <rdf:li rdf:resource=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1964\"/>         <rdf:li rdf:resource=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1963\"/>         <rdf:li rdf:resource=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1962\"/>         <rdf:li rdf:resource=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1961\"/>         <rdf:li rdf:resource=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1960\"/>         <rdf:li rdf:resource=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1959\"/>         <rdf:li rdf:resource=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1958\"/>         <rdf:li rdf:resource=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1957\"/>         <rdf:li rdf:resource=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1956\"/>         <rdf:li rdf:resource=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1955\"/>         <rdf:li rdf:resource=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1954\"/>         <rdf:li rdf:resource=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1953\"/>         <rdf:li rdf:resource=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1952\"/>         <rdf:li rdf:resource=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1951\"/>         <rdf:li rdf:resource=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1950\"/>       </rdf:Seq>     </items>     <image rdf:resource=\"http://gmane.org/img/gmane-25t.png\"/>     <textinput rdf:resource=\"\"/>   </channel>   <image rdf:about=\"http://gmane.org/img/gmane-25t.png\">     <title>Gmane</title>     <url>http://gmane.org/img/gmane-25t.png</url>     <link>http://gmane.org</link>   </image>   <item rdf:about=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1969\">     <title>Agar: r9787 - trunk/tests</title>     <link>http://permalink.gmane.org/gmane.comp.lib.agar.scm/1969</link>     <description>&lt;pre&gt;Author: vedge Date: 2015-03-18 23:24:12 -0400 (Wed, 18 Mar 2015) New Revision: 9787  Modified:    trunk/tests/agartest.c Log: ignore the '-psn' argument passed to applications started by Finder on OSX.   Modified: trunk/tests/agartest.c =================================================================== --- trunk/tests/agartest.c2015-03-13 04:11:36 UTC (rev 9786) +++ trunk/tests/agartest.c2015-03-19 03:24:12 UTC (rev 9787) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -455,8 +455,10 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    TAILQ_INIT(&amp;amp;tests);   -while ((c = AG_Getopt(argc, argv, \"?hd:t:\", &amp;amp;optArg, &amp;amp;optInd)) != -1) { +while ((c = AG_Getopt(argc, argv, \"p:?hd:t:\", &amp;amp;optArg, &amp;amp;optInd)) != -1) {  switch (c) { +case 'p': +break;  case 'd':  driverSpec = optArg;  break; &lt;/pre&gt;</description>     <dc:creator>Agar-SVN</dc:creator>     <dc:date>2015-03-19T03:24:12</dc:date>   </item>   <item rdf:about=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1968\">     <title>Agar: r9786 - trunk/gui</title>     <link>http://permalink.gmane.org/gmane.comp.lib.agar.scm/1968</link>     <description>&lt;pre&gt;Author: vedge Date: 2015-03-13 00:11:36 -0400 (Fri, 13 Mar 2015) New Revision: 9786  Modified:    trunk/gui/drv_cocoa.m Log: avoid referencing a bad drawable in PostResize; set up autorelease pool in Close and PostResize.   Modified: trunk/gui/drv_cocoa.m =================================================================== --- trunk/gui/drv_cocoa.m2015-03-06 04:53:57 UTC (rev 9785) +++ trunk/gui/drv_cocoa.m2015-03-13 04:11:36 UTC (rev 9786) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1,5 +1,5 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  /* - * Copyright (c) 2012-2013 Hypertriton, Inc. &amp;lt;http://hypertriton.com/&amp;gt; + * Copyright (c) 2012-2015 Hypertriton, Inc. &amp;lt;http://hypertriton.com/&amp;gt;   * All rights reserved.   *   * Redistribution and use in source and binary forms, with or without &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -203,7 +203,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    _driver = co;  _window = AGDRIVER_MW(co)-&amp;gt;win; - +  nc = [NSNotificationCenter defaultCenter];    if ([win delegate] != nil) { &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -236,7 +236,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_DriverCocoa *co = _driver;  NSWindow *win = co-&amp;gt;win;  NSView *view = [win contentView]; - +  nc = [NSNotificationCenter defaultCenter];    if ([win delegate] != self) { &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -652,7 +652,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  case NSRightMouseDown:  {  AG_MouseButton btn = GetMouseButton([event buttonNumber]); - +  AG_MouseButtonUpdate(drv-&amp;gt;mouse, AG_BUTTON_PRESSED, btn);  dev-&amp;gt;type = AG_DRIVER_MOUSE_BUTTON_DOWN;  dev-&amp;gt;win = win; &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -823,7 +823,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  if (dev-&amp;gt;win == NULL ||      dev-&amp;gt;win-&amp;gt;flags &amp;amp; AG_WINDOW_DETACHING)  return (0); - +  AG_LockVFS(&amp;amp;agDrivers);  drv = WIDGET(dev-&amp;gt;win)-&amp;gt;drv;   &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -887,10 +887,8 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  {  NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];   -if (win-&amp;gt;visible) { -[co-&amp;gt;glCtx setView:[co-&amp;gt;win contentView]]; -[co-&amp;gt;glCtx update]; -} +[co-&amp;gt;glCtx setView:[co-&amp;gt;win contentView]]; +[co-&amp;gt;glCtx update];  [co-&amp;gt;glCtx makeCurrentContext];    [pool release]; &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -911,7 +909,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_DriverCocoa *co = (AG_DriverCocoa *)WIDGET(win)-&amp;gt;drv;  AG_GL_Context *gl = &amp;amp;co-&amp;gt;gl;  AG_Color c = WCOLOR(win,0); - +  gl-&amp;gt;clipStates[0] = glIsEnabled(GL_CLIP_PLANE0); glEnable(GL_CLIP_PLANE0);  gl-&amp;gt;clipStates[1] = glIsEnabled(GL_CLIP_PLANE1); glEnable(GL_CLIP_PLANE1);  gl-&amp;gt;clipStates[2] = glIsEnabled(GL_CLIP_PLANE2); glEnable(GL_CLIP_PLANE2); &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -931,7 +929,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_DriverCocoa *co = obj;  AG_GL_Context *gl = &amp;amp;co-&amp;gt;gl;  Uint i; - +  [co-&amp;gt;glCtx flushBuffer];    /* Remove textures and display lists queued for deletion. */ &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1047,9 +1045,6 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  /* Set our event listener. */  [co-&amp;gt;evListener listen:co];   -/* Get the visibility status. */ -win-&amp;gt;visible = [co-&amp;gt;win isVisible]; -  /* Retrieve the effective style flags. */  winStyle = [co-&amp;gt;win styleMask];  if (winStyle == NSBorderlessWindowMask) { &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1083,10 +1078,6 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  }  pfAttr[i++] = NSOpenGLPFADoubleBuffer;  if (agStereo) { pfAttr[i++] = NSOpenGLPFAStereo; } -#if 0 -pfAttr[i++] = NSOpenGLPFAScreenMask; -pfAttr[i++] = CGDisplayIDToOpenGLDisplayMask(display); -#endif  pfAttr[i] = 0;  pf = [[NSOpenGLPixelFormat alloc] initWithAttributes:pfAttr];  if (pf == nil) { &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1099,7 +1090,8 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_SetError(\"Cannot create NSOpenGLContext\");  goto fail;  } -COCOA_GL_MakeCurrent(co, win); +[co-&amp;gt;glCtx update]; +[co-&amp;gt;glCtx makeCurrentContext];  if (AG_GL_InitContext(co, &amp;amp;co-&amp;gt;gl) == -1)  goto fail;   &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1150,6 +1142,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  {  AG_Driver *drv = WIDGET(win)-&amp;gt;drv;  AG_DriverCocoa *co = (AG_DriverCocoa *)drv; +NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];    AG_MutexLock(&amp;amp;co-&amp;gt;lock);   &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1175,6 +1168,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  drv-&amp;gt;videoFmt = NULL;    AG_MutexUnlock(&amp;amp;co-&amp;gt;lock); +[pool release];  }    static int &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1302,6 +1296,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  static void  COCOA_PostResizeCallback(AG_Window *win, AG_SizeAlloc *a)  { +NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];  AG_Driver *drv = WIDGET(win)-&amp;gt;drv;  AG_DriverCocoa *co = (AG_DriverCocoa *)drv;  int x = a-&amp;gt;x; &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1317,7 +1312,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_WidgetUpdateCoords(win, 0, 0);    /* The viewport coordinates have changed. */ -COCOA_GL_MakeCurrent(co, win); +[co-&amp;gt;glCtx makeCurrentContext];  AG_GL_SetViewport(&amp;amp;co-&amp;gt;gl, AG_RECT(0, 0, WIDTH(win), HEIGHT(win)));    #if MAC_OS_X_VERSION_MIN_REQUIRED &amp;gt;= 1050 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1344,6 +1339,8 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  /* Save the new effective window position. */  WIDGET(win)-&amp;gt;x = a-&amp;gt;x = x;  WIDGET(win)-&amp;gt;y = a-&amp;gt;y = y; + +[pool release];  }    static void &lt;/pre&gt;</description>     <dc:creator>Agar-SVN</dc:creator>     <dc:date>2015-03-13T04:11:39</dc:date>   </item>   <item rdf:about=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1967\">     <title>Agar: r9785 - trunk/gui</title>     <link>http://permalink.gmane.org/gmane.comp.lib.agar.scm/1967</link>     <description>&lt;pre&gt;Author: vedge Date: 2015-03-05 23:53:57 -0500 (Thu, 05 Mar 2015) New Revision: 9785  Modified:    trunk/gui/menu.c Log: in AG_MenuCollapse(), invalidate the surface handles only after the window has been detached (using `window-detached')   Modified: trunk/gui/menu.c =================================================================== --- trunk/gui/menu.c2015-03-06 04:43:03 UTC (rev 9784) +++ trunk/gui/menu.c2015-03-06 04:53:57 UTC (rev 9785) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -208,6 +208,29 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  return (win);  }   +static void +MenuWindowDetached(AG_Event *event) +{ +AG_Menu *m = AG_PTR(1); +AG_MenuItem *mi = AG_PTR(2); +AG_MenuItem *miSub; +Uint j; + +AG_ObjectLock(m); + +mi-&amp;gt;view = NULL; +mi-&amp;gt;sel_subitem = NULL;/* Loose selection */ + +/* The surface handles are no longer valid. */ +TAILQ_FOREACH(miSub, &amp;amp;mi-&amp;gt;subItems, items) { +for (j = 0; j &amp;lt; 2; j++) { +miSub-&amp;gt;lblView[j] = -1; +} +miSub-&amp;gt;icon = -1; +} +AG_ObjectUnlock(m); +} +  /*   * Collapse the window displaying the specified item and its sub-menus   * (if any). &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -217,7 +240,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  {  AG_Menu *m;  AG_MenuItem *miSub; -Uint j; +AG_Window *miWin;    if (mi == NULL || mi-&amp;gt;view == NULL || (m = mi-&amp;gt;pmenu) == NULL)  return; &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -231,19 +254,9 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  }    /* Destroy the MenuView's window. */ -AG_ObjectDetach(WIDGET(mi-&amp;gt;view)-&amp;gt;window); -mi-&amp;gt;view = NULL; - -/* Lose the current selection. */ -mi-&amp;gt;sel_subitem = NULL; - -/* The surface handles are no longer valid. */ -TAILQ_FOREACH(miSub, &amp;amp;mi-&amp;gt;subItems, items) { -for (j = 0; j &amp;lt; 2; j++) { -miSub-&amp;gt;lblView[j] = -1; -} -miSub-&amp;gt;icon = -1; -} +miWin = WIDGET(mi-&amp;gt;view)-&amp;gt;window; +AG_ObjectDetach(miWin); +AG_SetEvent(miWin, \"window-detached\", MenuWindowDetached, \"%p,%p\", m, mi);    AG_ObjectUnlock(m);  } &lt;/pre&gt;</description>     <dc:creator>Agar-SVN</dc:creator>     <dc:date>2015-03-06T04:53:57</dc:date>   </item>   <item rdf:about=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1966\">     <title>Agar: r9783 - trunk/gui</title>     <link>http://permalink.gmane.org/gmane.comp.lib.agar.scm/1966</link>     <description>&lt;pre&gt;Author: vedge Date: 2015-03-05 23:42:42 -0500 (Thu, 05 Mar 2015) New Revision: 9783  Modified:    trunk/gui/AG_Window.3    trunk/gui/window.c Log: post `window-detached' event after a window has been successfully detached.   Modified: trunk/gui/AG_Window.3 =================================================================== --- trunk/gui/AG_Window.32015-03-06 04:41:25 UTC (rev 9782) +++ trunk/gui/AG_Window.32015-03-06 04:42:42 UTC (rev 9783) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -72,10 +72,14 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  .Fn AG_WindowNew )  must be made visible using  .Fn AG_WindowShow . -To close a window and free its allocated resources, one call to -.Xr AG_ObjectDetach 3 -is sufficient (Agar will defer the actual destruction of the window -until it becomes safe to do so). +.Pp +Windows are destroyed by a single call to +.Xr AG_ObjectDetach 3 . +The detach operation actually places the window on a queue, and actual +freeing will occur after the end of the current event processing cycle. +After a window has been successfully detached, the +.Sq window-detached +event is raised.  .Sh INHERITANCE HIERARCHY  .Xr AG_Object 3 -&amp;gt;  .Xr AG_Widget 3 -&amp;gt; &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -854,16 +858,20 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  objects the following events:  .Bl -tag -width 2n  .It Fn window-close \"void\" -The user (or window system) is requesting that this window be closed. -By default, named windows are hidden and unnamed windows are destroyed. -Event handlers are free to ignore the request, or create new windows -(e.g., confirmation dialogs) in response. +Request to close the window (sent by the user / underlying window system). +The default behavior is to hide named windows and detach unnamed windows.. +It is safe for an event handler to ignore the request, or to create new +windows (e.g., a confirmation dialog) in response.  .It Fn window-modal-close \"int x\" \"int y\"  The window is modal (the  .Dv AG_WINDOW_MODAL  option is set), and a click or touch event was detected outside of its area  (at given coordinates).  By default, the request is ignored. +.It Fn window-detached \"void\" +The window has been successfully detached (as per a previous +.Xr AG_ObjectDetach 3 +request).  .It Fn window-shown \"void\"  The window is now visible.  .It Fn window-hidden \"void\"  Modified: trunk/gui/window.c =================================================================== --- trunk/gui/window.c2015-03-06 04:41:25 UTC (rev 9782) +++ trunk/gui/window.c2015-03-06 04:42:42 UTC (rev 9783) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1965,7 +1965,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  if (win-&amp;gt;flags &amp;amp; AG_WINDOW_MAIN) {  closedMain++;  } - +AG_PostEvent(drv, win, \"window-detached\", NULL);  AG_ObjectDestroy(win);  }  TAILQ_INIT(&amp;amp;agWindowDetachQ); &lt;/pre&gt;</description>     <dc:creator>Agar-SVN</dc:creator>     <dc:date>2015-03-06T04:42:42</dc:date>   </item>   <item rdf:about=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1965\">     <title>Agar: r9782 - trunk/tests</title>     <link>http://permalink.gmane.org/gmane.comp.lib.agar.scm/1965</link>     <description>&lt;pre&gt;Author: vedge Date: 2015-03-05 23:41:25 -0500 (Thu, 05 Mar 2015) New Revision: 9782  Modified:    trunk/tests/agartest.c    trunk/tests/agartest.h    trunk/tests/charsets.c    trunk/tests/focusing.c    trunk/tests/threads.c Log: invoke destroy() operation post `window-detach'   Modified: trunk/tests/agartest.c =================================================================== --- trunk/tests/agartest.c2015-03-04 07:12:55 UTC (rev 9781) +++ trunk/tests/agartest.c2015-03-06 04:41:25 UTC (rev 9782) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -213,7 +213,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_ConsoleMsg(console, _(\"%s: Interactive test started\"),      tc-&amp;gt;name);  AG_SeparatorNewHoriz(win); -AG_ButtonNewFn(win, AG_BUTTON_HFILL, _(\"Close this test\"), +ti-&amp;gt;closeBtn = AG_ButtonNewFn(win, AG_BUTTON_HFILL, _(\"Close this test\"),      RequestTestClose, \"%p\", win);  AG_WindowSetPosition(win, AG_WINDOW_MC, 0);  AG_WindowAttach(winParent, win); &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -264,14 +264,11 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  return;  }   -/* Close an interactive test. */ -void -TestWindowClose(AG_Event *event) +static void +TestWindowDetached(AG_Event *event)  {  AG_TestInstance *ti = AG_PTR(1);   -AG_ConsoleMsg(console, _(\"Test %s: terminated\"), ti-&amp;gt;name); -AG_ObjectDetach(ti-&amp;gt;win);  TAILQ_REMOVE(&amp;amp;tests, ti, instances);  if (ti-&amp;gt;tc-&amp;gt;destroy != NULL) {  ti-&amp;gt;tc-&amp;gt;destroy(ti); &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -279,6 +276,17 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  free(ti);  }   +/* Close an interactive test. */ +void +TestWindowClose(AG_Event *event) +{ +AG_TestInstance *ti = AG_PTR(1); + +AG_ConsoleMsg(console, _(\"Test %s: terminated\"), ti-&amp;gt;name); +AG_ObjectDetach(ti-&amp;gt;win); +AG_SetEvent(ti-&amp;gt;win, \"window-detached\", TestWindowDetached, \"%p\", ti); +} +  /* Write a message to the test console (format string). */  void  TestMsg(void *obj, const char *fmt, ...)  Modified: trunk/tests/agartest.h =================================================================== --- trunk/tests/agartest.h2015-03-04 07:12:55 UTC (rev 9781) +++ trunk/tests/agartest.h2015-03-06 04:41:25 UTC (rev 9782) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -39,6 +39,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  float score;/* Numerical result */  AG_Console *console;/* Output console */  AG_Window *win;/* Main (control) window */ +AG_Button *closeBtn;/* \"Close this test\" */  AG_TAILQ_ENTRY(ag_test_instance) instances;  } AG_TestInstance;    Modified: trunk/tests/charsets.c =================================================================== --- trunk/tests/charsets.c2015-03-04 07:12:55 UTC (rev 9781) +++ trunk/tests/charsets.c2015-03-06 04:41:25 UTC (rev 9782) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -12,27 +12,49 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    typedef struct {  AG_TestInstance _inherit; -char myASCII[20*4]; -char myUTF[30*4]; -char myLat1[30*4]; -AG_Text *myTxt; +char myASCII[20*4];/* Example US-ASCII buffer */ +char myUTF[30*4];/* Example UTF-8 buffer */ +char myLat1[30*4];/* Example ISO-8859-1 buffer */ +AG_Text *myTxt;/* Sample AG_TextElement(3) */  } MyTestInstance;    static int +Init(void *obj) +{ +MyTestInstance *ti = obj; + +if ((ti-&amp;gt;myTxt = AG_TextNew(0)) == NULL) { +return (-1); +} +AG_TextSetEnt(ti-&amp;gt;myTxt, AG_LANG_FR, \"(UTF8) Fran\\\\xc3\\\\xa7\\\\x61is!\"); +AG_TextSetEnt(ti-&amp;gt;myTxt, AG_LANG_EN, \"(UTF8) English!\"); +AG_TextSetEnt(ti-&amp;gt;myTxt, AG_LANG_NO, \"(UTF8) Norsk!\"); +return (0); +} + +static void +Destroy(void *obj) +{ +MyTestInstance *ti = obj; + +AG_TextFree(ti-&amp;gt;myTxt); +} + +static int  TestGUI(void *obj, AG_Window *win)  {  MyTestInstance *ti = obj;  AG_Textbox *tb;    /* Bind to a C string in US-ASCII */ -AG_Strlcpy(ti-&amp;gt;myASCII, \"ASCII!\", sizeof(ti-&amp;gt;myASCII)); +AG_Strlcpy(ti-&amp;gt;myASCII, \"(US-ASCII)\", sizeof(ti-&amp;gt;myASCII));  tb = AG_TextboxNew(win, AG_TEXTBOX_HFILL|AG_TEXTBOX_EXCL,      \"ASCII Buffer: \\ (%lu bytes)\", (long unsigned)sizeof(ti-&amp;gt;myASCII));  AG_TextboxBindASCII(tb, ti-&amp;gt;myASCII, sizeof(ti-&amp;gt;myASCII));  AG_TextboxSizeHintLines(tb, 2);    /* Bind to a C string in UTF-8 */ -AG_Strlcpy(ti-&amp;gt;myUTF, \"\\\\xc3\\\\x85ngstrom!\", sizeof(ti-&amp;gt;myUTF)); +AG_Strlcpy(ti-&amp;gt;myUTF, \"(UTF8) \\\\xc3\\\\x85ngstrom!\", sizeof(ti-&amp;gt;myUTF));  tb = AG_TextboxNew(win, AG_TEXTBOX_HFILL|AG_TEXTBOX_EXCL,      \"UTF-8 Buffer: \\ (%lu bytes)\", (long unsigned)sizeof(ti-&amp;gt;myUTF));  AG_TextboxBindUTF8(tb, ti-&amp;gt;myUTF, sizeof(ti-&amp;gt;myUTF)); &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -40,7 +62,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    /* Bind to a C string in any iconv-supported encoding */  #ifdef HAVE_ICONV -AG_Strlcpy(ti-&amp;gt;myLat1, \"Overv\\\\xE5knign for feils\\\\xF8king!\", sizeof(ti-&amp;gt;myLat1)); +AG_Strlcpy(ti-&amp;gt;myLat1, \"(LATIN-1) overv\\\\xE5knign for feils\\\\xF8king!\", sizeof(ti-&amp;gt;myLat1));  tb = AG_TextboxNew(win, AG_TEXTBOX_HFILL|AG_TEXTBOX_EXCL,      \"LATIN-1 Buffer: \\ (%lu bytes)\", (long unsigned)sizeof(ti-&amp;gt;myLat1));  AG_TextboxBindEncoded(tb, \"ISO-8859-1\", ti-&amp;gt;myLat1, sizeof(ti-&amp;gt;myLat1)); &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -54,38 +76,27 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_SeparatorNewHoriz(win);    /* Bind to a multilingual AG_Text(3) element. */ -if ((ti-&amp;gt;myTxt = AG_TextNew(0)) != NULL) { -AG_TextSetEnt(ti-&amp;gt;myTxt, AG_LANG_FR, \"Fran\\\\xc3\\\\xa7\\\\x61is!\"); -AG_TextSetEnt(ti-&amp;gt;myTxt, AG_LANG_EN, \"English!\"); -AG_TextSetEnt(ti-&amp;gt;myTxt, AG_LANG_NO, \"Norsk!\"); -AG_LabelNewS(win, 0, \"Multilingual AG_Text(3) buffer:\"); -tb = AG_TextboxNewS(win, -    AG_TEXTBOX_MULTILINGUAL|AG_TEXTBOX_EXPAND|AG_TEXTBOX_MULTILINE, -    NULL); -AG_TextboxBindText(tb, ti-&amp;gt;myTxt); -AG_TextboxSetLang(tb, AG_LANG_FR); -AG_TextboxSizeHint(tb, \"XXXXXXXXXXXXXXXXXXXXXXXXX\"); -AG_TextboxSizeHintLines(tb, 5); -AG_TextboxSetCursorPos(tb, -1);/* End of string */ -} +AG_LabelNewS(win, 0, \"Multilingual AG_Text(3) buffer:\"); +tb = AG_TextboxNewS(win, +    AG_TEXTBOX_MULTILINGUAL|AG_TEXTBOX_EXPAND| +    AG_TEXTBOX_MULTILINE|AG_TEXTBOX_EXCL, +    NULL); +AG_TextboxBindText(tb, ti-&amp;gt;myTxt); +AG_TextboxSetLang(tb, AG_LANG_FR); +AG_TextboxSizeHint(tb, \"XXXXXXXXXXXXXXXXXXXXXXXXX\"); +AG_TextboxSizeHintLines(tb, 5); +AG_TextboxSetCursorPos(tb, -1);/* End of string */ +  return (0);  }   -static void -Destroy(void *obj) -{ -MyTestInstance *ti = obj; - -AG_TextFree(ti-&amp;gt;myTxt); -} -  const AG_TestCase charsetsTest = {  \"charsets\",  N_(\"Test AG_Editable(3) bound to buffers in different character sets\"),  \"1.5.0\",  0,  sizeof(MyTestInstance), -NULL,/* init */ +Init,  Destroy,  NULL,/* test */  TestGUI,  Modified: trunk/tests/focusing.c =================================================================== --- trunk/tests/focusing.c2015-03-04 07:12:55 UTC (rev 9781) +++ trunk/tests/focusing.c2015-03-06 04:41:25 UTC (rev 9782) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -5,11 +5,6 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    #include \"agartest.h\"   -typedef struct { -AG_TestInstance _inherit; -AG_Widget *widget1, *widget2; -} MyTestInstance; -  static void  mousemotion(AG_Event *event)  { &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -67,8 +62,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  static void  TestUnfocusedMotion(AG_Event *event)  { -MyTestInstance *ti = AG_PTR(1); -AG_Window *winParent = AG_PTR(2), *win; +AG_Window *winParent = AG_PTR(1), *win;  AG_Button *btn;  AG_Fixed *fx1, *fx2;   &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -91,8 +85,6 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_FixedMove(fx1, btn, 0, 64);  AG_FixedSize(fx1, btn, 32, 32);   -ti-&amp;gt;widget1 = AGWIDGET(btn); -  fx2 = AG_FixedNew(fx1, AG_FIXED_BOX);  AGWIDGET(fx2)-&amp;gt;flags |= AG_WIDGET_FOCUSABLE|AG_WIDGET_UNFOCUSED_MOTION;  AG_FixedMove(fx1, fx2, 64, 16); &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -109,10 +101,8 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  static void  TestTabCycle(AG_Event *event)  { -MyTestInstance *ti = AG_PTR(1); -AG_Window *winParent = AG_PTR(2), *win; +AG_Window *winParent = AG_PTR(1), *win;  AG_Box *b, *b1, *b2; -AG_Button *btn;  int i;    if ((win = AG_WindowNew(0)) == NULL) { &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -124,8 +114,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;                      \"&amp;lt;SHIFT+TAB&amp;gt; = Cycle focus backward\");  b = AG_BoxNewHoriz(win, AG_BOX_HOMOGENOUS|AG_BOX_EXPAND);   -btn = AG_ButtonNew(b, AG_BUTTON_HFILL, \"Foo\"); -ti-&amp;gt;widget2 = AGWIDGET(btn); +AG_ButtonNew(b, AG_BUTTON_HFILL, \"Foo\");    b1 = AG_BoxNewVert(b, AG_BOX_VFILL);  for (i = 0; i &amp;lt; 5; i++) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -139,54 +128,14 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_WindowShow(win);  }   -static void -FocusWidget1(AG_Event *event) -{ -MyTestInstance *ti = AG_PTR(1); - -if (ti-&amp;gt;widget1 != NULL) -AG_WidgetFocus(ti-&amp;gt;widget1); -} - -static void -FocusWidget2(AG_Event *event) -{ -MyTestInstance *ti = AG_PTR(1); - -if (ti-&amp;gt;widget2 != NULL) -AG_WidgetFocus(ti-&amp;gt;widget2); -} -  static int -Init(void *obj) -{ -MyTestInstance *ti = obj; - -ti-&amp;gt;widget1 = NULL; -ti-&amp;gt;widget2 = NULL; -return (0); -} - -static int  TestGUI(void *obj, AG_Window *win)  { -MyTestInstance *ti = obj; -AG_Button *btn; -AG_Box *box; -  AG_LabelNewS(win, 0, \"Tests for widget focus states\"); -btn = AG_ButtonNewFn(win, 0, \"Test unfocused mouse motion\", TestUnfocusedMotion, \"%p,%p\", ti, win); -AG_WidgetSetFocusable(btn, 0); -btn = AG_ButtonNewFn(win, 0, \"Test &amp;lt;tab&amp;gt; focus cycling\", TestTabCycle, \"%p,%p\", ti, win); -AG_WidgetSetFocusable(btn, 0); - -box = AG_BoxNewHoriz(win, AG_BOX_HFILL); -{ -btn = AG_ButtonNewFn(box, 0, \"Focus widget 1\", FocusWidget1, \"%p\", ti); -AG_WidgetSetFocusable(btn, 0); -btn = AG_ButtonNewFn(box, 0, \"Focus widget 2\", FocusWidget2, \"%p\", ti); -AG_WidgetSetFocusable(btn, 0); -} +AG_ButtonNewFn(win, 0, \"Test unfocused mouse motion\", +    TestUnfocusedMotion, \"%p\", win); +AG_ButtonNewFn(win, 0, \"Test &amp;lt;tab&amp;gt; focus cycling\", +    TestTabCycle, \"%p\", win);  return (0);  }   &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -195,8 +144,8 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  N_(\"Test widget focus state control\"),  \"1.4.2\",  0, -sizeof(MyTestInstance), -Init, +sizeof(AG_TestInstance), +NULL,/* init */  NULL,/* destroy */  NULL,/* test */  TestGUI,  Modified: trunk/tests/threads.c =================================================================== --- trunk/tests/threads.c2015-03-04 07:12:55 UTC (rev 9781) +++ trunk/tests/threads.c2015-03-06 04:41:25 UTC (rev 9782) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -48,9 +48,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_LabelNew(win, 0, \"This window was created in a separate thread\");    AG_WindowAttach(ti-&amp;gt;winParent, win); -Verbose(\"Showing window\\ \");  AG_WindowShow(win); -Verbose(\"Window shown\\ \");  return (NULL);  } &lt;/pre&gt;</description>     <dc:creator>Agar-SVN</dc:creator>     <dc:date>2015-03-06T04:41:26</dc:date>   </item>   <item rdf:about=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1964\">     <title>Agar: r9781 - trunk/core</title>     <link>http://permalink.gmane.org/gmane.comp.lib.agar.scm/1964</link>     <description>&lt;pre&gt;Author: vedge Date: 2015-03-04 02:12:55 -0500 (Wed, 04 Mar 2015) New Revision: 9781  Modified:    trunk/core/string.c Log: correctly free the associated thread-specific keys used by the AG_Printf() buffers.   Modified: trunk/core/string.c =================================================================== --- trunk/core/string.c2015-03-03 10:20:58 UTC (rev 9780) +++ trunk/core/string.c2015-03-04 07:12:55 UTC (rev 9781) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1358,10 +1358,16 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    /* Free the AG_Printf() buffers. */  for (i = 0; i &amp;lt; AG_STRING_BUFFERS_MAX; i++) { -Free(agPrintBuf[i]);  #ifdef AG_THREADS +if ((agPrintBuf[i] = (char *)AG_ThreadKeyGet(agPrintBufKey[i])) +    != NULL) { +free(agPrintBuf[i]); +}  AG_ThreadKeyDelete(agPrintBufKey[i]); +#else +Free(agPrintBuf[i]);  #endif +agPrintBuf[i] = NULL;  }    /* Free the formatting engine extensions. */ &lt;/pre&gt;</description>     <dc:creator>Agar-SVN</dc:creator>     <dc:date>2015-03-04T07:12:56</dc:date>   </item>   <item rdf:about=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1963\">     <title>Agar: r9780 - trunk/tests</title>     <link>http://permalink.gmane.org/gmane.comp.lib.agar.scm/1963</link>     <description>&lt;pre&gt;Author: vedge Date: 2015-03-03 05:20:58 -0500 (Tue, 03 Mar 2015) New Revision: 9780  Modified:    trunk/tests/threads.c Log: prevent unsafe operation in the threads test   Modified: trunk/tests/threads.c =================================================================== --- trunk/tests/threads.c2015-03-03 08:09:29 UTC (rev 9779) +++ trunk/tests/threads.c2015-03-03 10:20:58 UTC (rev 9780) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -32,6 +32,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  int value;  } spinning;  int closeTest; +AG_Mutex lock;  } MyTestInstance;    static void * &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -60,21 +61,33 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    TestMsg(ti, \"Sleeping worker created\");  for (;;) { +AG_MutexLock(&amp;amp;ti-&amp;gt;lock);  if (ti-&amp;gt;closeTest) { -break; +TestMsg(ti, \"Task aborted\"); +AG_MutexUnlock(&amp;amp;ti-&amp;gt;lock); +goto out;  }  TestMsg(ti, \"Sleeping worker: %d/%d\", ti-&amp;gt;sleeping.value, ti-&amp;gt;sleeping..max);  if (++ti-&amp;gt;sleeping.value == ti-&amp;gt;sleeping.max) { -TestMsg(ti, \"Sleeping worker thread exiting\"); -AG_ObjectDetach(ti-&amp;gt;sleeping.win); -ti-&amp;gt;sleeping.win = NULL; -AG_ThreadExit(NULL); +TestMsg(ti, \"Task completed\"); +AG_MutexUnlock(&amp;amp;ti-&amp;gt;lock); +goto out;  }  AG_LabelText(ti-&amp;gt;sleeping.lbl,      \"Sleeping worker progress: %d/%d\", ti-&amp;gt;sleeping.value, ti-&amp;gt;sleeping.max); -AG_Delay(1000); + +AG_MutexUnlock(&amp;amp;ti-&amp;gt;lock); +AG_Delay(100);  } -ti-&amp;gt;sleeping.running = 0; +out: +AG_MutexLock(&amp;amp;ti-&amp;gt;lock); +ti-&amp;gt;closeTest = 0; +if (ti-&amp;gt;sleeping.win != NULL) { +AG_ObjectDetach(ti-&amp;gt;sleeping.win); +ti-&amp;gt;sleeping.win = NULL; +ti-&amp;gt;sleeping.running = 0; +} +AG_MutexUnlock(&amp;amp;ti-&amp;gt;lock);  return (NULL);  }   &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -87,16 +100,18 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  TestMsg(ti, \"Spinning worker created\");  for (;;) {  int i; - + +AG_MutexLock(&amp;amp;ti-&amp;gt;lock);  if (ti-&amp;gt;closeTest) { -break; +TestMsg(ti, \"Task aborted. x=%f, y=%f\", x, y); +AG_MutexUnlock(&amp;amp;ti-&amp;gt;lock); +goto out;  }  TestMsg(ti, \"Spinning worker: %d/%d\", ti-&amp;gt;spinning.value, ti-&amp;gt;spinning..max);  if (++ti-&amp;gt;spinning.value == ti-&amp;gt;spinning.max) { -TestMsg(ti, \"Spinning worker thread exiting. x=%f, y=%f\", x, y); -AG_ObjectDetach(ti-&amp;gt;spinning.win); -ti-&amp;gt;spinning.win = NULL; -AG_ThreadExit(NULL); +TestMsg(ti, \"Task completed. x=%f, y=%f\", x, y); +AG_MutexUnlock(&amp;amp;ti-&amp;gt;lock); +goto out;  }  AG_LabelText(ti-&amp;gt;spinning.lbl,      \"Spinning worker progress: %d/%d\", ti-&amp;gt;spinning.value, ti-&amp;gt;spinning.max); &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -105,8 +120,17 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  x = sin(cos(y)) + tan((double)i);  if (x != 12.345) { x = 1.0; }  } +AG_MutexUnlock(&amp;amp;ti-&amp;gt;lock); +AG_Delay(1);  } -ti-&amp;gt;spinning.running = 0; +out: +AG_MutexLock(&amp;amp;ti-&amp;gt;lock); +if (ti-&amp;gt;spinning.win != NULL) { +AG_ObjectDetach(ti-&amp;gt;spinning.win); +ti-&amp;gt;spinning.win = NULL; +ti-&amp;gt;spinning.running = 0; +} +AG_MutexUnlock(&amp;amp;ti-&amp;gt;lock);  return (NULL);  }   &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -128,8 +152,11 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_Window *win;  AG_ProgressBar *pb;   +AG_MutexLock(&amp;amp;ti-&amp;gt;lock); +  if (ti-&amp;gt;sleeping.win != NULL ||      (win = AG_WindowNew(AG_WINDOW_NOCLOSE)) == NULL) { +AG_MutexUnlock(&amp;amp;ti-&amp;gt;lock);  return;  }  ti-&amp;gt;sleeping.win = win; &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -144,11 +171,13 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_BindInt(pb, \"min\", &amp;amp;ti-&amp;gt;sleeping.min);  AG_BindInt(pb, \"max\", &amp;amp;ti-&amp;gt;sleeping.max);  ti-&amp;gt;sleeping.lbl = AG_LabelNew(win, AG_LABEL_HFILL, \"...\"); -AG_WindowAttach(ti-&amp;gt;winParent, win); +/*AG_WindowAttach(ti-&amp;gt;winParent, win); */  AG_WindowShow(win);    AG_ThreadCreate(&amp;amp;ti-&amp;gt;sleeping.th, SleepingWorker, ti);  ti-&amp;gt;sleeping.running = 1; + +AG_MutexUnlock(&amp;amp;ti-&amp;gt;lock);  }    static void &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -157,9 +186,12 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  MyTestInstance *ti = AG_PTR(1);  AG_Window *win;  AG_ProgressBar *pb; + +AG_MutexLock(&amp;amp;ti-&amp;gt;lock);    if (ti-&amp;gt;spinning.win != NULL ||      (win = AG_WindowNew(AG_WINDOW_NOCLOSE)) == NULL) { +AG_MutexUnlock(&amp;amp;ti-&amp;gt;lock);  return;  }  ti-&amp;gt;spinning.win = win; &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -174,11 +206,13 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_BindInt(pb, \"min\", &amp;amp;ti-&amp;gt;spinning.min);  AG_BindInt(pb, \"max\", &amp;amp;ti-&amp;gt;spinning.max);  ti-&amp;gt;spinning.lbl = AG_LabelNew(win, AG_LABEL_HFILL, \"...\"); -AG_WindowAttach(ti-&amp;gt;winParent, win); +/*AG_WindowAttach(ti-&amp;gt;winParent, win); */  AG_WindowShow(win);    AG_ThreadCreate(&amp;amp;ti-&amp;gt;spinning.th, SpinningWorker, ti);  ti-&amp;gt;spinning.running = 1; + +AG_MutexUnlock(&amp;amp;ti-&amp;gt;lock);  }    static int &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -194,6 +228,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  ti-&amp;gt;spinning.win = NULL;  ti-&amp;gt;spinning.running = 0;  ti-&amp;gt;closeTest = 0; +AG_MutexInit(&amp;amp;ti-&amp;gt;lock);  return (0);  }   &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -202,6 +237,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  {  MyTestInstance *ti = obj;   +AG_MutexDestroy(&amp;amp;ti-&amp;gt;lock);  AG_ObjectDestroy(&amp;amp;ti-&amp;gt;workerMgr);  }   &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -210,14 +246,19 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  {  MyTestInstance *ti = AG_PTR(1);   -ti-&amp;gt;closeTest = 1; - -while (ti-&amp;gt;sleeping.running) { -AG_Delay(50); +AG_MutexLock(&amp;amp;ti-&amp;gt;lock); +if (ti-&amp;gt;sleeping.running) { +TestMsg(ti, \"Sleeping worker is not finished\"); +AG_MutexUnlock(&amp;amp;ti-&amp;gt;lock); +return;  } -while (ti-&amp;gt;spinning.running) { -AG_Delay(50); +if (ti-&amp;gt;spinning.running) { +TestMsg(ti, \"Spinning worker is not finished\"); +AG_MutexUnlock(&amp;amp;ti-&amp;gt;lock); +return;  } +AG_MutexUnlock(&amp;amp;ti-&amp;gt;lock); +  TestWindowClose(event);  } &lt;/pre&gt;</description>     <dc:creator>Agar-SVN</dc:creator>     <dc:date>2015-03-03T10:20:59</dc:date>   </item>   <item rdf:about=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1962\">     <title>Agar: r9779 - trunk/core</title>     <link>http://permalink.gmane.org/gmane.comp.lib.agar.scm/1962</link>     <description>&lt;pre&gt;Author: vedge Date: 2015-03-03 03:09:29 -0500 (Tue, 03 Mar 2015) New Revision: 9779  Modified:    trunk/core/event.c Log: prevent cleanup routine of agEventSourceKey from calling DestroyEventSource() twice   Modified: trunk/core/event.c =================================================================== --- trunk/core/event.c2015-03-02 04:50:47 UTC (rev 9778) +++ trunk/core/event.c2015-03-03 08:09:29 UTC (rev 9779) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -641,13 +641,19 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  {  AG_EventSource *src = pEventSource;  AG_EventSink *es, *esNext; + +if (agEventSource == NULL) +return; +  #ifdef HAVE_KQUEUE -AG_EventSourceKQUEUE *kq = pEventSource; +{ +AG_EventSourceKQUEUE *kq = pEventSource;   -if (kq-&amp;gt;fd != -1) { -close(kq-&amp;gt;fd); +if (kq-&amp;gt;fd != -1) { +close(kq-&amp;gt;fd); +} +Free(kq-&amp;gt;changes);  } -Free(kq-&amp;gt;changes);  #endif  for (es = TAILQ_FIRST(&amp;amp;src-&amp;gt;prologues); es != TAILQ_END(&amp;amp;src-&amp;gt;prologues); es = esNext) {  esNext = TAILQ_NEXT(es, sinks); &lt;/pre&gt;</description>     <dc:creator>Agar-SVN</dc:creator>     <dc:date>2015-03-03T08:09:38</dc:date>   </item>   <item rdf:about=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1961\">     <title>Agar: r9775 - trunk/gui</title>     <link>http://permalink.gmane.org/gmane.comp.lib.agar.scm/1961</link>     <description>&lt;pre&gt;Author: vedge Date: 2015-02-20 00:01:47 -0500 (Fri, 20 Feb 2015) New Revision: 9775  Modified:    trunk/gui/window.c Log: unused warnings   Modified: trunk/gui/window.c =================================================================== --- trunk/gui/window.c2015-02-19 15:36:39 UTC (rev 9774) +++ trunk/gui/window.c2015-02-20 05:01:47 UTC (rev 9775) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -284,14 +284,10 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  Detach(AG_Event *event)  {  AG_Window *win = AG_SELF(); -AG_Driver *drv = OBJECT(win)-&amp;gt;parent, *odrv; +AG_Driver *drv;  AG_Window *other, *subwin;  AG_Timer *to, *toNext;   -#ifdef AG_DEBUG -if (drv == NULL || !AG_OfClass(drv, \"AG_Driver:*\")) -AG_FatalError(\"Window is not attached to a Driver\"); -#endif  AG_LockVFS(&amp;amp;agDrivers);    /* Mark window detach in progress */ &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -308,8 +304,8 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_UnlockTiming();    /* Implicitely detach window dependencies. */ -AGOBJECT_FOREACH_CHILD(odrv, &amp;amp;agDrivers, ag_driver) { -AG_FOREACH_WINDOW(other, odrv) { +AGOBJECT_FOREACH_CHILD(drv, &amp;amp;agDrivers, ag_driver) { +AG_FOREACH_WINDOW(other, drv) {  if (other == win) {  continue;  } &lt;/pre&gt;</description>     <dc:creator>Agar-SVN</dc:creator>     <dc:date>2015-02-20T05:01:47</dc:date>   </item>   <item rdf:about=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1960\">     <title>Agar: r9774 - trunk/gui</title>     <link>http://permalink.gmane.org/gmane.comp.lib.agar.scm/1960</link>     <description>&lt;pre&gt;Author: vedge Date: 2015-02-19 10:36:39 -0500 (Thu, 19 Feb 2015) New Revision: 9774  Modified:    trunk/gui/drv_glx.c    trunk/gui/drv_sdl_common.c Log: don't try to free shared cursors    Modified: trunk/gui/drv_glx.c =================================================================== --- trunk/gui/drv_glx.c2015-02-19 15:14:11 UTC (rev 9773) +++ trunk/gui/drv_glx.c2015-02-19 15:36:39 UTC (rev 9774) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -99,6 +99,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  XColor white;  Cursor xc;  int visible; +int shared;  } AG_CursorGLX;    AG_DriverMwClass agDriverGLX; &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -918,9 +919,11 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  /*   * Initialize generic Agar cursor part.   */ -if ((ac = acGLX = TryMalloc(sizeof(AG_CursorGLX))) == NULL) { +if ((acGLX = TryMalloc(sizeof(AG_CursorGLX))) == NULL) {  return (NULL);  } +ac = (AG_Cursor *)acGLX; +  if ((ac-&amp;gt;data = TryMalloc(size)) == NULL) {  free(ac);  return (NULL); &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1000,6 +1003,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  acGLX-&amp;gt;xc = XCreatePixmapCursor(agDisplay, dataPixmap, maskPixmap,      &amp;amp;acGLX-&amp;gt;black, &amp;amp;acGLX-&amp;gt;white, ac-&amp;gt;xHot, ac-&amp;gt;yHot);  acGLX-&amp;gt;visible = 0; +acGLX-&amp;gt;shared = 0;    XFreePixmap(agDisplay, dataPixmap);  XFreePixmap(agDisplay, maskPixmap); &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1017,6 +1021,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  static void  GLX_FreeCursor(void *obj, AG_Cursor *ac)  { +AG_Driver *drv = obj;  AG_DriverGLX *glx = obj;  AG_CursorGLX *acGLX = (AG_CursorGLX *)ac;   &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1025,8 +1030,8 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    if (ac == drv-&amp;gt;activeCursor)  drv-&amp;gt;activeCursor = NULL; - -XFreeCursor(agDisplay, acGLX-&amp;gt;xc); +if (!acGLX-&amp;gt;shared) +XFreeCursor(agDisplay, acGLX-&amp;gt;xc);    AG_MutexUnlock(&amp;amp;glx-&amp;gt;lock);  AG_MutexUnlock(&amp;amp;agDisplayLock); &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1041,7 +1046,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  {  AG_Driver *drv = obj;  AG_DriverGLX *glx = obj; -AG_CursorGLX *cg = ac-&amp;gt;p; +AG_CursorGLX *acGLX = (AG_CursorGLX *)ac;    if (drv-&amp;gt;activeCursor == ac)  return (0); &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1052,7 +1057,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  if (ac == TAILQ_FIRST(&amp;amp;drv-&amp;gt;cursors)) {  XUndefineCursor(agDisplay, glx-&amp;gt;w);  } else { -XDefineCursor(agDisplay, glx-&amp;gt;w, cg-&amp;gt;xc); +XDefineCursor(agDisplay, glx-&amp;gt;w, acGLX-&amp;gt;xc);  }    AG_MutexUnlock(&amp;amp;glx-&amp;gt;lock); &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1061,7 +1066,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  XSync(agDisplay, False);    drv-&amp;gt;activeCursor = ac; -cg-&amp;gt;visible = 1; +acGLX-&amp;gt;visible = 1;  return (0);  }   &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1123,20 +1128,17 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  {  AG_Driver *drv = AGDRIVER(glx);  AG_Cursor *ac; -AG_CursorGLX *cursGLX; +AG_CursorGLX *acGLX;   -if ((cursGLX = TryMalloc(sizeof(AG_CursorGLX))) == NULL) { +if ((acGLX = TryMalloc(sizeof(AG_CursorGLX))) == NULL) {  return (-1);  } -if ((ac = TryMalloc(sizeof(AG_Cursor))) == NULL) { -free(cursGLX); -return (-1); -} +ac = (AG_Cursor *)acGLX;  AG_CursorInit(ac);   -cursGLX-&amp;gt;xc = XCreateFontCursor(agDisplay, XC_left_ptr); -cursGLX-&amp;gt;visible = 1; -ac-&amp;gt;p = cursGLX; +acGLX-&amp;gt;xc = XCreateFontCursor(agDisplay, XC_left_ptr); +acGLX-&amp;gt;visible = 1; +acGLX-&amp;gt;shared = 1;    TAILQ_INSERT_HEAD(&amp;amp;drv-&amp;gt;cursors, ac, cursors);  drv-&amp;gt;nCursors++;  Modified: trunk/gui/drv_sdl_common.c =================================================================== --- trunk/gui/drv_sdl_common.c2015-02-19 15:14:11 UTC (rev 9773) +++ trunk/gui/drv_sdl_common.c2015-02-19 15:36:39 UTC (rev 9774) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -496,11 +496,13 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  return (NULL);  }  if ((ac-&amp;gt;data = TryMalloc(size)) == NULL) { -goto fail; +free(ac); +return (NULL);  }  if ((ac-&amp;gt;mask = TryMalloc(size)) == NULL) {  free(ac-&amp;gt;data); -goto fail; +free(ac); +return (NULL);  }  memcpy(ac-&amp;gt;data, data, size);  memcpy(ac-&amp;gt;mask, mask, size); &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -514,7 +516,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;      ac-&amp;gt;xHot, ac-&amp;gt;yHot);  if (sc == NULL) {  AG_SetError(\"SDL_CreateCursor failed\"); -return (-1); +goto fail;  }  ac-&amp;gt;p = (void *)sc;  return (ac); &lt;/pre&gt;</description>     <dc:creator>Agar-SVN</dc:creator>     <dc:date>2015-02-19T15:36:39</dc:date>   </item>   <item rdf:about=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1959\">     <title>Agar: r9772 - trunk/gui</title>     <link>http://permalink.gmane.org/gmane.comp.lib.agar.scm/1959</link>     <description>&lt;pre&gt;Author: vedge Date: 2015-02-19 10:13:40 -0500 (Thu, 19 Feb 2015) New Revision: 9772  Modified:    trunk/gui/AG_Driver.3    trunk/gui/cursors.c    trunk/gui/drv.h    trunk/gui/drv_glx.c    trunk/gui/drv_sdl_common.c    trunk/gui/drv_sdl_common.h    trunk/gui/drv_wgl.c Log: - extend the AG_Cursor structure to include driver-specific data, instead   of referencing an external structure. - have the drivers handle entire createCursor() operation.    Modified: trunk/gui/AG_Driver.3 =================================================================== --- trunk/gui/AG_Driver.32015-02-19 15:08:42 UTC (rev 9771) +++ trunk/gui/AG_Driver.32015-02-19 15:13:40 UTC (rev 9772) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -195,7 +195,9 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  void (*popBlendingMode)(void *drv);    /* Hardware cursor interface */ -int  (*createCursor)(void *drv, AG_Cursor *curs); +AG_Cursor *(*createCursor)(void *drv, Uint w, Uint h, +                           const Uint8 *data, const Uint8 *mask, +   int xHot, int yHot);  void (*freeCursor)(void *drv, AG_Cursor *curs);  int  (*setCursor)(void *drv, AG_Cursor *curs);  void (*unsetCursor)(void *drv); &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -432,9 +434,14 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  .Pp  The  .Fn createCursor -operation registers a hardware cursor for the specified -.Ft AG_Cursor -structure, returning 0 on success or -1 on failure. +operation creates a hardware cursor from the bitmap data +.Fa data +and transparency mask +.Fa mask . +The hotspot coordinates are given in +.Fa xHot , +.Fa yHot . +If a hardware cursor cannot be allocated, the call should return NULL.  .Fn freeCursor  destroys any hardware cursor corresponding to the given  .Ft AG_Cursor  Modified: trunk/gui/cursors.c =================================================================== --- trunk/gui/cursors.c2015-02-19 15:08:42 UTC (rev 9771) +++ trunk/gui/cursors.c2015-02-19 15:13:40 UTC (rev 9772) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -58,57 +58,27 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;      int xHot, int yHot)  {  AG_Driver *drv = obj; -AG_Cursor *curs; -Uint size = w*h; +AG_Cursor *ac;   -if ((curs = TryMalloc(sizeof(AG_Cursor))) == NULL) { +ac = AGDRIVER_CLASS(drv)-&amp;gt;createCursor(drv, w, h, data, mask, +    xHot, yHot); +if (ac == NULL) {  return (NULL);  } -if ((curs-&amp;gt;data = TryMalloc(size)) == NULL) { -free(curs); -return (NULL); -} -if ((curs-&amp;gt;mask = TryMalloc(size)) == NULL) { -goto fail; -} -memcpy(curs-&amp;gt;data, data, size); -memcpy(curs-&amp;gt;mask, mask, size); -curs-&amp;gt;w = w; -curs-&amp;gt;h = h; -curs-&amp;gt;xHot = xHot; -curs-&amp;gt;yHot = yHot; - -if (AGDRIVER_CLASS(drv)-&amp;gt;createCursor(drv, curs) == -1) { -goto fail; -} -TAILQ_INSERT_TAIL(&amp;amp;drv-&amp;gt;cursors, curs, cursors); +TAILQ_INSERT_TAIL(&amp;amp;drv-&amp;gt;cursors, ac, cursors);  drv-&amp;gt;nCursors++; -return (curs); -fail: -free(curs-&amp;gt;data); -free(curs-&amp;gt;mask); -free(curs); -return (NULL); +return (ac);  }   -static __inline__ void -FreeCursor(AG_Driver *drv, AG_Cursor *curs) -{ -AGDRIVER_CLASS(drv)-&amp;gt;freeCursor(drv, curs); -free(curs-&amp;gt;data); -free(curs-&amp;gt;mask); -free(curs); -} -  /* Delete a registered cursor. */  void -AG_CursorFree(void *obj, AG_Cursor *curs) +AG_CursorFree(void *obj, AG_Cursor *ac)  {  AG_Driver *drv = obj;   -TAILQ_REMOVE(&amp;amp;drv-&amp;gt;cursors, curs, cursors); +TAILQ_REMOVE(&amp;amp;drv-&amp;gt;cursors, ac, cursors);  drv-&amp;gt;nCursors--; -FreeCursor(drv, curs); +AGDRIVER_CLASS(drv)-&amp;gt;freeCursor(drv, ac);  }    /* Create a cursor from the contents of an XPM file. */ &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -177,7 +147,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;       ac != TAILQ_END(&amp;amp;drv-&amp;gt;cursors);       ac = acNext) {  acNext = TAILQ_NEXT(ac, cursors); -FreeCursor(drv, ac); +AGDRIVER_CLASS(drv)-&amp;gt;freeCursor(drv, ac);  }  TAILQ_INIT(&amp;amp;drv-&amp;gt;cursors);  drv-&amp;gt;nCursors = 0;  Modified: trunk/gui/drv.h =================================================================== --- trunk/gui/drv.h2015-02-19 15:08:42 UTC (rev 9771) +++ trunk/gui/drv.h2015-02-19 15:13:40 UTC (rev 9772) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -72,7 +72,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  void (*pushBlendingMode)(void *drv, AG_BlendFn srcFn, AG_BlendFn dstFn);  void (*popBlendingMode)(void *drv);  /* Hardware cursor operations */ -int  (*createCursor)(void *drv, struct ag_cursor *curs); +struct ag_cursor *(*createCursor)(void *drv, Uint w, Uint h, const Uint8 *data, const Uint8 *mask, int xHot, int yHot);  void (*freeCursor)(void *drv, struct ag_cursor *curs);  int  (*setCursor)(void *drv, struct ag_cursor *curs);  void (*unsetCursor)(void *drv);  Modified: trunk/gui/drv_glx.c =================================================================== --- trunk/gui/drv_glx.c2015-02-19 15:08:42 UTC (rev 9771) +++ trunk/gui/drv_glx.c2015-02-19 15:13:40 UTC (rev 9772) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -94,6 +94,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  #include &amp;lt;agar/gui/drv_glx_keymaps.h&amp;gt;    typedef struct ag_cursor_glx { +struct ag_cursor _inherit;  XColor black;  XColor white;  Cursor xc; &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -899,38 +900,61 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;   * Cursor operations   */   -static int -GLX_CreateCursor(void *obj, AG_Cursor *ac) +static AG_Cursor * +GLX_CreateCursor(void *obj, Uint w, Uint h, const Uint8 *data, const Uint8 *mask, +    int xHot, int yHot)  {  AG_DriverGLX *glx = obj; -AG_CursorGLX *cg; -int i, size; +AG_Cursor *ac; +AG_CursorGLX *acGLX; +Uint size = w*h, dataSize; +int i;  char *xData, *xMask;  XGCValues gcVals;  GC gc;  XImage *dataImg, *maskImg;  Pixmap dataPixmap, maskPixmap;   -if ((cg = TryMalloc(sizeof(AG_CursorGLX))) == NULL) { -return (-1); +/* + * Initialize generic Agar cursor part. + */ +if ((ac = acGLX = TryMalloc(sizeof(AG_CursorGLX))) == NULL) { +return (NULL);  } -memset(&amp;amp;cg-&amp;gt;black, 0, sizeof(cg-&amp;gt;black)); -cg-&amp;gt;white.pixel = 0xffff; -cg-&amp;gt;white.red = 0xffff; -cg-&amp;gt;white.green = 0xffff; -cg-&amp;gt;white.blue = 0xffff; +if ((ac-&amp;gt;data = TryMalloc(size)) == NULL) { +free(ac); +return (NULL); +} +if ((ac-&amp;gt;mask = TryMalloc(size)) == NULL) { +free(ac-&amp;gt;data); +free(ac); +return (NULL); +} +memcpy(ac-&amp;gt;data, data, size); +memcpy(ac-&amp;gt;mask, mask, size); +ac-&amp;gt;w = w; +ac-&amp;gt;h = h; +ac-&amp;gt;xHot = xHot; +ac-&amp;gt;yHot = yHot;   -size = (ac-&amp;gt;w/8)*ac-&amp;gt;h; -if ((xData = TryMalloc(size)) == NULL) { -free(cg); -return (-1); +/* + * Initialize X11-specific part. + */ +memset(&amp;amp;acGLX-&amp;gt;black, 0, sizeof(acGLX-&amp;gt;black)); +acGLX-&amp;gt;white.pixel = 0xffff; +acGLX-&amp;gt;white.red = 0xffff; +acGLX-&amp;gt;white.green = 0xffff; +acGLX-&amp;gt;white.blue = 0xffff; + +dataSize = (ac-&amp;gt;w / 8) * ac-&amp;gt;h; +if ((xData = TryMalloc(dataSize)) == NULL) { +goto fail;  } -if ((xMask = TryMalloc(size)) == NULL) { +if ((xMask = TryMalloc(dataSize)) == NULL) {  free(xData); -free(cg); -return (-1); +goto fail;  } -for (i = 0; i &amp;lt; size; i++) { +for (i = 0; i &amp;lt; dataSize; i++) {  xMask[i] = ac-&amp;gt;data[i] | ac-&amp;gt;mask[i];  xData[i] = ac-&amp;gt;data[i];  } &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -973,40 +997,43 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  XDestroyImage(maskImg);    /* Create the X cursor */ -cg-&amp;gt;xc = XCreatePixmapCursor(agDisplay, dataPixmap, maskPixmap, -    &amp;amp;cg-&amp;gt;black, &amp;amp;cg-&amp;gt;white, ac-&amp;gt;xHot, ac-&amp;gt;yHot); -cg-&amp;gt;visible = 0; +acGLX-&amp;gt;xc = XCreatePixmapCursor(agDisplay, dataPixmap, maskPixmap, +    &amp;amp;acGLX-&amp;gt;black, &amp;amp;acGLX-&amp;gt;white, ac-&amp;gt;xHot, ac-&amp;gt;yHot); +acGLX-&amp;gt;visible = 0;    XFreePixmap(agDisplay, dataPixmap);  XFreePixmap(agDisplay, maskPixmap);    AG_MutexUnlock(&amp;amp;glx-&amp;gt;lock);  AG_MutexUnlock(&amp;amp;agDisplayLock); - -XSync(agDisplay, False); - -ac-&amp;gt;p = cg; -return (0); +return (ac); +fail: +free(ac-&amp;gt;data); +free(ac-&amp;gt;mask); +free(ac); +return (NULL);  }    static void  GLX_FreeCursor(void *obj, AG_Cursor *ac)  {  AG_DriverGLX *glx = obj; -AG_CursorGLX *cg = ac-&amp;gt;p; +AG_CursorGLX *acGLX = (AG_CursorGLX *)ac;    AG_MutexLock(&amp;amp;agDisplayLock);  AG_MutexLock(&amp;amp;glx-&amp;gt;lock);   -XFreeCursor(agDisplay, cg-&amp;gt;xc); +if (ac == drv-&amp;gt;activeCursor) +drv-&amp;gt;activeCursor = NULL; + +XFreeCursor(agDisplay, acGLX-&amp;gt;xc);    AG_MutexUnlock(&amp;amp;glx-&amp;gt;lock);  AG_MutexUnlock(&amp;amp;agDisplayLock);   -XSync(agDisplay, False); - -free(cg); -ac-&amp;gt;p = NULL; +free(ac-&amp;gt;data); +free(ac-&amp;gt;mask); +free(ac);  }    static int &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1016,9 +1043,8 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_DriverGLX *glx = obj;  AG_CursorGLX *cg = ac-&amp;gt;p;   -if (drv-&amp;gt;activeCursor == ac) { +if (drv-&amp;gt;activeCursor == ac)  return (0); -}    AG_MutexLock(&amp;amp;agDisplayLock);  AG_MutexLock(&amp;amp;glx-&amp;gt;lock);  Modified: trunk/gui/drv_sdl_common.c =================================================================== --- trunk/gui/drv_sdl_common.c2015-02-19 15:08:42 UTC (rev 9771) +++ trunk/gui/drv_sdl_common.c2015-02-19 15:13:40 UTC (rev 9772) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -484,10 +484,30 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  }    /* Create a cursor. */ -int -AG_SDL_CreateCursor(void *obj, AG_Cursor *ac) +AG_Cursor * +AG_SDL_CreateCursor(void *obj, Uint w, Uint h, const Uint8 *data, +    const Uint8 *mask, int xHot, int yHot)  { +AG_Cursor *ac;  SDL_Cursor *sc; +Uint size = w*h; + +if ((ac = TryMalloc(sizeof(AG_Cursor))) == NULL) { +return (NULL); +} +if ((ac-&amp;gt;data = TryMalloc(size)) == NULL) { +goto fail; +} +if ((ac-&amp;gt;mask = TryMalloc(size)) == NULL) { +free(ac-&amp;gt;data); +goto fail; +} +memcpy(ac-&amp;gt;data, data, size); +memcpy(ac-&amp;gt;mask, mask, size); +ac-&amp;gt;w = w; +ac-&amp;gt;h = h; +ac-&amp;gt;xHot = xHot; +ac-&amp;gt;yHot = yHot;    sc = SDL_CreateCursor(ac-&amp;gt;data, ac-&amp;gt;mask,      ac-&amp;gt;w, ac-&amp;gt;h, &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -497,7 +517,12 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  return (-1);  }  ac-&amp;gt;p = (void *)sc; -return (0); +return (ac); +fail: +free(ac-&amp;gt;data); +free(ac-&amp;gt;mask); +free(ac); +return (NULL);  }    /* Release a cursor. */ &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -506,11 +531,13 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  {  AG_Driver *drv = obj;   -if (ac == TAILQ_FIRST(&amp;amp;drv-&amp;gt;cursors)) -return; +if (ac == drv-&amp;gt;activeCursor) +drv-&amp;gt;activeCursor = NULL;    SDL_FreeCursor((SDL_Cursor *)(ac-&amp;gt;p)); -ac-&amp;gt;p = NULL; +free(ac-&amp;gt;data); +free(ac-&amp;gt;mask); +free(ac);  }    /* Retrieve cursor visibility status. */  Modified: trunk/gui/drv_sdl_common.h =================================================================== --- trunk/gui/drv_sdl_common.h2015-02-19 15:08:42 UTC (rev 9771) +++ trunk/gui/drv_sdl_common.h2015-02-19 15:13:40 UTC (rev 9772) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -44,7 +44,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  int             AG_SDL_InitDefaultCursor(void *);  int             AG_SDL_SetCursor(void *, AG_Cursor *);  void            AG_SDL_UnsetCursor(void *); -int             AG_SDL_CreateCursor(void *, AG_Cursor *); +AG_Cursor      *AG_SDL_CreateCursor(void *, Uint, Uint, const Uint8 *, const Uint8 *, int, int);  void            AG_SDL_FreeCursor(void *, AG_Cursor *);  int             AG_SDL_GetCursorVisibility(void *);  void            AG_SDL_SetCursorVisibility(void *, int);  Modified: trunk/gui/drv_wgl.c =================================================================== --- trunk/gui/drv_wgl.c2015-02-19 15:08:42 UTC (rev 9771) +++ trunk/gui/drv_wgl.c2015-02-19 15:13:40 UTC (rev 9772) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -65,6 +65,8 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  } AG_DriverWGL;    typedef struct ag_cursor_wgl { +struct ag_cursor _inherit; +int      shared;/* Shared cursor */  COLORREF black;  COLORREF white;  HCURSOR  cursor; &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1125,91 +1127,114 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    for (i = 0; i &amp;lt; nStockCursors; i++) {  AG_Cursor *ac; -struct ag_cursor_wgl *cg; +AG_CursorWGL *acWGL;   -if ((ac = TryMalloc(sizeof(AG_Cursor))) == NULL) { +if ((acWGL = TryMalloc(sizeof(AG_CursorWGL))) == NULL) {  return (-1);  } -if ((cg = TryMalloc(sizeof(struct ag_cursor_wgl))) == NULL) { -free(ac); -return (-1); -} -ac-&amp;gt;p = cg; -cg-&amp;gt;cursor = LoadCursor(NULL, IDC_ARROW); +ac = (AG_Cursor *)acWGL; +acWGL-&amp;gt;shared = 1; +acWGL-&amp;gt;cursor = LoadCursor(NULL, IDC_ARROW);  AG_CursorInit(ac); -  TAILQ_INSERT_HEAD(&amp;amp;drv-&amp;gt;cursors, ac, cursors);  drv-&amp;gt;nCursors++;  }  return (0);  }   -static int -WGL_CreateCursor(void *obj, AG_Cursor *ac) +static AG_Cursor * +WGL_CreateCursor(void *obj, Uint w, Uint h, const Uint8 *data, const Uint8 *mask, +    int xHot, int yHot)  { -AG_CursorWGL *cg; -int          size, i; -BYTE         *xorMask, *andMask; +AG_Cursor *ac; +AG_CursorWGL *acWGL; +int dataSize, i; +BYTE *xorMask, *andMask; +Uint size = w*h;   -if ((cg = TryMalloc(sizeof(AG_CursorWGL))) == NULL) { -return (-1); +/* + * Initialize generic Agar cursor part. + */ +if ((acWGL = TryMalloc(sizeof(AG_CursorWGL))) == NULL) { +return (NULL);  } -cg-&amp;gt;black = RGB(0, 0, 0); -cg-&amp;gt;white = RGB(0xFF, 0xFF, 0xFF); - -/* Calc size for cursor data */ -size = (ac-&amp;gt;w / 8) * ac-&amp;gt;h; +ac = (AG_Cursor *)acWGL;   -/* Allocate memory for xorMask (which represents the cursor data) */ -if ((xorMask = TryMalloc(size)) == NULL) { -free(cg); -return (-1); +if ((ac-&amp;gt;data = TryMalloc(size)) == NULL) { +goto fail;  } +if ((ac-&amp;gt;mask = TryMalloc(size)) == NULL) { +free(ac-&amp;gt;data); +goto fail; +} +memcpy(ac-&amp;gt;data, data, size); +memcpy(ac-&amp;gt;mask, mask, size); +ac-&amp;gt;w = w; +ac-&amp;gt;h = h; +ac-&amp;gt;xHot = xHot; +ac-&amp;gt;yHot = yHot;   -/* Allocate memory for andMask (which represents the transparence) */ -if ((andMask = TryMalloc(size)) == NULL) { +/* + * Initialize Windows-specific part. + */ +acWGL-&amp;gt;shared = 0; +acWGL-&amp;gt;black = RGB(0, 0, 0); +acWGL-&amp;gt;white = RGB(0xFF, 0xFF, 0xFF); + +dataSize = (ac-&amp;gt;w / 8) * ac-&amp;gt;h; +if ((xorMask = TryMalloc(dataSize)) == NULL) { +free(ac-&amp;gt;data); +goto fail; +} +if ((andMask = TryMalloc(dataSize)) == NULL) {  free(xorMask); -free(cg); -return (-1); +free(ac-&amp;gt;data); +goto fail;  } - -/* Copy cursor data into buffers for use with CreateCursor */ -for (i = 0; i &amp;lt; size; i++) { +for (i = 0; i &amp;lt; dataSize; i++) {  andMask[i] = ~ac-&amp;gt;mask[i];  xorMask[i] = ~ac-&amp;gt;data[i] ^ ~ac-&amp;gt;mask[i];  }   -/* Create cursor */ -if ((cg-&amp;gt;cursor = CreateCursor(GetModuleHandle(NULL),  -    ac-&amp;gt;xHot, ac-&amp;gt;yHot, ac-&amp;gt;w, ac-&amp;gt;h, andMask, xorMask))) { -ac-&amp;gt;p = cg; -return (0); +acWGL-&amp;gt;cursor = CreateCursor(GetModuleHandle(NULL), ac-&amp;gt;xHot, ac-&amp;gt;yHot, +    ac-&amp;gt;w, ac-&amp;gt;h, andMask, xorMask); +if (!acWGL-&amp;gt;cursor) { +WGL_SetWindowsError(\"CreateCursor\", GetLastError()); +goto fail;  } - -WGL_SetWindowsError(\"CreateCursor failed!\", GetLastError()); -return (-1); +return (ac); +fail: +free(ac); +return (NULL);  }    static void  WGL_FreeCursor(void *obj, AG_Cursor *ac)  { -AG_CursorWGL *cg = ac-&amp;gt;p; - -DestroyCursor(cg-&amp;gt;cursor); -free(cg); -ac-&amp;gt;p = NULL; +AG_Driver *drv = obj; +AG_CursorWGL *acWGL = (AG_CursorWGL *)ac; + +if (ac == drv-&amp;gt;activeCursor) { +drv-&amp;gt;activeCursor = NULL; +} +if (!acWGL-&amp;gt;shared) { +DestroyCursor(acWGL-&amp;gt;cursor); +} +free(ac-&amp;gt;data); +free(ac-&amp;gt;mask); +free(ac);  }    static int  WGL_SetCursor(void *obj, AG_Cursor *ac)  {  AG_Driver *drv = obj; -AG_CursorWGL *cg = ac-&amp;gt;p; +AG_CursorWGL *acWGL = (AG_CursorWGL *)ac;    if (drv-&amp;gt;activeCursor == ac) {  return (0);  } -SetCursor(cg-&amp;gt;cursor); +SetCursor(acWGL-&amp;gt;cursor);  drv-&amp;gt;activeCursor = ac;  return (0);  } &lt;/pre&gt;</description>     <dc:creator>Agar-SVN</dc:creator>     <dc:date>2015-02-19T15:13:40</dc:date>   </item>   <item rdf:about=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1958\">     <title>Agar: r9768 - trunk/core</title>     <link>http://permalink.gmane.org/gmane.comp.lib.agar.scm/1958</link>     <description>&lt;pre&gt;Author: vedge Date: 2015-02-19 10:07:13 -0500 (Thu, 19 Feb 2015) New Revision: 9768  Modified:    trunk/core/variable.c Log: use explicit %llu to print long long unsigned ints   Modified: trunk/core/variable.c =================================================================== --- trunk/core/variable.c2015-02-19 15:06:48 UTC (rev 9767) +++ trunk/core/variable.c2015-02-19 15:07:13 UTC (rev 9768) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -241,6 +241,8 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  #ifdef HAVE_64BIT  case AG_VARIABLE_SINT64:Snprintf(s, len, \"%lld\", (long long)V-&amp;gt;data.s64);break;  case AG_VARIABLE_P_SINT64:Snprintf(s, len, \"%lld\", (long long)*(Sint64 *)V-&amp;gt;data.p);break; +case AG_VARIABLE_UINT64:Snprintf(s, len, \"%llu\", (unsigned long long)V-&amp;gt;data.u64);break; +case AG_VARIABLE_P_UINT64:Snprintf(s, len, \"%llu\", (unsigned long long)*(Sint64 *)V-&amp;gt;data.p);break;  #endif  case AG_VARIABLE_FLOAT:Snprintf(s, len, \"%.2f\", V-&amp;gt;data.flt);break;  case AG_VARIABLE_P_FLOAT:Snprintf(s, len, \"%.2f\", *(float *)V-&amp;gt;data.p);break; &lt;/pre&gt;</description>     <dc:creator>Agar-SVN</dc:creator>     <dc:date>2015-02-19T15:07:13</dc:date>   </item>   <item rdf:about=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1957\">     <title>Agar: r9767 - trunk/core</title>     <link>http://permalink.gmane.org/gmane.comp.lib.agar.scm/1957</link>     <description>&lt;pre&gt;Author: vedge Date: 2015-02-19 10:06:48 -0500 (Thu, 19 Feb 2015) New Revision: 9767  Modified:    trunk/core/error.c Log: if USE_WIN32_CONSOLE is defined (not default), use AttachConsole() and redirect AG_Verbose() / AG_Debug() output to the parent process's console..   Modified: trunk/core/error.c =================================================================== --- trunk/core/error.c2015-02-12 13:12:43 UTC (rev 9766) +++ trunk/core/error.c2015-02-19 15:06:48 UTC (rev 9767) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1,5 +1,5 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  /* - * Copyright (c) 2002-2012 Hypertriton, Inc. &amp;lt;http://hypertriton.com/&amp;gt; + * Copyright (c) 2002-2015 Hypertriton, Inc. &amp;lt;http://hypertriton.com/&amp;gt;   * All rights reserved.   *   * Redistribution and use in source and binary forms, with or without &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -45,6 +45,15 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_ThreadKey agErrorCodeKey;  #endif   +/* Redirect Verbose() output to \"foo-out.txt\" file */ +/* #define VERBOSE_TO_FILE */ + +/* Redirect Debug() output to \"foo-debug.txt\" file */ +/* #define DEBUG_TO_FILE */ + +/* Use AttachConsole() on Windows */ +/* #define USE_WIN32_CONSOLE */ +  int agDebugLvl = 1;/* Default debug level */    static void (*agErrorCallback)(const char *) = NULL; &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -69,12 +78,19 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_ThreadKeySet(agErrorMsgKey, NULL);  AG_ThreadKeySet(agErrorCodeKey, NULL);  #endif + +#if defined(_WIN32) &amp;amp;&amp;amp; defined(USE_WIN32_CONSOLE) +AttachConsole(ATTACH_PARENT_PROCESS); +#endif  return (0);  }    void  AG_DestroyErrorSubsystem(void)  { +#if defined(_WIN32) &amp;amp;&amp;amp; defined(USE_WIN32_CONSOLE) +FreeConsole(); +#endif  Free(agErrorMsg);  agErrorMsg = NULL;  agErrorCode = AG_EUNDEFINED; &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -121,7 +137,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  const char *  AG_Strerror(int error)   { -#if defined(_WIN32) &amp;amp;&amp;amp; !defined (_XBOX) +#if defined(_WIN32) &amp;amp;&amp;amp; !defined(_XBOX)  static char *str = NULL;  char *p;   &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -193,7 +209,8 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  }  if (agDebugLvl &amp;gt;= 1 || (obj != NULL &amp;amp;&amp;amp; OBJECT_DEBUG(obj))) {  va_start(args, fmt); -# ifdef _WIN32 +# if defined(DEBUG_TO_FILE) +/* Redirect output to foo-debug.txt */  {  char path[AG_FILENAME_MAX];  FILE *f; &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -205,10 +222,35 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  Strlcpy(path, \"debug.txt\", sizeof(path));  }  if ((f = fopen(path, \"a\")) != NULL) { +if (obj != NULL) { +if (OBJECT(obj)-&amp;gt;name[0] != '\\\\0') { +fprintf(f, \"%s: \", OBJECT(obj)-&amp;gt;name); +} else { +fprintf(f, \"&amp;lt;%p&amp;gt;: \", obj); +} +}  vfprintf(f, fmt, args);  fclose(f);  }  } +# elif defined(_WIN32) &amp;amp;&amp;amp; defined(USE_WIN32_CONSOLE) +{ +HANDLE cons; +char *buf; + +cons = GetStdHandle(STD_ERROR_HANDLE); +if (cons != NULL &amp;amp;&amp;amp; cons != INVALID_HANDLE_VALUE) { +if (obj != NULL &amp;amp;&amp;amp; +    OBJECT(obj)-&amp;gt;name[0] != '\\\\0') { +WriteConsole(cons, OBJECT(obj)-&amp;gt;name, +    strlen(OBJECT(obj)-&amp;gt;name), NULL, NULL); +WriteConsole(cons, \": \", 2, NULL, NULL); +} +Vasprintf(&amp;amp;buf, fmt, args); +WriteConsole(cons, buf, strlen(buf), NULL, NULL); +free(buf); +} +}  # else /* _WIN32 */  if (obj != NULL) {  if (OBJECT(obj)-&amp;gt;name[0] != '\\\\0') { &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -218,7 +260,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  }  }  vprintf(fmt, args); -# endif /* !_WIN32 */ +#endif  va_end(args);  }  #endif /* AG_DEBUG */ &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -246,7 +288,8 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  }    va_start(args, fmt); -#ifdef _WIN32 +#if defined(VERBOSE_TO_FILE) +/* Redirect output to foo-out.txt */  {  char path[AG_FILENAME_MAX];  FILE *f; &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -262,6 +305,18 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  fclose(f);  }  } +#elif defined(_WIN32) &amp;amp;&amp;amp; defined(USE_WIN32_CONSOLE) +{ +HANDLE cons; +char *buf; + +cons = GetStdHandle(STD_ERROR_HANDLE); +if (cons != NULL &amp;amp;&amp;amp; cons != INVALID_HANDLE_VALUE) { +Vasprintf(&amp;amp;buf, fmt, args); +WriteConsole(cons, buf, strlen(buf), NULL, NULL); +free(buf); +} +}  #else  vprintf(fmt, args);  #endif &lt;/pre&gt;</description>     <dc:creator>Agar-SVN</dc:creator>     <dc:date>2015-02-19T15:06:48</dc:date>   </item>   <item rdf:about=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1956\">     <title>Agar: r9766 - trunk/gui</title>     <link>http://permalink.gmane.org/gmane.comp.lib.agar.scm/1956</link>     <description>&lt;pre&gt;Author: vedge Date: 2015-02-12 08:12:43 -0500 (Thu, 12 Feb 2015) New Revision: 9766  Modified:    trunk/gui/window.c Log: - clean up detach-related code. in Detach(), insert the window in both Hide   and Detach queues. - send widget \"detached\" notification in event context, after the detach has   been processed. - update window's AG_WIDGET_VISIBLE flag in addition to \"visible\" member. - remove redundant locks in AG_WindowProcess*Queue(). - in AG_WindowShow() / AG_WindowHide(), acquire the agDrivers VFS lock in   addition to the window's lock.    Modified: trunk/gui/window.c =================================================================== --- trunk/gui/window.c2015-02-12 12:53:16 UTC (rev 9765) +++ trunk/gui/window.c2015-02-12 13:12:43 UTC (rev 9766) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1,5 +1,5 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  /* - * Copyright (c) 2001-2012 Hypertriton, Inc. &amp;lt;http://hypertriton.com/&amp;gt; + * Copyright (c) 2001-2015 Hypertriton, Inc. &amp;lt;http://hypertriton.com/&amp;gt;   * All rights reserved.   *   * Redistribution and use in source and binary forms, with or without &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -69,6 +69,9 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  \"_NET_WM_WINDOW_TYPE_DND\"  };   +/* #define DEBUG_VISIBILITY */ +/* #define DEBUG_FOCUS */ +  void  AG_InitWindowSystem(void)  { &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -285,7 +288,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  {  AG_Window *win = AG_SELF();  AG_Driver *drv = OBJECT(win)-&amp;gt;parent, *odrv; -AG_Window *owin, *subwin; +AG_Window *other, *subwin;  AG_Timer *to, *toNext;    #ifdef AG_DEBUG &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -297,10 +300,6 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  /* Mark window detach in progress */  win-&amp;gt;flags |= AG_WINDOW_DETACHING;   -/* Cancel any planned focus change to this window. */ -if (win == agWindowToFocus) -agWindowToFocus = NULL; -  /* Cancel any running timer attached to the window. */  AG_LockTiming();  for (to = TAILQ_FIRST(&amp;amp;OBJECT(win)-&amp;gt;timers); &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -310,48 +309,40 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_DelTimer(win, to);  }  AG_UnlockTiming(); - -if (win-&amp;gt;visible) -AG_WindowHide(win);   +/* Implicitely detach window dependencies. */  AGOBJECT_FOREACH_CHILD(odrv, &amp;amp;agDrivers, ag_driver) { -AG_FOREACH_WINDOW(owin, odrv) { -if (owin == win) { +AG_FOREACH_WINDOW(other, odrv) { +if (other == win) {  continue;  } -if (owin-&amp;gt;parent == win) { -AG_ObjectDetach(owin); -} -TAILQ_FOREACH(subwin, &amp;amp;owin-&amp;gt;subwins, swins) { +AG_ObjectLock(other); +TAILQ_FOREACH(subwin, &amp;amp;other-&amp;gt;subwins, swins) {  if (subwin == win)  break;  } -if (subwin != NULL) -TAILQ_REMOVE(&amp;amp;owin-&amp;gt;subwins, subwin, swins); +if (subwin != NULL) { +TAILQ_REMOVE(&amp;amp;other-&amp;gt;subwins, subwin, swins); +} +if (other-&amp;gt;pinnedTo == win) { +AG_WindowUnpin(other); +} +if (other-&amp;gt;parent == win || +    other-&amp;gt;transientFor == win) { +AG_ObjectDetach(other); +} +AG_ObjectUnlock(other);  }  } -#if 1 -goto out; -#endif -/* if (AGDRIVER_SINGLE(drv)) { */ -win-&amp;gt;tbar = NULL;/* No longer safe to use */ -win-&amp;gt;icon = NULL; -/* } */ - -/* - * Notify all child widgets of the window detach request. Widgets will - * acknowledge the request by resetting their drv and drvOps to NULL. - */ -AG_PostEvent(drv, win, \"detached\", NULL);     /* - * For a window detach operation to be free-threaded and safe in event - * context, the window list cannot be directly altered. We place the - * window in a detach queue which will be processed at the end of the - * event processing cycle. + * For the AG_ObjectDetach() call to be safe in (free-threaded) event + * context, we must defer the actual window hide / detach operation + * until the end of the current event processing cycle.   */ +TAILQ_INSERT_TAIL(&amp;amp;agWindowHideQ, win, visibility);  TAILQ_INSERT_TAIL(&amp;amp;agWindowDetachQ, win, detach); -out: +  AG_UnlockVFS(&amp;amp;agDrivers);  }   &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -377,6 +368,8 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  return (to-&amp;gt;ival);  } else {  AG_WindowSetOpacity(win, 1.0); + +/* Defer operation until AG_WindowProcessQueued(). */  AG_LockVFS(&amp;amp;agDrivers);  TAILQ_INSERT_TAIL(&amp;amp;agWindowHideQ, win, visibility);  AG_UnlockVFS(&amp;amp;agDrivers); &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -707,6 +700,12 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  Uint mwFlags = 0;  AG_Variable V;   +#ifdef DEBUG_VISIBILITY +Debug(win, \"Window \\\\\"%s\\\\\" now visible\\ \", win-&amp;gt;caption); +#endif +win-&amp;gt;visible = 1; +WIDGET(win)-&amp;gt;flags |= AG_WIDGET_VISIBLE; +  /* Compile the globally inheritable style attributes. */  AG_WidgetCompileStyle(win);   &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -750,15 +749,14 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    switch (AGDRIVER_CLASS(drv)-&amp;gt;wm) {  case AG_WM_SINGLE: -if (win-&amp;gt;flags &amp;amp; AG_WINDOW_MODAL) { -/* Use the per-driver modal window stack. */ +if (win-&amp;gt;flags &amp;amp; AG_WINDOW_MODAL) {/* Per-driver stack */  AG_InitPointer(&amp;amp;V, win);  AG_ListAppend(AGDRIVER_SW(drv)-&amp;gt;Lmodal, &amp;amp;V);  }  AG_WidgetUpdateCoords(win, WIDGET(win)-&amp;gt;x, WIDGET(win)-&amp;gt;y);  break;  case AG_WM_MULTIPLE: -if (win-&amp;gt;flags &amp;amp; AG_WINDOW_MODAL) { +if (win-&amp;gt;flags &amp;amp; AG_WINDOW_MODAL) {/* Global stack */  AG_InitPointer(&amp;amp;V, win);  AG_ListAppend(agModalWindows, &amp;amp;V);  } &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -783,15 +781,15 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  }  break;  } - -if (!(win-&amp;gt;flags &amp;amp; AG_WINDOW_DENYFOCUS)) -AG_WindowFocus(win);   -/* Notify that the window is now visible. */ +/* Notify widgets that the window is now visible. */  AG_PostEvent(NULL, win, \"window-shown\", NULL);   -/* Assume we gained focus. XXX */ -AG_PostEvent(NULL, win, \"window-gainfocus\", NULL); +/* Implicit focus change. */ +if (!(win-&amp;gt;flags &amp;amp; AG_WINDOW_DENYFOCUS)) { +agWindowFocused = win; +AG_PostEvent(NULL, win, \"window-gainfocus\", NULL); +}    /* Mark for redraw */  win-&amp;gt;dirty = 1; &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -813,16 +811,23 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_Driver *drv = WIDGET(win)-&amp;gt;drv;  AG_DriverSw *dsw;  int i; - -/* Cancel any pending redraw. */ + +#ifdef DEBUG_VISIBILITY +Debug(win, \"Window \\\\\"%s\\\\\" now hidden\\ \", win-&amp;gt;caption); +#endif +win-&amp;gt;visible = 0; +WIDGET(win)-&amp;gt;flags &amp;amp;= ~(AG_WIDGET_VISIBLE);  win-&amp;gt;dirty = 0; +win-&amp;gt;flags |= AG_WINDOW_NOCURSORCHG;   -/* Disallow cursor changes. */ -win-&amp;gt;flags |= AG_WINDOW_NOCURSORCHG; - -/* Cancel any pending focus change to this window. */ -if (win == agWindowToFocus) +/* Cancel focus state or any focus change requests. */ +if (win == agWindowToFocus) {  agWindowToFocus = NULL; +} +if (win == agWindowFocused) { +AG_PostEvent(NULL, win, \"window-lostfocus\", NULL); +agWindowFocused = NULL; +}    switch (AGDRIVER_CLASS(drv)-&amp;gt;wm) {  case AG_WM_SINGLE: &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -831,8 +836,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  if (OBJECT(drv)-&amp;gt;parent == NULL)  break;   -if (win-&amp;gt;flags &amp;amp; AG_WINDOW_MODAL) { -/* Remove from per-driver modal window stack. */ +if (win-&amp;gt;flags &amp;amp; AG_WINDOW_MODAL) {/* Per-driver stack */  for (i = 0; i &amp;lt; dsw-&amp;gt;Lmodal-&amp;gt;n; i++) {  if (dsw-&amp;gt;Lmodal-&amp;gt;v[i].data.p == win)  break; &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -841,7 +845,6 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_ListRemove(dsw-&amp;gt;Lmodal, i);  }  if (AGDRIVER_CLASS(drv)-&amp;gt;type == AG_FRAMEBUFFER) { -/* Update the background. */  AG_DrawRectFilled(win,      AG_RECT(0,0, WIDTH(win), HEIGHT(win)), dsw-&amp;gt;bgColor);  if (AGDRIVER_CLASS(drv)-&amp;gt;updateRegion != NULL) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -851,8 +854,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  }  break;  case AG_WM_MULTIPLE: -if (win-&amp;gt;flags &amp;amp; AG_WINDOW_MODAL) { -/* Remove from global modal window stack. */ +if (win-&amp;gt;flags &amp;amp; AG_WINDOW_MODAL) {/* Global stack */  for (i = 0; i &amp;lt; agModalWindows-&amp;gt;n; i++) {  if (agModalWindows-&amp;gt;v[i].data.p == win)  break; &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -866,6 +868,8 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  }  break;  } + +/* Notify widgets that the window is now hidden. */  AG_PostEvent(NULL, win, \"window-hidden\", NULL);  }   &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -900,19 +904,30 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  static void  OnFocusGain(AG_Event *event)  { -WidgetGainFocus(WIDGET(AG_SELF())); +AG_Window *win = AG_SELF(); + +#ifdef DEBUG_FOCUS +Debug(win, \"Window \\\\\"%s\\\\\" gained focus\\ \", win-&amp;gt;caption); +#endif +WidgetGainFocus(WIDGET(win));  }    static void  OnFocusLoss(AG_Event *event)  { -WidgetLostFocus(WIDGET(AG_SELF())); +AG_Window *win = AG_SELF(); + +#ifdef DEBUG_FOCUS +Debug(win, \"Window \\\\\"%s\\\\\" lost focus\\ \", win-&amp;gt;caption); +#endif +WidgetLostFocus(WIDGET(win));  }    /* Make a window visible to the user. */  void  AG_WindowShow(AG_Window *win)  { +AG_LockVFS(&amp;amp;agDrivers);  AG_ObjectLock(win);  if (!win-&amp;gt;visible) {  #ifdef AG_THREADS &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -924,40 +939,44 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  #endif  {  AG_PostEvent(NULL, win, \"widget-shown\", NULL); -win-&amp;gt;visible = 1; -WIDGET(win)-&amp;gt;flags |= AG_WIDGET_VISIBLE;  }  }  AG_ObjectUnlock(win); +AG_UnlockVFS(&amp;amp;agDrivers);  }    /* Make a window invisible to the user. */  void  AG_WindowHide(AG_Window *win)  { +AG_LockVFS(&amp;amp;agDrivers);  AG_ObjectLock(win); -if (win-&amp;gt;visible) { -if ((win-&amp;gt;flags &amp;amp; AG_WINDOW_FADEOUT) &amp;amp;&amp;amp; -   !(win-&amp;gt;flags &amp;amp; AG_WINDOW_DETACHING)) { -AG_AddTimer(win, &amp;amp;win-&amp;gt;fadeTo, -    (Uint32)((win-&amp;gt;fadeOutTime*1000.0)/(1.0/win-&amp;gt;fadeOutIncr)), -    FadeTimeout, \"%i\", -1); -} else { + +if (!win-&amp;gt;visible) { +goto out; +} +if ((win-&amp;gt;flags &amp;amp; AG_WINDOW_FADEOUT) &amp;amp;&amp;amp; +   !(win-&amp;gt;flags &amp;amp; AG_WINDOW_DETACHING)) { +AG_AddTimer(win, &amp;amp;win-&amp;gt;fadeTo, +    (Uint32)((win-&amp;gt;fadeOutTime*1000.0)/(1.0/win-&amp;gt;fadeOutIncr)), +    FadeTimeout, \"%i\", -1); +} else {  #ifdef AG_THREADS -if (!AG_ThreadEqual(AG_ThreadSelf(), agEventThread)) { -AG_LockVFS(&amp;amp;agDrivers); -TAILQ_INSERT_TAIL(&amp;amp;agWindowHideQ, win, visibility); -AG_UnlockVFS(&amp;amp;agDrivers); -} else +if (!AG_ThreadEqual(AG_ThreadSelf(), agEventThread)) { +AG_LockVFS(&amp;amp;agDrivers); +TAILQ_INSERT_TAIL(&amp;amp;agWindowHideQ, win, visibility); +AG_UnlockVFS(&amp;amp;agDrivers); +} else  #endif -{ -AG_PostEvent(NULL, win, \"widget-hidden\", NULL); -win-&amp;gt;visible = 0; -WIDGET(win)-&amp;gt;flags &amp;amp;= ~(AG_WIDGET_VISIBLE); -} +{ +AG_PostEvent(NULL, win, \"widget-hidden\", NULL); +win-&amp;gt;visible = 0; +WIDGET(win)-&amp;gt;flags &amp;amp;= ~(AG_WIDGET_VISIBLE);  }  } +out:  AG_ObjectUnlock(win); +AG_UnlockVFS(&amp;amp;agDrivers);  }    /* Build an ordered list of the focusable widgets in a window. */ &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1040,11 +1059,8 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  }    /* - * Give focus to a window. For single-window drivers, the operation only takes - * effect at the end of the current event cycle. For multiple-window drivers, - * the change takes effect immediately. If the window is not attached to a - * driver, the operation is deferred until the next attach. If NULL is given, - * cancel any planned focus change. + * Give input focus to a window. The actual focus change will take effect at + * the end of the current event cycle.   */  void  AG_WindowFocus(AG_Window *win) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1107,8 +1123,8 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  }    /* - * Place focus on a Window following a click at the given coordinates, - * in the video context of a specified single-display driver. + * Focus the window at specified display coordinates x,y + * (single-window drivers only).   *   * Returns 1 if the focus state has changed as a result.   */ &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1117,8 +1133,11 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  {  AG_Window *win;   +AG_LockVFS(&amp;amp;agDrivers); +  AG_ASSERT_CLASS(dsw, \"AG_Driver:AG_DriverSw:*\");  agWindowToFocus = NULL; +  AG_FOREACH_WINDOW_REVERSE(win, dsw) {  AG_ObjectLock(win);  if (!win-&amp;gt;visible || &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1129,8 +1148,10 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  }  agWindowToFocus = win;  AG_ObjectUnlock(win); +AG_UnlockVFS(&amp;amp;agDrivers);  return (1);  } +AG_UnlockVFS(&amp;amp;agDrivers);  return (0);  }   &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1888,43 +1909,40 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  agWindowToFocus = NULL;  }   -/* Make windows on the show queue visible. */ +/* + * Make windows on the show queue visible. + * The agDrivers VFS must be locked. + */  void  AG_WindowProcessShowQueue(void)  { -AG_Window *win, *winNext; +AG_Window *win;   -AG_LockVFS(&amp;amp;agDrivers); -for (win = TAILQ_FIRST(&amp;amp;agWindowShowQ); -     win != TAILQ_END(&amp;amp;agWindowShowQ); -     win = winNext) { -winNext = TAILQ_NEXT(win, visibility); +TAILQ_FOREACH(win, &amp;amp;agWindowShowQ, visibility) {  AG_PostEvent(NULL, win, \"widget-shown\", NULL); -win-&amp;gt;visible = 1;  }  TAILQ_INIT(&amp;amp;agWindowShowQ); -AG_UnlockVFS(&amp;amp;agDrivers);  }   -/* Make windows on the hide queue invisible. */ +/* + * Make windows on the hide queue invisible. + * The agDrivers VFS must be locked. + */  void  AG_WindowProcessHideQueue(void)  { -AG_Window *win, *winNext; +AG_Window *win;   -AG_LockVFS(&amp;amp;agDrivers); -for (win = TAILQ_FIRST(&amp;amp;agWindowHideQ); -     win != TAILQ_END(&amp;amp;agWindowHideQ); -     win = winNext) { -winNext = TAILQ_NEXT(win, visibility); -win-&amp;gt;visible = 0; +TAILQ_FOREACH(win, &amp;amp;agWindowHideQ, visibility) {  AG_PostEvent(NULL, win, \"widget-hidden\", NULL);  }  TAILQ_INIT(&amp;amp;agWindowHideQ); -AG_UnlockVFS(&amp;amp;agDrivers);  }   -/* Close and destroy windows on the detach queue. */ +/* + * Close and destroy windows on the detach queue. + * The agDrivers VFS must be locked. + */  void  AG_WindowProcessDetachQueue(void)  { &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1932,38 +1950,39 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_Driver *drv;  int closedMain = 0;   -AG_LockVFS(&amp;amp;agDrivers);  for (win = TAILQ_FIRST(&amp;amp;agWindowDetachQ);       win != TAILQ_END(&amp;amp;agWindowDetachQ);       win = winNext) {  winNext = TAILQ_NEXT(win, detach); +drv = WIDGET(win)-&amp;gt;drv;   -/* Cancel any planned focus change to this window. */ -if (win == agWindowFocused) -agWindowFocused = NULL; +#ifdef AG_DEBUG +if (win-&amp;gt;visible) { AG_FatalError(\"Detach on visible window\"); } +#endif   +/* Notify all widgets of the window detach. */ +AG_PostEvent(drv, win, \"detached\", NULL); +  /* Release the cursor areas and associated cursors. */  AG_UnmapAllCursors(win, NULL); - -/* Close the associated window in MW mode. */ -drv = WIDGET(win)-&amp;gt;drv; -if (AGDRIVER_MULTIPLE(drv) &amp;amp;&amp;amp; -    AGDRIVER_MW(drv)-&amp;gt;flags &amp;amp; AG_DRIVER_MW_OPEN) { -AGDRIVER_MW_CLASS(drv)-&amp;gt;closeWindow(win); -AGDRIVER_MW(drv)-&amp;gt;flags &amp;amp;= ~(AG_DRIVER_MW_OPEN); + +if (AGDRIVER_MULTIPLE(drv)) { +if (AGDRIVER_MW(drv)-&amp;gt;flags &amp;amp; AG_DRIVER_MW_OPEN) { +AGDRIVER_MW_CLASS(drv)-&amp;gt;closeWindow(win); +AGDRIVER_MW(drv)-&amp;gt;flags &amp;amp;= ~(AG_DRIVER_MW_OPEN); +} +} else { +win-&amp;gt;tbar = NULL;/* No longer safe to use */ +win-&amp;gt;icon = NULL;  }   -/* Remove the Window detach handler and free the object. */ +/* We can now perform the standard AG_ObjectDetach(). */  AG_ObjectSetDetachFn(win, NULL, NULL);  AG_ObjectDetach(win);    if (AGDRIVER_MULTIPLE(drv)) { -/* - * In multiple-window mode, free the driver instance - * associated with the window. - */  AG_UnlockVFS(&amp;amp;agDrivers); -AG_DriverClose(drv); +AG_DriverClose(drv);/* Free this driver instance */  AG_LockVFS(&amp;amp;agDrivers);  }  if (win-&amp;gt;flags &amp;amp; AG_WINDOW_MAIN) { &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1986,7 +2005,6 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_Terminate(0);  }  } -AG_UnlockVFS(&amp;amp;agDrivers);  }    int &lt;/pre&gt;</description>     <dc:creator>Agar-SVN</dc:creator>     <dc:date>2015-02-12T13:12:43</dc:date>   </item>   <item rdf:about=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1955\">     <title>Agar: r9765 - trunk/gui</title>     <link>http://permalink.gmane.org/gmane.comp.lib.agar.scm/1955</link>     <description>&lt;pre&gt;Author: vedge Date: 2015-02-12 07:53:16 -0500 (Thu, 12 Feb 2015) New Revision: 9765  Modified:    trunk/gui/widget.c Log: add missing lock in AG_WidgetShow() / AG_WidgetHide()    Modified: trunk/gui/widget.c =================================================================== --- trunk/gui/widget.c2015-02-12 12:52:41 UTC (rev 9764) +++ trunk/gui/widget.c2015-02-12 12:53:16 UTC (rev 9765) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1417,9 +1417,11 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  {  AG_Widget *wid = obj;   +AG_ObjectLock(wid);  wid-&amp;gt;flags &amp;amp;= ~(AG_WIDGET_HIDE);  AG_PostEvent(NULL, wid, \"widget-shown\", NULL);  AG_WindowUpdate(wid-&amp;gt;window); +AG_ObjectUnlock(wid);  }    /* Hide a widget */ &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1428,9 +1430,11 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  {  AG_Widget *wid = obj;   +AG_ObjectLock(wid);  wid-&amp;gt;flags |= AG_WIDGET_HIDE;  AG_PostEvent(NULL, wid, \"widget-hidden\", NULL);  AG_WindowUpdate(wid-&amp;gt;window); +AG_ObjectUnlock(wid);  }    /* Make a widget and all of its children visible. */ &lt;/pre&gt;</description>     <dc:creator>Agar-SVN</dc:creator>     <dc:date>2015-02-12T12:53:16</dc:date>   </item>   <item rdf:about=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1954\">     <title>Agar: r9764 - trunk/gui</title>     <link>http://permalink.gmane.org/gmane.comp.lib.agar.scm/1954</link>     <description>&lt;pre&gt;Author: vedge Date: 2015-02-12 07:52:41 -0500 (Thu, 12 Feb 2015) New Revision: 9764  Modified:    trunk/gui/drv_glx.c    trunk/gui/drv_wgl.c Log: prevent spurious double \"window-gainfocus\" and \"window-lostfocus\" events.    Modified: trunk/gui/drv_glx.c =================================================================== --- trunk/gui/drv_glx.c2015-02-12 12:51:10 UTC (rev 9763) +++ trunk/gui/drv_glx.c2015-02-12 12:52:41 UTC (rev 9764) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1,5 +1,5 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  /* - * Copyright (c) 2009-2013 Hypertriton, Inc. &amp;lt;http://hypertriton.com/&amp;gt; + * Copyright (c) 2009-2015 Hypertriton, Inc. &amp;lt;http://hypertriton.com/&amp;gt;   * All rights reserved.   *   * Redistribution and use in source and binary forms, with or without &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -666,8 +666,6 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  #ifdef DEBUG_XEVENTS  Debug(win, \"FocusIn\\ \");  #endif -agWindowFocused = win; -AG_PostEvent(NULL, win, \"window-gainfocus\", NULL);  dev-&amp;gt;type = AG_DRIVER_FOCUS_IN;  dev-&amp;gt;win = win;  break; &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -678,10 +676,6 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  #ifdef DEBUG_XEVENTS  Debug(win, \"FocusOut\\ \");  #endif -if (agWindowFocused == win) { -AG_PostEvent(NULL, win, \"window-lostfocus\", NULL); -agWindowFocused = NULL; -}  dev-&amp;gt;type = AG_DRIVER_FOCUS_OUT;  dev-&amp;gt;win = win;  break; &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -806,11 +800,13 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_PostEvent(NULL, dev-&amp;gt;win, \"window-leave\", NULL);  break;  case AG_DRIVER_FOCUS_IN: -agWindowFocused = dev-&amp;gt;win; -AG_PostEvent(NULL, dev-&amp;gt;win, \"window-gainfocus\", NULL); +if (agWindowFocused != dev-&amp;gt;win) { +agWindowFocused = dev-&amp;gt;win; +AG_PostEvent(NULL, dev-&amp;gt;win, \"window-gainfocus\", NULL); +}  break;  case AG_DRIVER_FOCUS_OUT: -if (dev-&amp;gt;win == agWindowFocused) { +if (agWindowFocused == dev-&amp;gt;win) {  AG_PostEvent(NULL, dev-&amp;gt;win, \"window-lostfocus\", NULL);  agWindowFocused = NULL;  } &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -858,7 +854,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_GL_Context *gl = &amp;amp;glx-&amp;gt;gl;  AG_Color c = WCOLOR(win,0);   -if (!glx-&amp;gt;w) +if (!glx-&amp;gt;w)/* XXX is this needed? */  return;    gl-&amp;gt;clipStates[0] = glIsEnabled(GL_CLIP_PLANE0); glEnable(GL_CLIP_PLANE0); &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -1423,7 +1419,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    AG_MutexUnlock(&amp;amp;glx-&amp;gt;lock);  AG_MutexUnlock(&amp;amp;agDisplayLock); - +  XFree(xvi);  return (0);  fail_ctx:  Modified: trunk/gui/drv_wgl.c =================================================================== --- trunk/gui/drv_wgl.c2015-02-12 12:51:10 UTC (rev 9763) +++ trunk/gui/drv_wgl.c2015-02-12 12:52:41 UTC (rev 9764) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -859,8 +859,10 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_PostEvent(NULL, dev-&amp;gt;win, \"window-leave\", NULL);  break;  case AG_DRIVER_FOCUS_IN: -agWindowFocused = dev-&amp;gt;win; -AG_PostEvent(NULL, dev-&amp;gt;win, \"window-gainfocus\", NULL); +if (dev-&amp;gt;win != agWindowFocused) { +agWindowFocused = dev-&amp;gt;win; +AG_PostEvent(NULL, dev-&amp;gt;win, \"window-gainfocus\", NULL); +}  break;  case AG_DRIVER_FOCUS_OUT:  if (dev-&amp;gt;win == agWindowFocused) { &lt;/pre&gt;</description>     <dc:creator>Agar-SVN</dc:creator>     <dc:date>2015-02-12T12:52:41</dc:date>   </item>   <item rdf:about=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1953\">     <title>Agar: r9763 - trunk/gui</title>     <link>http://permalink.gmane.org/gmane.comp.lib.agar.scm/1953</link>     <description>&lt;pre&gt;Author: vedge Date: 2015-02-12 07:51:10 -0500 (Thu, 12 Feb 2015) New Revision: 9763  Modified:    trunk/gui/AG_Window.3 Log: elaborate on detach operations and dependencies    Modified: trunk/gui/AG_Window.3 =================================================================== --- trunk/gui/AG_Window.32015-02-07 04:52:43 UTC (rev 9762) +++ trunk/gui/AG_Window.32015-02-12 12:51:10 UTC (rev 9763) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -43,18 +43,23 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  The  .Xr AG_Widget 3  objects form a tree structure attached to a parent -.Nm , -and the windows themselves are attached to some parent +.Nm . +Agar windows are attached to some parent  .Xr AG_Driver 3 -instance. -The parent driver provides an interface to some underlying window system.. +which provides a bridge between the Agar GUI system and the user's preferred +graphics platform / backend.  .Pp -Widgets can be attached directly to the +Widgets can be attached to the  .Nm -object, in which case -.Nm -will behave like a standard, vertical -.Xr AG_Box 3 . +object itself (it will behave like a standard, vertical +.Xr AG_Box 3 ) . +Agar's standard toolkit includes a variety of other container widgets, such as +.Xr AG_Box 3 , +.Xr AG_Fixed 3 , +.Xr AG_Pane 3 , +.Xr AG_Notebook 3 +and +.Xr AG_Scrollview 3 .  .Pp  The dimensions of new Agar windows is best determined automatically (using  recursive widget size requests which take resolution, font sizes, etc. into &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -63,16 +68,14 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  it can be determined automatically, or otherwise provide a suitable  application-level API for \"size hints\".  .Pp -In addition to -.Nm , -other widgets in the standard toolkit which are solely designed as -containers include -.Xr AG_Box 3 , -.Xr AG_Fixed 3 , -.Xr AG_Pane 3 , -.Xr AG_Notebook 3 -and -.Xr AG_Scrollview 3 . +Newly created windows (as returned by +.Fn AG_WindowNew ) +must be made visible using +.Fn AG_WindowShow . +To close a window and free its allocated resources, one call to +.Xr AG_ObjectDetach 3 +is sufficient (Agar will defer the actual destruction of the window +until it becomes safe to do so).  .Sh INHERITANCE HIERARCHY  .Xr AG_Object 3 -&amp;gt;  .Xr AG_Widget 3 -&amp;gt; &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -433,27 +436,35 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  .Pp  The  .Fn AG_WindowAttach -function makes +function registers  .Fa winChld -a logical child window of -.Fa winParent , -such that whenever the parent window is destroyed, Agar will automatically -destroy the child window as well. -Logical child windows also inherit the style properties from their parent. +as a child window dependent of +.Fa winParent . +Detaching the parent window (using +.Xr AG_ObjectDetach 3 ) +will cause dependent child windows to be detached implicitely. +Child windows also inherit the style properties from their parent. +The  .Fn AG_WindowDetach -detaches the window from its logical parent window. +function detaches the window from its parent window.  .Pp -The  .Fn AG_WindowMakeTransient -function makes +registers  .Fa winTrans -a \"transient\" window for +as a dependent and transient window for  .Fa winParent .  The effects of transient window state are dependent on the underlying -window manager. -For example, under Motif, transient windows have no titlebar buttons. -Under TWM, transient windows are created without requesting the initial -size from the user. +window system and window manager. +Under Motif, transient windows have no titlebar buttons. +Under TWM, transient windows are created without requesting that the user +select an initial geometry. +Detaching +.Fa winParent +(using +.Xr AG_ObjectDetach 3 ) +will cause +.Fa winTrans +to be detached implicitely.  .Pp  The  .Fn AG_WindowPin &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -689,13 +700,13 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  Read-only (use  .Fn AG_WindowSetMinSize ) .  .It Ft AG_Window *parent -Pointer to \"logical\" parent window, or NULL if there isn't any. +Pointer to parent window, or NULL if there isn't any.  Read-only (see  .Fn AG_WindowAttach  and  .Fn AG_WindowDetach ) .  .It Ft TAILQ subwins -List of \"logical\" child windows. +List of dependent child windows.  Read-only (see  .Fn AG_WindowAttach  and &lt;/pre&gt;</description>     <dc:creator>Agar-SVN</dc:creator>     <dc:date>2015-02-12T12:51:10</dc:date>   </item>   <item rdf:about=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1952\">     <title>Agar: r9762 - trunk/gui</title>     <link>http://permalink.gmane.org/gmane.comp.lib.agar.scm/1952</link>     <description>&lt;pre&gt;Author: vedge Date: 2015-02-06 23:52:43 -0500 (Fri, 06 Feb 2015) New Revision: 9762  Modified:    trunk/gui/window.c Log: - in Detach(), cancel any running timers attached to the window just like AG_ObjectDetach() normally does. - in AG_WindowHide(), ignore FADEOUT if a detach is in progress.   Modified: trunk/gui/window.c =================================================================== --- trunk/gui/window.c2015-02-07 04:50:55 UTC (rev 9761) +++ trunk/gui/window.c2015-02-07 04:52:43 UTC (rev 9762) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -222,11 +222,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  return AG_WindowNewNamedS(flags, s);  }   -/* - * Window attach function (we don't use the default Object attach function - * because AG_WINDOW_KEEPBELOW windows have to be inserted at the head of - * the list). - */ +/* Special implementation of AG_ObjectAttach() for AG_Window. */  static void  Attach(AG_Event *event)  { &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -283,14 +279,14 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_WindowFocus(win);  }   -/* Window detach function. */ +/* Special implementation of AG_ObjectDetach() for AG_Window. */  static void  Detach(AG_Event *event)  {  AG_Window *win = AG_SELF();  AG_Driver *drv = OBJECT(win)-&amp;gt;parent, *odrv; -AG_Window *subwin; -AG_Window *owin; +AG_Window *owin, *subwin; +AG_Timer *to, *toNext;    #ifdef AG_DEBUG  if (drv == NULL || !AG_OfClass(drv, \"AG_Driver:*\")) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -300,19 +296,31 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    /* Mark window detach in progress */  win-&amp;gt;flags |= AG_WINDOW_DETACHING; + +/* Cancel any planned focus change to this window. */ +if (win == agWindowToFocus) +agWindowToFocus = NULL; + +/* Cancel any running timer attached to the window. */ +AG_LockTiming(); +for (to = TAILQ_FIRST(&amp;amp;OBJECT(win)-&amp;gt;timers); +     to != TAILQ_END(&amp;amp;OBJECT(win)-&amp;gt;timers); +     to = toNext) { +toNext = TAILQ_NEXT(to, timers); +AG_DelTimer(win, to); +} +AG_UnlockTiming();   -/* - * Remove all dependencies toward this window. Child windows are - * reparented to NULL and sent a `window-close' event. - */ +if (win-&amp;gt;visible) +AG_WindowHide(win); +  AGOBJECT_FOREACH_CHILD(odrv, &amp;amp;agDrivers, ag_driver) {  AG_FOREACH_WINDOW(owin, odrv) {  if (owin == win) {  continue;  }  if (owin-&amp;gt;parent == win) { -AG_PostEvent(NULL, owin, \"window-close\", NULL); -owin-&amp;gt;parent = NULL; +AG_ObjectDetach(owin);  }  TAILQ_FOREACH(subwin, &amp;amp;owin-&amp;gt;subwins, swins) {  if (subwin == win) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -322,22 +330,17 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  TAILQ_REMOVE(&amp;amp;owin-&amp;gt;subwins, subwin, swins);  }  } +#if 1 +goto out; +#endif +/* if (AGDRIVER_SINGLE(drv)) { */ +win-&amp;gt;tbar = NULL;/* No longer safe to use */ +win-&amp;gt;icon = NULL; +/* } */   -/* Cancel any planned focus change to this window. */ -if (win == agWindowToFocus) -agWindowToFocus = NULL; - -if (win-&amp;gt;visible) -AG_WindowHide(win); - -/* Titlebar and icons are no longer safe to reference. */ -if (win-&amp;gt;tbar != NULL) { win-&amp;gt;tbar = NULL; } -if (win-&amp;gt;icon != NULL) { win-&amp;gt;icon = NULL; } -  /* - * Notify all child widgets of the window detach request. Widgets - * acknowledge the request by resetting their drv and drvOps pointers - * to NULL. + * Notify all child widgets of the window detach request. Widgets will + * acknowledge the request by resetting their drv and drvOps to NULL.   */  AG_PostEvent(drv, win, \"detached\", NULL);   &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -348,7 +351,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;   * event processing cycle.   */  TAILQ_INSERT_TAIL(&amp;amp;agWindowDetachQ, win, detach); - +out:  AG_UnlockVFS(&amp;amp;agDrivers);  }   &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -837,13 +840,10 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  if (i &amp;lt; dsw-&amp;gt;Lmodal-&amp;gt;n)  AG_ListRemove(dsw-&amp;gt;Lmodal, i);  } - -/* Update the background. */ -/* XXX XXX XXX no need for the fill rect? */  if (AGDRIVER_CLASS(drv)-&amp;gt;type == AG_FRAMEBUFFER) { +/* Update the background. */  AG_DrawRectFilled(win, -    AG_RECT(0,0, WIDTH(win), HEIGHT(win)), -    dsw-&amp;gt;bgColor); +    AG_RECT(0,0, WIDTH(win), HEIGHT(win)), dsw-&amp;gt;bgColor);  if (AGDRIVER_CLASS(drv)-&amp;gt;updateRegion != NULL)  AGDRIVER_CLASS(drv)-&amp;gt;updateRegion(drv,      AG_RECT(WIDGET(win)-&amp;gt;x, WIDGET(win)-&amp;gt;y, &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -937,7 +937,8 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  {  AG_ObjectLock(win);  if (win-&amp;gt;visible) { -if (win-&amp;gt;flags &amp;amp; AG_WINDOW_FADEOUT) { +if ((win-&amp;gt;flags &amp;amp; AG_WINDOW_FADEOUT) &amp;amp;&amp;amp; +   !(win-&amp;gt;flags &amp;amp; AG_WINDOW_DETACHING)) {  AG_AddTimer(win, &amp;amp;win-&amp;gt;fadeTo,      (Uint32)((win-&amp;gt;fadeOutTime*1000.0)/(1.0/win-&amp;gt;fadeOutIncr)),      FadeTimeout, \"%i\", -1); &lt;/pre&gt;</description>     <dc:creator>Agar-SVN</dc:creator>     <dc:date>2015-02-07T04:52:44</dc:date>   </item>   <item rdf:about=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1951\">     <title>Agar: r9760 - trunk/core</title>     <link>http://permalink.gmane.org/gmane.comp.lib.agar.scm/1951</link>     <description>&lt;pre&gt;Author: vedge Date: 2015-02-06 23:50:28 -0500 (Fri, 06 Feb 2015) New Revision: 9760  Modified:    trunk/core/AG_Object.3    trunk/core/object.c Log: AG_TIMER_SURVIVE_DETACH is not needed   Modified: trunk/core/AG_Object.3 =================================================================== --- trunk/core/AG_Object.32015-02-06 13:54:29 UTC (rev 9759) +++ trunk/core/AG_Object.32015-02-07 04:50:28 UTC (rev 9760) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -215,9 +215,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  .Fn AG_ObjectDetach  cancels any scheduled  .Xr AG_Timer 3 -callback (unless the timer has the -.Dv AG_TIMER_SURVIVE_DETACH -flag). +callback.  If  .Fa parent  is NULL,  Modified: trunk/core/object.c =================================================================== --- trunk/core/object.c2015-02-06 13:54:29 UTC (rev 9759) +++ trunk/core/object.c2015-02-07 04:50:28 UTC (rev 9760) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -501,17 +501,13 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  goto out;  }   -/* - * Cancel any running timers. This behavior can be overridden with - * the AG_TIMER_SURVIVE_DETACH flag. - */ +/* Cancel any running timer associated with the object. */  AG_LockTiming();  for (to = TAILQ_FIRST(&amp;amp;chld-&amp;gt;timers);       to != TAILQ_END(&amp;amp;chld-&amp;gt;timers);       to = toNext) {  toNext = TAILQ_NEXT(to, timers); -if ((to-&amp;gt;flags &amp;amp; AG_TIMER_SURVIVE_DETACH) == 0) -AG_DelTimer(chld, to); +AG_DelTimer(chld, to);  }  AG_UnlockTiming(); &lt;/pre&gt;</description>     <dc:creator>Agar-SVN</dc:creator>     <dc:date>2015-02-07T04:50:29</dc:date>   </item>   <item rdf:about=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1950\">     <title>Agar: r9759 - in trunk: dev math vg</title>     <link>http://permalink.gmane.org/gmane.comp.lib.agar.scm/1950</link>     <description>&lt;pre&gt;Author: vedge Date: 2015-02-06 08:54:29 -0500 (Fri, 06 Feb 2015) New Revision: 9759  Modified:    trunk/dev/browser.c    trunk/dev/config.c    trunk/dev/object.c    trunk/math/m_plotter.c    trunk/vg/vg_view.c Log: - use AG_WidgetShowAll() / AG_WidgetHideAll() - use AG_NotebookAdd()    Modified: trunk/dev/browser.c =================================================================== --- trunk/dev/browser.c2015-02-06 13:53:55 UTC (rev 9758) +++ trunk/dev/browser.c2015-02-06 13:54:29 UTC (rev 9759) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -771,7 +771,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  #endif /* AG_DEBUG */    nb = AG_NotebookNew(win, AG_NOTEBOOK_HFILL|AG_NOTEBOOK_VFILL); -ntab = AG_NotebookAddTab(nb, _(\"Working copy\"), AG_BOX_VERT); +ntab = AG_NotebookAdd(nb, _(\"Working copy\"), AG_BOX_VERT);  {  AG_MenuItem *mi;    Modified: trunk/dev/config.c =================================================================== --- trunk/dev/config.c2015-02-06 13:53:55 UTC (rev 9758) +++ trunk/dev/config.c2015-02-06 13:54:29 UTC (rev 9759) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -235,13 +235,13 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_WindowSetCloseAction(win, AG_WINDOW_DETACH);    nb = AG_NotebookNew(win, AG_NOTEBOOK_HFILL|AG_NOTEBOOK_VFILL); -tab = AG_NotebookAddTab(nb, _(\"Video\"), AG_BOX_VERT); +tab = AG_NotebookAdd(nb, _(\"Video\"), AG_BOX_VERT);  {  AG_NumericalNewIntR(tab, 0, \"%\", _(\"Screenshot quality: \"),      &amp;amp;agScreenshotQuality, 1, 100);  }   -tab = AG_NotebookAddTab(nb, _(\"GUI\"), AG_BOX_VERT); +tab = AG_NotebookAdd(nb, _(\"GUI\"), AG_BOX_VERT);  {  AG_CheckboxNewInt(tab, 0, _(\"Built-in key composition\"),      &amp;amp;agTextComposition); &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -262,7 +262,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;      &amp;amp;agKbdRepeat, 1, 500);  }   -tab = AG_NotebookAddTab(nb, _(\"Directories\"), AG_BOX_VERT); +tab = AG_NotebookAdd(nb, _(\"Directories\"), AG_BOX_VERT);  {  hb = AG_BoxNewHoriz(tab, AG_BOX_HFILL);  tbox = AG_TextboxNewS(hb, AG_TEXTBOX_HFILL, _(\"Temporary file directory: \")); &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -292,7 +292,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_SetEvent(tbox, \"textbox-return\", SetPath, \"%s\", \"font-path\");  }  #if 0 -tab = AG_NotebookAddTab(nb, _(\"Colors\"), AG_BOX_VERT); +tab = AG_NotebookAdd(nb, _(\"Colors\"), AG_BOX_VERT);  {  AG_Pane *hPane;  AG_HSVPal *hsv; &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -333,7 +333,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  #endif    #ifdef AG_DEBUG -tab = AG_NotebookAddTab(nb, _(\"Debug\"), AG_BOX_VERT); +tab = AG_NotebookAdd(nb, _(\"Debug\"), AG_BOX_VERT);  {  AG_NumericalNewIntR(tab, 0, NULL, _(\"Debug level: \"),      &amp;amp;agDebugLvl, 0, 255);  Modified: trunk/dev/object.c =================================================================== --- trunk/dev/object.c2015-02-06 13:53:55 UTC (rev 9758) +++ trunk/dev/object.c2015-02-06 13:54:29 UTC (rev 9759) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -211,7 +211,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_WindowSetPosition(win, AG_WINDOW_UPPER_RIGHT, 1);    nb = AG_NotebookNew(win, AG_NOTEBOOK_HFILL|AG_NOTEBOOK_VFILL); -ntab = AG_NotebookAddTab(nb, _(\"Infos\"), AG_BOX_VERT); +ntab = AG_NotebookAdd(nb, _(\"Infos\"), AG_BOX_VERT);  {  AG_Textbox *tbMD5, *tbSHA1, *tbRMD160;   &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -255,20 +255,20 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  }  }   -ntab = AG_NotebookAddTab(nb, _(\"Deps\"), AG_BOX_VERT); +ntab = AG_NotebookAdd(nb, _(\"Deps\"), AG_BOX_VERT);  {  tl = AG_TlistNew(ntab, AG_TLIST_POLL|AG_TLIST_EXPAND);  AG_TlistSizeHint(tl, \"XXXXXXXXXXXX\", 6);  AG_SetEvent(tl, \"tlist-poll\", PollDeps, \"%p\", ob);  }   -ntab = AG_NotebookAddTab(nb, _(\"Events\"), AG_BOX_VERT); +ntab = AG_NotebookAdd(nb, _(\"Events\"), AG_BOX_VERT);  {  tl = AG_TlistNew(ntab, AG_TLIST_POLL|AG_TLIST_EXPAND);  AG_SetEvent(tl, \"tlist-poll\", PollEvents, \"%p\", ob);  }   -ntab = AG_NotebookAddTab(nb, _(\"Variables\"), AG_BOX_VERT); +ntab = AG_NotebookAdd(nb, _(\"Variables\"), AG_BOX_VERT);  {  tl = AG_TlistNew(ntab, AG_TLIST_POLL|AG_TLIST_EXPAND);  AG_SetEvent(tl, \"tlist-poll\", PollVariables, \"%p\", ob);  Modified: trunk/math/m_plotter.c =================================================================== --- trunk/math/m_plotter.c2015-02-06 13:53:55 UTC (rev 9758) +++ trunk/math/m_plotter.c2015-02-06 13:54:29 UTC (rev 9759) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -214,7 +214,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_WindowSetPosition(win, AG_WINDOW_MIDDLE_LEFT, 0);    nb = AG_NotebookNew(win, AG_NOTEBOOK_EXPAND); -ntab = AG_NotebookAddTab(nb, _(\"Trace\"), AG_BOX_VERT); +ntab = AG_NotebookAdd(nb, _(\"Trace\"), AG_BOX_VERT);  {  AG_RadioNewUint(ntab, 0, type_names, (void *)&amp;amp;pl-&amp;gt;type);  M_NumericalNewReal(ntab, 0, NULL, _(\"X-scale: \"), &amp;amp;pl-&amp;gt;xScale); &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -223,7 +223,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_NumericalNewInt(ntab, 0, \"px\", _(\"X-offset: \"), &amp;amp;pl-&amp;gt;xOffs);  AG_NumericalNewInt(ntab, 0, \"px\", _(\"Y-offset: \"), &amp;amp;pl-&amp;gt;yOffs);  } -ntab = AG_NotebookAddTab(nb, _(\"Color\"), AG_BOX_VERT); +ntab = AG_NotebookAdd(nb, _(\"Color\"), AG_BOX_VERT);  {  AG_HSVPal *pal;   &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -232,7 +232,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_SetEvent(pal, \"h-changed\", UpdateLabel, \"%p\", pl);  AG_SetEvent(pal, \"sv-changed\", UpdateLabel, \"%p\", pl);  } -ntab = AG_NotebookAddTab(nb, _(\"Table\"), AG_BOX_VERT); +ntab = AG_NotebookAdd(nb, _(\"Table\"), AG_BOX_VERT);  {  AG_Table *tbl;    Modified: trunk/vg/vg_view.c =================================================================== --- trunk/vg/vg_view.c2015-02-06 13:53:55 UTC (rev 9758) +++ trunk/vg/vg_view.c2015-02-06 13:54:29 UTC (rev 9759) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -892,7 +892,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    AG_ObjectFreeChildren(editArea);  AG_WidgetUpdate(editArea); -AG_WidgetHiddenRecursive(editArea); +AG_WidgetHideAll(editArea);  }  AG_ObjectUnlock(vv);  } &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -909,7 +909,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_ObjectFreeChildren(vv-&amp;gt;editAreas[editArea]);  AG_ObjectAttach(vv-&amp;gt;editAreas[editArea], wEdit);  AG_WidgetUpdate(vv-&amp;gt;editAreas[editArea]); -AG_WidgetShownRecursive(vv-&amp;gt;editAreas[editArea]); +AG_WidgetShowAll(vv-&amp;gt;editAreas[editArea]);  }  } &lt;/pre&gt;</description>     <dc:creator>Agar-SVN</dc:creator>     <dc:date>2015-02-06T13:54:29</dc:date>   </item>   <item rdf:about=\"http://permalink.gmane.org/gmane.comp.lib.agar.scm/1949\">     <title>Agar: r9758 - trunk/tests</title>     <link>http://permalink.gmane.org/gmane.comp.lib.agar.scm/1949</link>     <description>&lt;pre&gt;Author: vedge Date: 2015-02-06 08:53:55 -0500 (Fri, 06 Feb 2015) New Revision: 9758  Modified:    trunk/tests/agartest.c    trunk/tests/charsets.c    trunk/tests/compositing.c    trunk/tests/customwidget.c    trunk/tests/fixedres.c    trunk/tests/glview.c    trunk/tests/loader.c    trunk/tests/objsystem.c    trunk/tests/sockets.c    trunk/tests/threads.c    trunk/tests/widgets.c Log: plug some memleaks in the testsuite itself    Modified: trunk/tests/agartest.c =================================================================== --- trunk/tests/agartest.c2015-02-06 13:53:00 UTC (rev 9757) +++ trunk/tests/agartest.c2015-02-06 13:53:55 UTC (rev 9758) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -273,6 +273,9 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_ConsoleMsg(console, _(\"Test %s: terminated\"), ti-&amp;gt;name);  AG_ObjectDetach(ti-&amp;gt;win);  TAILQ_REMOVE(&amp;amp;tests, ti, instances); +if (ti-&amp;gt;tc-&amp;gt;destroy != NULL) { +ti-&amp;gt;tc-&amp;gt;destroy(ti); +}  free(ti);  }    Modified: trunk/tests/charsets.c =================================================================== --- trunk/tests/charsets.c2015-02-06 13:53:00 UTC (rev 9757) +++ trunk/tests/charsets.c2015-02-06 13:53:55 UTC (rev 9758) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -10,36 +10,40 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    #include &amp;lt;agar/config/have_iconv.h&amp;gt;   -char myASCII[20*4]; -char myUTF[30*4]; -char myLat1[30*4]; +typedef struct { +AG_TestInstance _inherit; +char myASCII[20*4]; +char myUTF[30*4]; +char myLat1[30*4]; +AG_Text *myTxt; +} MyTestInstance;    static int  TestGUI(void *obj, AG_Window *win)  { -AG_Text *myTxt; +MyTestInstance *ti = obj;  AG_Textbox *tb;    /* Bind to a C string in US-ASCII */ -AG_Strlcpy(myASCII, \"ASCII!\", sizeof(myASCII)); +AG_Strlcpy(ti-&amp;gt;myASCII, \"ASCII!\", sizeof(ti-&amp;gt;myASCII));  tb = AG_TextboxNew(win, AG_TEXTBOX_HFILL|AG_TEXTBOX_EXCL, -    \"ASCII Buffer: \\ (%lu bytes)\", sizeof(myASCII)); -AG_TextboxBindASCII(tb, myASCII, sizeof(myASCII)); +    \"ASCII Buffer: \\ (%lu bytes)\", sizeof(ti-&amp;gt;myASCII)); +AG_TextboxBindASCII(tb, ti-&amp;gt;myASCII, sizeof(ti-&amp;gt;myASCII));  AG_TextboxSizeHintLines(tb, 2);    /* Bind to a C string in UTF-8 */ -AG_Strlcpy(myUTF, \"\\\\xc3\\\\x85ngstrom!\", sizeof(myUTF)); +AG_Strlcpy(ti-&amp;gt;myUTF, \"\\\\xc3\\\\x85ngstrom!\", sizeof(ti-&amp;gt;myUTF));  tb = AG_TextboxNew(win, AG_TEXTBOX_HFILL|AG_TEXTBOX_EXCL, -    \"UTF-8 Buffer: \\ (%lu bytes)\", sizeof(myUTF)); -AG_TextboxBindUTF8(tb, myUTF, sizeof(myUTF)); +    \"UTF-8 Buffer: \\ (%lu bytes)\", sizeof(ti-&amp;gt;myUTF)); +AG_TextboxBindUTF8(tb, ti-&amp;gt;myUTF, sizeof(ti-&amp;gt;myUTF));  AG_TextboxSizeHintLines(tb, 2);    /* Bind to a C string in any iconv-supported encoding */  #ifdef HAVE_ICONV -AG_Strlcpy(myLat1, \"Overv\\\\xE5knign for feils\\\\xF8king!\", sizeof(myLat1)); +AG_Strlcpy(ti-&amp;gt;myLat1, \"Overv\\\\xE5knign for feils\\\\xF8king!\", sizeof(ti-&amp;gt;myLat1));  tb = AG_TextboxNew(win, AG_TEXTBOX_HFILL|AG_TEXTBOX_EXCL, -    \"LATIN-1 Buffer: \\ (%lu bytes)\", sizeof(myLat1)); -AG_TextboxBindEncoded(tb, \"ISO-8859-1\", myLat1, sizeof(myLat1)); +    \"LATIN-1 Buffer: \\ (%lu bytes)\", sizeof(ti-&amp;gt;myLat1)); +AG_TextboxBindEncoded(tb, \"ISO-8859-1\", ti-&amp;gt;myLat1, sizeof(ti-&amp;gt;myLat1));  AG_TextboxSizeHintLines(tb, 2);  AG_LabelNewS(win, 0, \"iconv support: YES\");  #else &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -50,30 +54,39 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_SeparatorNewHoriz(win);    /* Bind to a multilingual AG_Text(3) element. */ -myTxt = AG_TextNew(0); -AG_TextSetEnt(myTxt, AG_LANG_FR, \"Fran\\\\xc3\\\\xa7\\\\x61is!\"); -AG_TextSetEnt(myTxt, AG_LANG_EN, \"English!\"); -AG_TextSetEnt(myTxt, AG_LANG_NO, \"Norsk!\"); -AG_LabelNewS(win, 0, \"Multilingual AG_Text(3) buffer:\"); -tb = AG_TextboxNewS(win, -    AG_TEXTBOX_MULTILINGUAL|AG_TEXTBOX_EXPAND|AG_TEXTBOX_MULTILINE, -    NULL); -AG_TextboxBindText(tb, myTxt); -AG_TextboxSetLang(tb, AG_LANG_FR); -AG_TextboxSizeHint(tb, \"XXXXXXXXXXXXXXXXXXXXXXXXX\"); -AG_TextboxSizeHintLines(tb, 5); -AG_TextboxSetCursorPos(tb, -1);/* End of string */ +if ((ti-&amp;gt;myTxt = AG_TextNew(0)) != NULL) { +AG_TextSetEnt(ti-&amp;gt;myTxt, AG_LANG_FR, \"Fran\\\\xc3\\\\xa7\\\\x61is!\"); +AG_TextSetEnt(ti-&amp;gt;myTxt, AG_LANG_EN, \"English!\"); +AG_TextSetEnt(ti-&amp;gt;myTxt, AG_LANG_NO, \"Norsk!\"); +AG_LabelNewS(win, 0, \"Multilingual AG_Text(3) buffer:\"); +tb = AG_TextboxNewS(win, +    AG_TEXTBOX_MULTILINGUAL|AG_TEXTBOX_EXPAND|AG_TEXTBOX_MULTILINE, +    NULL); +AG_TextboxBindText(tb, ti-&amp;gt;myTxt); +AG_TextboxSetLang(tb, AG_LANG_FR); +AG_TextboxSizeHint(tb, \"XXXXXXXXXXXXXXXXXXXXXXXXX\"); +AG_TextboxSizeHintLines(tb, 5); +AG_TextboxSetCursorPos(tb, -1);/* End of string */ +}  return (0);  }   +static void +Destroy(void *obj) +{ +MyTestInstance *ti = obj; + +AG_TextFree(ti-&amp;gt;myTxt); +} +  const AG_TestCase charsetsTest = {  \"charsets\",  N_(\"Test AG_Editable(3) bound to buffers in different character sets\"), -\"1.4.2\", +\"1.5.0\",  0, -sizeof(AG_TestInstance), +sizeof(MyTestInstance),  NULL,/* init */ -NULL,/* destroy */ +Destroy,  NULL,/* test */  TestGUI,  NULL/* bench */  Modified: trunk/tests/compositing.c =================================================================== --- trunk/tests/compositing.c2015-02-06 13:53:00 UTC (rev 9757) +++ trunk/tests/compositing.c2015-02-06 13:53:55 UTC (rev 9758) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -28,7 +28,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_WindowSetFadeIn(win, 1.0f, 0.1f);    if (!AG_ConfigFile(\"load-path\", \"agar\", \"bmp\", path, sizeof(path))) { -AG_PixmapFromBMP(win, 0, path); +AG_PixmapFromFile(win, 0, path);  }  AG_LabelNew(win, 0, \"Testing AG_WINDOW_FADEIN\");   &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -45,9 +45,9 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    hb = AG_BoxNewHoriz(win, AG_BOX_HFILL);  if (!AG_ConfigFile(\"load-path\", \"agar\", \"bmp\", path, sizeof(path))) { -AG_PixmapFromBMP(hb, 0, path); -AG_PixmapFromBMP(hb, 0, path); -AG_PixmapFromBMP(hb, 0, path); +AG_PixmapFromFile(hb, 0, path); +AG_PixmapFromFile(hb, 0, path); +AG_PixmapFromFile(hb, 0, path);  }  hb = AG_BoxNewHoriz(win, AG_BOX_HFILL);  {  Modified: trunk/tests/customwidget.c =================================================================== --- trunk/tests/customwidget.c2015-02-06 13:53:00 UTC (rev 9757) +++ trunk/tests/customwidget.c2015-02-06 13:53:55 UTC (rev 9758) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -11,22 +11,12 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  static int  Init(void *obj)  { -if (inited++ &amp;gt; 0) { -return (0); +if (inited++ == 0) { +AG_RegisterClass(&amp;amp;myWidgetClass);  } -AG_RegisterClass(&amp;amp;myWidgetClass);  return (0);  }   -static void -Destroy(void *obj) -{ -if (--inited &amp;gt; 0) { -return; -} -AG_UnregisterClass(&amp;amp;myWidgetClass); -} -  static int  TestGUI(void *obj, AG_Window *win)  { &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -43,11 +33,11 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  const AG_TestCase customWidgetTest = {  \"customWidget\",  N_(\"Test registering a custom Agar widget\"), -\"1.4.2\", +\"1.5.0\",  0,  sizeof(AG_TestInstance),  Init, -Destroy, +NULL,/* destroy */  NULL,/* test */  TestGUI,  NULL/* bench */  Modified: trunk/tests/fixedres.c =================================================================== --- trunk/tests/fixedres.c2015-02-06 13:53:00 UTC (rev 9757) +++ trunk/tests/fixedres.c2015-02-06 13:53:55 UTC (rev 9758) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -28,7 +28,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    /* Create some background pixmap from an image file. */  if (!AG_ConfigFile(\"load-path\", \"menubg\", \"bmp\", path, sizeof(path))) { -if ((px = AG_PixmapFromBMP(fx, 0, path)) == NULL) { +if ((px = AG_PixmapFromFile(fx, 0, path)) == NULL) {  AG_LabelNewS(win, 0, AG_GetError());  fprintf(stderr, \"%s\\ \", AG_GetError());  exit(1);  Modified: trunk/tests/glview.c =================================================================== --- trunk/tests/glview.c2015-02-06 13:53:00 UTC (rev 9757) +++ trunk/tests/glview.c2015-02-06 13:53:55 UTC (rev 9758) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -194,7 +194,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  UpdateRotation(AG_Timer *to, AG_Event *event)  {  MyTestInstance *ti = AG_PTR(1); - +  if (++ti-&amp;gt;spin &amp;gt; 360.0f) { ti-&amp;gt;spin -= 360.0f; }  return (to-&amp;gt;ival);  } &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -290,7 +290,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  nb = AG_NotebookNew(pa-&amp;gt;div[0], AG_NOTEBOOK_EXPAND);    for (i = 0; i &amp;lt; 2; i++) { -ntab = AG_NotebookAddTab(nb, \"Test tab\", AG_BOX_VERT); +ntab = AG_NotebookAdd(nb, \"Test tab\", AG_BOX_VERT);    /* Create the AG_GLView widget. */  glv = AG_GLViewNew(ntab, AG_GLVIEW_EXPAND); &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -305,23 +305,24 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_GLViewButtondownFn(glv, ButtonDown, \"%p\", ti);    /* Update the rotation 30 times per second. */ -AG_AddTimerAuto(glv, 1000/30, UpdateRotation, \"%p\", ti); +AG_AddTimerAuto(win, 1000/30,  +    UpdateRotation, \"%p\", ti);  }    /* Edit ambient and diffuse color components. */  nbColor = AG_NotebookNew(pa-&amp;gt;div[1], AG_NOTEBOOK_EXPAND);  { -ntab = AG_NotebookAddTab(nbColor, \"Amb\", AG_BOX_VERT); +ntab = AG_NotebookAdd(nbColor, \"Amb\", AG_BOX_VERT);  pal = AG_HSVPalNew(ntab,      AG_HSVPAL_NOALPHA|AG_HSVPAL_EXPAND);  AG_BindFloat(pal, \"RGBAv\", ti-&amp;gt;ambient);   -ntab = AG_NotebookAddTab(nbColor, \"Dif\", AG_BOX_VERT); +ntab = AG_NotebookAdd(nbColor, \"Dif\", AG_BOX_VERT);  pal = AG_HSVPalNew(ntab,      AG_HSVPAL_NOALPHA|AG_HSVPAL_EXPAND);  AG_BindFloat(pal, \"RGBAv\", ti-&amp;gt;diffuse);   -ntab = AG_NotebookAddTab(nbColor, \"Spe\", AG_BOX_VERT); +ntab = AG_NotebookAdd(nbColor, \"Spe\", AG_BOX_VERT);  pal = AG_HSVPalNew(ntab,      AG_HSVPAL_NOALPHA|AG_HSVPAL_EXPAND);  AG_BindFloat(pal, \"RGBAv\", ti-&amp;gt;specular); &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -349,7 +350,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  #ifdef HAVE_OPENGL  sizeof(MyTestInstance),  Init, -NULL,/* destroy */ +NULL,  NULL,/* test */  TestGUI,  #else  Modified: trunk/tests/loader.c =================================================================== --- trunk/tests/loader.c2015-02-06 13:53:00 UTC (rev 9757) +++ trunk/tests/loader.c2015-02-06 13:53:55 UTC (rev 9758) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -85,7 +85,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  int i;    nb = AG_NotebookNew(win, AG_NOTEBOOK_EXPAND); -ntab = AG_NotebookAddTab(nb, \"Load file\", AG_BOX_VERT); +ntab = AG_NotebookAdd(nb, \"Load file\", AG_BOX_VERT);  {  /* Create the file loader widget. */  fd = AG_FileDlgNew(ntab, AG_FILEDLG_EXPAND); &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -126,7 +126,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  AG_BoxSetPadding(box, 10);  AG_FileDlgSetOptionContainer(fd, box);  } -ntab = AG_NotebookAddTab(nb, \"Select directory\", AG_BOX_VERT); +ntab = AG_NotebookAdd(nb, \"Select directory\", AG_BOX_VERT);  {  /* Create the directory selector widget. */  dd = AG_DirDlgNew(ntab, AG_DIRDLG_EXPAND);  Modified: trunk/tests/objsystem.c =================================================================== --- trunk/tests/objsystem.c2015-02-06 13:53:00 UTC (rev 9757) +++ trunk/tests/objsystem.c2015-02-06 13:53:55 UTC (rev 9758) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -13,6 +13,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  #include \"objsystem_mammal.h\"    typedef struct { +AG_TestInstance _inherit;  AG_Object vfsRoot;/* Our test VFS */  } MyTestInstance;    Modified: trunk/tests/sockets.c =================================================================== --- trunk/tests/sockets.c2015-02-06 13:53:00 UTC (rev 9757) +++ trunk/tests/sockets.c2015-02-06 13:53:55 UTC (rev 9758) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -77,7 +77,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    /* Create a pixmap */  if (!AG_ConfigFile(\"load-path\", \"menubg\", \"bmp\", path, sizeof(path))) { -if ((px = AG_PixmapFromBMP(fx, 0, path)) == NULL) { +if ((px = AG_PixmapFromFile(fx, 0, path)) == NULL) {  TestMsg(obj, \"%s: %s\", path, AG_GetError());  exit(1);  } &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -92,7 +92,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  if (AG_ConfigFile(\"load-path\", imageFiles[i], \"bmp\", path, sizeof(path)) != 0) {  continue;  } -pixmaps[i] = AG_SurfaceFromBMP(path); +pixmaps[i] = AG_SurfaceFromFile(path);  AG_SurfaceSetColorKey(pixmaps[i], AG_SRCCOLORKEY,      AG_MapPixelRGB(pixmaps[i]-&amp;gt;format, 0,255,0));  }  Modified: trunk/tests/threads.c =================================================================== --- trunk/tests/threads.c2015-02-06 13:53:00 UTC (rev 9757) +++ trunk/tests/threads.c2015-02-06 13:53:55 UTC (rev 9758) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -11,6 +11,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  #include &amp;lt;math.h&amp;gt;    typedef struct { +AG_TestInstance _inherit;  AG_Object workerMgr;  int      nWorkers;  AG_Window *winParent;  Modified: trunk/tests/widgets.c =================================================================== --- trunk/tests/widgets.c2015-02-06 13:53:00 UTC (rev 9757) +++ trunk/tests/widgets.c2015-02-06 13:53:55 UTC (rev 9758) &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -15,7 +15,11 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  #include &amp;lt;agar/config/ag_debug.h&amp;gt;  #include &amp;lt;agar/config/version.h&amp;gt;   -char textBuffer[30]; +typedef struct { +AG_TestInstance _inherit; +char textBuffer[30]; +char *someText; +} MyTestInstance;    /* Example callback for combo-selected. */  static void &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -45,6 +49,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  static int  TestGUI(void *obj, AG_Window *win)  { +MyTestInstance *ti = obj;  char path[AG_PATHNAME_MAX];  AG_Box *hBox, *vBox;  AG_Pane *pane; &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -67,9 +72,9 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  char path[AG_PATHNAME_MAX];  AG_Label *lbl;   -/* The Pixmap widget displays a raster surface. */ +/* The Pixmap widget can display an image surface. */  if (!AG_ConfigFile(\"load-path\", \"agar\", \"bmp\", path, sizeof(path))) -AG_PixmapFromBMP(div1, 0, path); +AG_PixmapFromFile(div1, 0, path);    /*   * The Label widget provides a simple static or polled label &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -189,13 +194,13 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;   * encoding.   */  { -AG_Strlcpy(textBuffer, \"Foo bar baz bezo\", sizeof(textBuffer)); +AG_Strlcpy(ti-&amp;gt;textBuffer, \"Foo bar baz bezo\", sizeof(ti-&amp;gt;textBuffer));    /* Create a textbox bound to a fixed-size buffer */  tbox = AG_TextboxNew(div1,      AG_TEXTBOX_EXCL|AG_TEXTBOX_HFILL,      \"Fixed text buffer: \"); -AG_TextboxBindUTF8(tbox, textBuffer, sizeof(textBuffer)); +AG_TextboxBindUTF8(tbox, ti-&amp;gt;textBuffer, sizeof(ti-&amp;gt;textBuffer));    /* Create a textbox bound to a built-in AG_Text element */  tbox = AG_TextboxNew(div1, &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -269,7 +274,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;    nb = AG_NotebookNew(div2, AG_NOTEBOOK_EXPAND);   -ntab = AG_NotebookAddTab(nb, \"Some table\", AG_BOX_VERT); +ntab = AG_NotebookAdd(nb, \"Some table\", AG_BOX_VERT);  {  float f;   &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -294,9 +299,8 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  }  }   -ntab = AG_NotebookAddTab(nb, \"Some text\", AG_BOX_VERT); +ntab = AG_NotebookAdd(nb, \"Some text\", AG_BOX_VERT);  { -char *someText;  size_t size, bufSize;  FILE *f;   &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -322,13 +326,13 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  size = ftell(f);  fseek(f, 0, SEEK_SET);  bufSize = size+1024; -someText = AG_Malloc(bufSize); -(void)fread(someText, size, 1, f); +ti-&amp;gt;someText = AG_Malloc(bufSize); +(void)fread(ti-&amp;gt;someText, size, 1, f);  fclose(f); -someText[size] = '\\\\0'; +ti-&amp;gt;someText[size] = '\\\\0';  } else { -someText = AG_Strdup(\"Failed to load loss.txt\"); -bufSize = strlen(someText)+1; +ti-&amp;gt;someText = AG_Strdup(\"Failed to load loss.txt\"); +bufSize = strlen(ti-&amp;gt;someText)+1;  }    /* &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -336,14 +340,14 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;   * size argument to AG_TextboxBindUTF8() must include   * space for the terminating NUL.   */ -AG_TextboxBindUTF8(tbox, someText, bufSize); +AG_TextboxBindUTF8(tbox, ti-&amp;gt;someText, bufSize);    /* Add a word wrapping control */  AG_CheckboxNewFn(ntab, 0, \"Word wrapping\",      SetWordWrap, \"%p\", tbox);  }   -ntab = AG_NotebookAddTab(nb, \"Empty tab\", AG_BOX_VERT); +ntab = AG_NotebookAdd(nb, \"Empty tab\", AG_BOX_VERT);  }  return (0);  } &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -351,6 +355,10 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  static int  Init(void *obj)  { +MyTestInstance *ti = obj; + +ti-&amp;gt;textBuffer[0] = '\\\\0'; +ti-&amp;gt;someText = NULL;  DEV_InitSubsystem(0);  return (0);  } &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -358,6 +366,9 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  static void  Destroy(void *obj)  { +MyTestInstance *ti = obj; + +Free(ti-&amp;gt;someText);  DEV_DestroySubsystem();  }   &amp;lt; at &amp;gt;&amp;lt; at &amp;gt; -366,7 +377,7 &amp;lt; at &amp;gt;&amp;lt; at &amp;gt;  N_(\"Display various standard Agar widgets\"),  \"1.5.0\",  0, -sizeof(AG_TestInstance), +sizeof(MyTestInstance),  Init,  Destroy,  NULL,/* test */ &lt;/pre&gt;</description>     <dc:creator>Agar-SVN</dc:creator>     <dc:date>2015-02-06T13:53:55</dc:date>   </item>   <textinput rdf:about=\"http://search.gmane.org/?group=$group=gmane.comp.lib.agar.scm\">     <title>Search Engine</title>     <description>Search the mailing list at Gmane</description>     <name>query</name>     <link>http://search.gmane.org/?group=$group=gmane.comp.lib.agar.scm</link>   </textinput> </rdf:RDF> ", 
    "identity": {
        "subtype": "dataset", 
        "is_error": false, 
        "version": "", 
        "protocol": "RDF", 
        "language": "", 
        "service": "", 
        "has_dataset": false, 
        "has_metadata": false
    }, 
    "digest": "6fd27c0e1f8a0ac5ec5596bade6f3f04", 
    "source_url": "http://rss.gmane.org/messages/complete/gmane.comp.lib.agar.scm"
}