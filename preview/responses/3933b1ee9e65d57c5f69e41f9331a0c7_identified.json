{
    "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?><?rfc linefile=\"1:xml/complete/rfc2130.xml\"?> <!-- automatically generated by xml2rfc v1.36 on 2012-11-19T22:05:18Z --> <!DOCTYPE rfc SYSTEM \"rfc2629.dtd\"> <?rfc toc=\"yes\"?>  <!--      ASCII to XML transformation by Invisible Worlds, Inc.      http://invisible.net/      Last transformation: 03-Feb-1999, 02:04:02       Cannonical version of this document is at:      http://info.internet.isi.edu/in-notes/rfc/files/rfc2130.txt       Implementors should verify all content with      cannonical version.  Failure to do so may result in      protocol failures. --> <!--    Editor's note: May be missing appendix E.  Requires further         edit.  CM, 2/13/99 -->  <rfc number=\"2130\"      category=\"info\"> <front> <title abbrev=\"Character Set Workshop Report\">The Report of the IAB Character Set Workshop held 29 February - 1 March, 1996</title> <author initials=\"C.\" surname=\"Weider\" fullname=\"Chris Weider\"> <organization>Microsoft Corp.</organization> <address> <postal> <street>1 Microsoft Way</street> <street>Redmond</street> <street>WA 98052</street> <country>USA</country> </postal> <email>cweider@microsoft.com</email> </address> </author> <author initials=\"C.\" surname=\"Preston\" fullname=\"Cecilia Preston\"> <organization>Preston &amp; Lynch</organization> <address> <postal> <street>PO Box 8310</street> <street>Emeryville</street> <street>CA 94662</street> <country>USA</country> </postal> <email>cecilia@well.com</email> </address> </author> <author initials=\"K.\" surname=\"Simonsen\" fullname=\"Keld Simonsen\"> <organization>DKUUG</organization> <address> <postal> <street>Freubjergvey 3</street> <street>DK-2100 Kxbenhavn X</street> <street>Danmark</street> </postal> <email>Keld@dkuug.dk</email> </address> </author> <author initials=\"H.T.\" surname=\"Alvestrand\" fullname=\"Harald T. Alvestrand\"> <organization>UNINETT</organization> <address> <postal> <street>P.O.Box 6883 Elgeseter</street> <street>N-7002 TRONDHEIM</street> <country>NORWAY</country> </postal> <email>Harald.T.Alvestrand@uninett.no</email> </address> </author> <author initials=\"R.\" surname=\"Atkinson\" fullname=\"Randall Atkinson\"> <organization>cisco Systems</organization> <address> <postal> <street>170 West Tasman Drive</street> <street>San Jose</street> <street>CA 95134-1706</street> <country>USA</country> </postal> <email>rja@cisco.com</email> </address> </author> <author initials=\"M.\" surname=\"Crispin\" fullname=\"Mark Crispin\"> <organization>Networks &amp; Distributed Computing</organization> <address> <postal> <street>University of Washington</street> <street>4545 15th Avenue</street> <street>Seattle</street> <street>WA  98105-4527</street> <country>USA</country> </postal> <email>mrc@cac.washington.edu</email> </address> </author> <author initials=\"P.\" surname=\"Svanberg\" fullname=\"Peter Svanberg\"> <organization>Dept. of Numberical Analysis and Computing Science (Nada)</organization> <address> <postal> <street>Royal Institute of Technology</street> <street>SE-100 44 STOCKHOLM</street> <country>SWEDEN</country> </postal> <email>psv@nada.kth.se</email> </address> </author> <date month=\"April\" year=\"1997\"/> <area>Applications</area> <keyword>Internet Architecture Board</keyword> <keyword>character encoding</keyword> <keyword>multipurpose internet mail extensions</keyword> <keyword>workshop</keyword> <abstract> <t>    This report details the conclusions of an IAB-sponsored invitational    workshop held 29 February  - 1 March, 1996, to discuss the use of    character sets on the Internet.  It motivates the need to have    character set handling in Internet protocols which transmit text,    provides a conceptual framework for specifying character sets,    recommends the use of MIME tagging for transmitted text, recommends a    default character set *without* stating that there is no need for    other character sets, and makes a series of recommendations to the    IAB, IANA, and the IESG for furthering the integration of the    character set framework into text transmission protocols. </t> </abstract> <!-- RFC original section: (0:) --> <note title=\"Executive summary\"> <t>    The term &apos;Character Set&apos; means many things to many people. Even the    MIME registry of character sets registers items that have great    differences in semantics and applicability. This workshop provides    guidance to the IAB and IETF about the use of character sets on the    Internet and provides a common framework for interoperability between    the many characters in use there. </t> <t>    The framework consists of four components: an architecture model,    which specifies components necessary for on-the-wire transmission of    text; recommendations for tagging transmitted (and stored) text;    recommended defaults for each level of the model; and a set of    recommendations to the IAB, IANA, and the IESG for furthering the    integration of  this framework into text transmission protocols. </t> <t>    The architectural model specifies 7 layers, of which only three are    required for on-the-wire transmission. The Coded Character Set is a    mapping from a set of abstract characters to a set of integers. The    Character Encoding Scheme is a mapping from a Coded Character Set (or    several) to a set of octets. The Transfer Encoding Syntax is a    transformation applied to data which has been encoded using a    Character Encoding Scheme to allow it to be transmitted. These layers    should be specified in a transmitted text stream by using the MIME    encoding mechanisms. </t> <t>    This report recommends the use of ISO 10646 as the default Coded    Character Set, and UTF-8 as the default Character Encoding Scheme in    the creation of new protocols or new version of old protocols which    transmit text. These defaults do not deprecate the use of other    character sets when and where they are needed; they are simply    intended to provide guidance and a specification for    interoperability. </t> </note> </front> <middle> <!-- RFC original section: (1:) --> <section title=\"Introduction\"> <t>    This is the report of an IAB-sponsored invitational workshop on the    use of Character Sets on the Internet, held 29 February - 1 March    1996 at Information Sciences Institute (ISI) in Marina del Rey,    California.  In addition, this report covers the discussion on the    mailing list up to and slightly beyond the workshop itself.  The    goals of this workshop were to provide guidance to the IAB and the    IETF about the use of character sets on the Internet, and if possible    a common framework for interoperability between the many character    sets in use there.  Both goals were achieved. </t> </section> <!-- RFC original section: (2:) --> <section title=\"Character sets on the Internet - the problem\"> <t>    The term &apos;character set&apos; is typically applied to the contents of a    wide variety of text transmission and display protocols used on the    Internet.  Because the term is used to mean different things,    confusion has arisen.  For example, the MIME registry of character    sets [MIME] contains items that may differ greatly in their    applicability and semantics in various Internet protocols. </t> <t>    In addition, there is a vast profusion of different text encoding    schemes in use on the Internet.  This per se is not a problem; each    scheme has evolved to meet real needs.  However, information    applications such as mail, directories, and the World Wide Web have    each developed different techniques for dealing with the growing    number of schemes.  A robust information architecture for the    Internet requires as much interoperability between these techniques    as possible. </t> <!-- RFC original section: (2.1:) --> <section title=\"Related topics deemed out of scope for this workshop\"> <t>    Successful display of plain text transmitted over the Internet    requires a lot of information about the text itself, such as the    underlying character set, language, and so forth.  An additional set    of formatting information is needed if the receiving application    wishes to use local (cultural) conventions when it presents the data    to the user.  This formatting includes information, that provides the    data necessary to format certain  types of textual data (dates,    times, numbers and monetary notation) into a form which is familiar    to the user.  The POSIX [POSIX] notation of locale encompasses    language, coded character set and cultural conventions. </t> <t>    To avoid unfruitful discussion, and to make the best use of the time    available for the workshop, we declared the following  issues out of    scope for the purposes of this workshop: <list> <t>    -  glyphs </t> <t>    -  sorting </t> <t>    -  culture (e.g. do we present the American or British spelling?) </t> <t>    -  user interface issues </t> <t>    -  internal representation of textual data </t> <t>    -  included characters (why aren&apos;t certain characters available in           any character set?) </t> <t>    -  locale (in the POSIX sense) </t> <t>    -  font registration </t> <t>    -  semantics </t> <t>    -  user input/output issues </t> <t>    -  Han unification issues </t></list> </t> <t>    There are some related issues which were included for discussion,    most importantly the &apos;locale&apos; components necessary for transport and    identification of multilingual texts. </t> </section> <!-- RFC original section: (2.2:) --> <section title=\"Character Set handling in existing protocols\"> <t>    One of the group&apos;s overriding concerns was that the framework    developed for character set handling not break existing protocols.    With that in mind, the way character sets are being used in existing    protocols was examined.  See Appendix A for a list of those protocols    and some recommendations for change. </t> <!-- RFC original section: (2.2.1:) --> <section title=\"General comments\"> <t>    The problem areas here fall into three main categories: protocols,    identifiers, and data. </t> <!-- RFC original section: (2.2.1.1:) --> <section title=\"Protocols\"> <t>    The protocol machinery SHOULD NOT be changed; allowing, for instance,    SMTP [SMTP] to use both MAIL FROM and POST FRA is dangerous to the    protocols&apos; stability.  However, many protocols carry error messages    and other information that is intended for human consumption; it    MIGHT be an advantage to allow these to be localized into a specific    language and character set, rather than staying in English and US-    ASCII [ASCII].  If this is done, new extensions should follow the    framework outlined below. </t> </section> <!-- RFC original section: (2.2.1.2:) --> <section title=\"Identifiers.\"> <t>    There is a strong statement of direction from the IAB, RFC 1958 [RFC    1958],  which states: </t> <figure><artwork>         4.3 Public (i.e. widely visible) names should be in case             independent ASCII.  Specifically, this refers to DNS names,             and to protocol elements that are transmitted in text format.             ...         5.4 Designs should be fully international, with support for             localization (adaptation to local character sets). In             particular, there should be a uniform approach to character             set tagging for information content. </artwork></figure> <t>    In protocols that up to now have used US-ASCII only, UTF-8 [UTF-8]    forms a simple upgrade path; however, its use should be negotiated    either by negotiating a protocol version or by negotiating charset    usage, and a fallback to a US-ASCII compatible representation such as    UTF-7 [UTF-7] MUST be available. </t> <t>    The need for passing application data such as language on individual    identifiers varies between applications; protocols SHOULD attempt to    evaluate this need when designing mechanisms.  Applying the ASCII    requirement for identifiers that are only used in a local context    (such as private mailbox folder names) is both unrealistic and    unreasonable; in such cases, methods for consistency in the handling    of character set should be considered. </t> </section> <!-- RFC original section: (2.2.1.3:) --> <section title=\"Data\"> <t>    Data that require character set handling includes text, databases,    and HTML [HTML] pages, for example.  In these the support for    multiple character sets and proper application information is    absolutely vital, and MUST be supported. </t> </section> </section> </section> <!-- RFC original section: (2.3:) --> <section title=\"Architectural requirements\"> <t>    To address the issues enumerated for this work, first an    architectural model was created which establishes the components that    are required to fully specify the transmission of textual data. Many    of these components are already familiar to the users of encoding    protocols such as MIME.  Not all of these are discussed in detail in    this report; we restrict ourselves primarily to those components    which are required to specify the &apos;on-the-wire&apos; phase of text    transmission. </t> <t>    Mandating a single, all-encompassing character set would not fit well    with the IETF philosophy of planning for architectural diversity.    So, the best that can be done is to provide a common *framework* for    identifying and using the multitude of character sets available on    the Internet.  It would be an advantage if the total number of Coded    Character Sets could be kept to a minimum.  This framework should    meet the following requirements: <list> <t>    -  it should not break existing protocols (because then the likelihood         of deployment is very small), </t> <t>    -  it should allow the use of character sets currently used on the         Internet, and </t> <t>    -  it should be relatively easy to build into new protocols. </t></list> </t> </section> </section> <!-- RFC original section: (3:) --> <section title=\"Architectural model\"> <t>    The basic architectural model which guided our discussions is shown    in below.  A distinction was made between those segments which were    necessary to successfully transmit character set data on-the-wire and    those needed to present that data to a user in a comprehensible    manner.  The discussions were primarily restricted to those segments    of the model which specify the &apos;on-the-wire&apos; transmission of textual    data. <list> <t>    User interface issues: these are briefly discussed in Section 3.1.1. <list> <t>         Layout </t> <t>         Culture </t> <t>         Locale </t> <t>         Language </t></list> </t> <t>    On-the-wire: see section 3.2 for detailed discussion. <list> <t>         Transfer Syntax </t> <t>         Character Encoding Scheme </t> <t>         Coded Character Set </t></list> </t></list> </t> <!-- RFC original section: (3.1:) --> <section title=\"Segments defined\"> <t> </t> <!-- RFC original section: (3.1:1:) --> <section title=\"User interface\"> <t> </t> <!-- RFC original section: (3.1.1.1:) --> <section title=\"Layout\"> <t>    Layout includes the elements needed for displaying text to the user,    such as font selection, word-wrapping, etc.  It is similar to the    &apos;presentation&apos; layer in the 7-layer ISO telecommunications model    [ISO-7498]. </t> </section> <!-- RFC original section: (3.1.1.2:) --> <section title=\"Culture\"> <t>    Culture includes information about cultural preferences, which affect    spelling, word choice, and so forth. </t> </section> <!-- RFC original section: (3.1.1.3:) --> <section title=\"Locale\"> <t>    The locale component includes the information necessary to make    choices about text manipulation which will present the text to the    user in an expected format.  This information may include the display    of date, time and monetary symbol preferences.  Notice that locale    modifications are typically applied to a text stream before it is    presented to the user, although they also are used to specify input    formats. </t> </section> <!-- RFC original section: (3.1.1.4:) --> <section title=\"Language\"> <t>    This component specifies the language of the transmitted text.  At    times and in specific cases, language information may be required to    achieve a particular level of quality for the purpose of displaying a    text stream.  For example, UTF-8 encoded Han may require transmission    of a language tag to select the specific glyphs to be displayed at a    particular level of quality. </t> <t>    Note that information other than language may be used to achieve the    required level of quality in a display process.  In particular, a    font tag is sufficient to produce identical results.  However, the    association of a language with a specific block of text has    usefulness far beyond its use in display.  In particular, as the    amount of information available in multiple languages on the World    Wide Web grows, it becomes critical to specify which language is in    use in particular documents, to assist automatic indexing and    retrieval of relevant documents. </t> <t>    The term &apos;language tag&apos; should be reserved for the short identifier    of RFC 1766 [RFC-1766] that only serves to identify the language.    While there may be other text attributes intimately associated with    the language of the document, such as desired font or text direction,    these should be specified with other identifiers rather than    overloading the language tag. </t> </section> </section> </section> <!-- RFC original section: (3.2:) --> <section title=\"On the wire\"> <t>    There are three segments of the model which are required for    completely specifying the content of a transmitted text stream (with    the occasional exception of the Language component, mentioned above).    These components are: <list> <t>    1)  Coded Character Set, </t> <t>    2)  Character Encoding Scheme, and </t> <t>    3)  Transfer Encoding Syntax. </t></list> </t> <t>    Each of these abstract components must be explicitly specified by the    transmitter when the data is sent.  There may be instances of an    implicit specification due to the protocol/standard being used (i.e.    ANSI/NISO Z39.50).  Also, in MIME, the Coded Character Set and    Character Encoding Scheme are specified by the Charset parameter to    the Content-Type header field, and Transfer Encoding Syntax is    specified by the Content-Transfer-Encoding header field. </t> <!-- RFC original section: (3.2.1:) --> <section title=\"Coded Character Set\"> <t>    A Coded Character Set (CCS) is a mapping from a set of abstract    characters to a set of integers.  Examples of coded character sets    are ISO 10646 [ISO-10646], US-ASCII [ASCII], and ISO-8859 series    [ISO-8859]. </t> </section> <!-- RFC original section: (3.2.2:) --> <section title=\"Character Encoding Scheme\"> <t>    A Character Encoding Scheme (CES) is a mapping from a Coded Character    Set or several coded character sets to a set of octets. Examples of    Character Encoding Schemes are ISO 2022 [ISO-2022] and UTF-8 [UTF-8].    A given CES is typically associated with a single CCS; for example,    UTF-8 applies only to ISO 10646. </t> </section> <!-- RFC original section: (3.2.3:) --> <section title=\"Transfer Encoding Syntax\"> <t>    It is frequently necessary to transform encoded text into a format    which is transmissible by specific protocols.  The Transfer Encoding    Syntax (TES) is a transformation applied to character data encoded    using a CCS and possibly a CES to allow it to be transmitted.    Examples of Transfer Encoding Syntaxes are Base64 Encoding [Base64],    gzip encoding, and so forth. </t> </section> </section> <!-- RFC original section: (3.3:) --> <section title=\"Determining which values of CCS, CES, and TES are used\"> <t>    To completely specify which CCS, CES, and TES are used in a specific    text transmission, there needs to be a consistent set of labels for    specifying which CCS, CES, and TES are used.  Once the appropriate    mechanisms have been selected, there are six techniques for attaching    these labels to the data. </t> <t>    The labels themselves are named and registered, either with IANA    [IANA] or with some other registry.  Ideally, their definitions are    retrievable from some registration authority. </t> <t>    Labels may be determined in one of the following ways: <list> <t>    -  Determined by guessing, where the receiver of the text has to       guess the values of the CCS, CES, and TES. For example: &quot;I got       this from Sweden so it&apos;s probably  ISO-8859-1.&quot;  This is       obviously not a very foolproof way to decode text. </t> <t>    -  Determined by the standard, where the protocol used to transmit       the data has made documented choices of CCS, CES, and TES in the       standard. Thus, the encodings used are known through the       access protocol, for example HTTP [HTTP] uses (but is not       limited to) ISO-8859-1, SMTP uses US-ASCII. </t> <t>    -  Attached to the transfer envelope, where the descriptive labels are       attached to the wrapper placed around the text for transport.       MIME headers are a good example of this technique. </t> <t>    -  Included in the data stream, where the data stream itself has       been encoded in such a way as to signal the character set used.       For example, ISO-2022 encodes the data with escape sequences to       provide information on the character subset currently being used. </t> <t>    -  Agreed by prior bilateral agreement, where some out-of-band       negotiation has allowed the text transmitter and receiver to       determine the CCS, CES, and  TES for the transmitted text. </t> <t>    -  Agreed to by negotiation during some phase, typically       initialization of the protocol. </t></list> </t> <!-- RFC original section: (3.3.1:) --> <section title=\"Recommendations for value specification mechanisms\"> <t>    While each of these techniques (with the  exception of guessing) is    useful in particular situations, interoperability requires a more    consistent set of techniques.  Thus, we recommend that MIME    registered values be used for all tagging of character sets and    languages UNLESS there is an existing mechanism for determining the    required information using one of the other techniques (except    guessing).  This recommendation will require a fair bit of work on    the part of protocol designers, implementors, the IETF, the IESG, and    the IAB. </t> <t>    However, it is important to point out that the MIME concept of    &apos;charset&apos; in some cases cuts across several layers of components in    our model.  While this can be accepted in existing registrations, we    also recommend that the MIME registration procedure for character    sets be modified to show how a proposed character set deals with the    CCS and the CES. Most &apos;charsets&apos; have a well defined CCS and CES,    they should merely be teased apart for the registration. </t> <t>    There are a number of other recommendations, but these will be    covered in the next sections. </t> </section> </section> <!-- RFC original section: (3.4:) --> <section title=\"Recommended Defaults\"> <t>    For a number of reasons, one cannot define a mandatory set of    defaults for all Internet protocols.  There is a mass of current    practice, future protocols are likely to have different purposes,    which may determine their handling of text, and protocols may need    specific variation support.  For example, in mail, text is a    predominant data type and coded character sets then become a major    issue for the protocol.  Also, since e-mail is ubiquitous and users    expect to be able to send it to everyone, the mail protocols need to    be quite adept at handling different character set encodings.  On the    other hand, if strings are seldom used in a given protocol, there is    no need to weigh the protocol down with a sophisticated apparatus for    handling multiple character sets, assuming that the predicated    character set can handle all the protocol&apos;s needs. This observation    also applies to the specification techniques for character set    parameters.  If only one character set encoding is needed, it can be    made explicit in the protocol specification.  Protocols with a    greater need for character set support will need a more elaborate    specification technique. </t> <!-- RFC original section: (3.4.1:) --> <section title=\"Clarity of specification\"> <t>    We recommend that each protocol clearly specify what it is using for    each of the layers of the transmission model.  Users (or clients)    should never have to guess what the parameter is for a given layer. </t> </section> <!-- RFC original section: (3.4.2:) --> <section title=\"Default Coded Character Set:\"> <t>    The default Coded Character Set is the repertoire of ISO-10646. </t> </section> <!-- RFC original section: (3.4.3:) --> <section title=\"Default Character Encoding Scheme\"> <t>    For text-oriented protocols, new protocols should use UTF-8, and    protocols that have a backwards compatibility requirement should use    the default of the existing protocol, e.g. US-ASCII for mail, and    ISO-8859-1 for HTTP.  The recommended specification scheme is the    MIME &quot;charset&quot; specification, using the IANA &quot;charset&quot;    specifications.  The MIME specifications will need to be clarified to    meet this model in the future. </t> <t>    For other protocols, the default should be UTF-8 as this initially    allows US-ASCII to be entered as-is, and enables the full repertoire    of ISO 10646. </t> <t>    Some protocols, such as those descended from SGML [SGML], have other    natural notations for characters outside their &quot;natural&quot; repertoire;    for instance, HTML [HTML] allows the use of &amp;#nnnn to refer to any    ISO 10646 character.  Note that this, like all other encodings that    depend on &quot;escape characters&quot;, redefines at least one character from    the base character set for use as an indicator of &quot;foreign&quot;    characters.  Use of this approach must be weighed very carefully. </t> </section> <!-- RFC original section: (3.4.4:) --> <section title=\"Default Transport Encoding Scheme\"> <t>    There is no recommended default for this level.  For plain text    oriented protocols, the bytestream transport format should be 8-bit    clean, possibly with normalization of end-of-line indicators.  Some    special cases could be made for protocols that are not 8-bit clean,    such as encoding it for transport over 7-bit connections.  For binary    the same recommendation holds as above.  The specification technique    should either be defined in the  protocol, if only one way is    permitted, or by use of MIME content-transfer-encoding (CTE)    techniques, using IANA registered values. </t> </section> <!-- RFC original section: (3.4.5:) --> <section title=\"Default Language\"> <t>    There is no recommended default for the language level.  For human    readable text, there should always be a way to specify the natural    language. The specification technique should be a MIME identifier    with IANA  registered values for languages.  If headers are used, the    header should be &apos;Content-Language&apos;. </t> </section> <!-- RFC original section: (3.4.6:) --> <section title=\"Default Locale\"> <t>    The default should be the POSIX locale.  The specification technique    should use the Cultural register of CEN ENV 12005 [CEN] for the    values.  If headers are used, the header should be &apos;Content-Locale&apos;. </t> </section> <!-- RFC original section: (3.4.7:) --> <section title=\"Default Culture\"> <t>    There is no recommended default for the Culture level.  The    specification  technique should be a MIME or MIME-like identifier    (e.g. Content-Culture) and should use the Cultural register of CEN    ENV 12005 for its values. </t> </section> <!-- RFC original section: (3.4.8:) --> <section title=\"Default Presentation\"> <t>    There is no recommended default for the Presentation level.  The    specification technique should be a MIME or MIME-like identifier    (e.g.  Content-Layout) and use the glyph register of ISO 10036 and    other registers for its values. </t> </section> <!-- RFC original section: (3.4.9:) --> <section title=\"Multiplexing\"> <t>    In some cases, text transmission may require the use of a number of    different values for a given parameter; for example, English    annotation of Japanese text might well require shifting the Content-    Language parameter.  The way to switch the value of parameters within    a single body of text depends on the application.  For instance, the    HTML I18N [I18N] work defines a language attribute on most of its    elements, including &lt;SPAN&gt;, &lt;HTML&gt;, and &lt;BODY&gt;, for the purpose of    switching between different languages.  When only one value is    needed, this value should be as general as possible, and specified in    the protocol standard with reference to the IANA or other registry    value.  All levels should be specified explicitly. </t> </section> <!-- RFC original section: (3.4.10:) --> <section title=\"Storage\"> <t>    Because stored text may very well be stored without any of the    additional information necessary for decoding, stored text SHOULD be    tagged in a MIME compliant fashion.  This alleviates the problem of    being unable to interpret text which has been stored for a long time,    or text whose provenance is not available. </t> </section> </section> <!-- RFC original section: (3.5:) --> <section title=\"Guidelines for conversions between coded character sets\"> <t>    This section covers various algorithms to convert a source text S,    encoded in the coded character set CCS(S), to a target text T,    encoded in the coded character set CCS(T). </t> <t>    Rep(X) is the character repertoire of coded character set X, i.e. the    set of characters which can be represented with X. </t> <!-- RFC original section: (3.5.1:) --> <section title=\"Exact conversion\"> <t>    When Rep(CCS(S)) and Rep(CCS(T)) are equal or Rep(CCS(S)) is a subset    of Rep(CCS(T)), exact conversion is possible; i.e. T is equal to S.    The octets just need to be remapped.  The algorithm for performing    this remapping is simple, if the IANA-registered definition tables    for CCS(S) and CCS(T) are available. </t> </section> <!-- RFC original section: (3.5.2:) --> <section title=\"Approximate conversion\"> <t>    In all other cases, any conversion creates a text T which differs    from S.  There are different principles for how this inevitable    difference should be handled.  A choice between them should be made,    depending on the purpose and requirements of the conversion.  Where    possible, the client application should be given mechanisms to    determine what has been done to the text. </t> <!-- 3.5.2.1 -->  <section title=\"Length-modifying conversion for human display\"> <t>    When the length of the target text T is allowed to differ from the    length of the source text S, one should use a conversion method in    which each source character is converted to one or several target    character(s), using a best resemblance criteria in the choice of that    target character(s). </t> <figure><artwork>    Examples:       LATIN CAPITAL LETTER [*] -&gt;  AE       COPYRIGHT SIGN       [*] -&gt; (c) </artwork></figure> </section> <!-- RFC original section: (3.5.2.2:) --> <section title=\"Length-preserving conversion for human display\"> <t>    Where the text T must be presented and the length of T cannot differ    from the length of S, one should use a conversion method where each    source character is converted to one target character, using some    kind of best  resemblance criteria in the choice of target character. </t> <figure><artwork>    Examples:      LATIN CAPITAL LETTER  [*] -&gt; A      COPYRIGHT SIGN        [*] -&gt; C </artwork></figure> </section> <!-- RFC original section: (3.5.2.3:) --> <section title=\"Conversion without data loss\"> <t>    Where the conversion of the text S into T must be completely    reversible, apply a Character Encoding Syntax or other reversible    transformation method.  This case is most frequently met in data    storage requirements. </t> <figure><artwork>    Examples:      LATIN CAPITAL LETTER [*] -&gt; &amp;AE      COPYRIGHT SIGN       [*] -&gt; &amp;(C </artwork></figure> <t>    An alternate method, which can be used if the size of Rep(CCS(T)) &gt;=    Rep(CCS(S)), then for each character in Rep(CCS(S)) which is not    present in Rep(CCS(T)), define a mapping into a character in    Rep(CCS(T)) which is not present in Rep(CCS(S)). </t> <figure><artwork>    Examples:      LATIN CAPITAL LETTER  [*] -&gt; CYRILLIC CAPITAL LETTER [*]      COPYRIGHT SIGN  [*] -&gt; PARTIAL DIFFERENTIAL SIGN [*] </artwork></figure> <t>    Note that conversion without data loss requires redefining some    member of T to indicate &quot;the introduction of character data outside    T&quot;.  This effectively adds another level of CES on top of CES(T). </t> </section> </section> </section> </section> <!-- RFC original section: (4:) --> <section title=\"Presentation issues\"> <t>    There are a number of considerations to make in selecting the base    character set.  One such consideration is the protocol&apos;s convenience    to users with limited equipment (for example only ISO 8859-1 or a    keyboard without the ability to enter all the characters in ISO    10646).  Alternative representation should be considered for these    users, both for input and output.  Possible options for the    representation of characters that can not be displayed include    transliteration (a la CEN/TC304 or ISO TC46/SC2 ), RFC 1345 [RFC-    1345] representative icons, or the WG2 short name (u+xxxx). </t> </section> <!-- RFC original section: (5:) --> <section title=\"Open issues\"> <t>    In addition to the issues declared out of scope and enumerated in    section 2.1, the following issues are still open and will need to be    addressed in other forums.  These issues: language tags, public    identifiers such as URL names, and bi-directionality are briefly    discussed below as they repeatedly encroached the discussion. </t> <!-- RFC original section: (5.1:) --> <section title=\"Language tags\"> <t>    Although the workshop decided not to explicitly address the so-called    &quot;CJK issue&quot;, a few members felt it was necessary to have some    mechanism to address the problem of correct Han character display in    the ISO-10646 issue, and that saying that it was a &quot;font issue&quot; would    not suffice. </t> <t>    The &quot;CJK issue&quot; refers to the extended discussion about &quot;Han    unification&quot;, the use of a single ISO-10646 codepoint to represent    multiple national variants of a Chinese (Han) character.  ISO-10646    can map uniquely to any single CJK national character set, but in the    absence of additional  information an application can not display an    ISO-10646 text using the proper national variants for that text. </t> <t>    It was agreed that language tags would be sufficient to disambiguate    unified characters. There was not, in our opinion, a significant    technical difference between the use of different coded character    sets with overlapping codepoints, and a single coded character set    with language tags.  Either way, the application has sufficient    information to display the text properly. </t> <t>    It was observed that in contemporary usage of MIME charsets, the    language is implied as well as the coded character set and the    character encoding syntax.  We agreed that this is excessive    overloading of MIME charsets. </t> <t>    To specify the language used in a particular block of text, we    recommend that the MIME tag &quot;Content-Language&quot; be used.  There are a    number of questions about this approach that need to be worked out,    however: <list> <t>    -  Is Content-Language: actually suitable? </t> <t>    -  Is there an overload between this function and the other         intended functions of Content-Language: as described in RFC         1766? </t> <t>    -  What, precisely, does &quot;Content-Language: zh-tw, ja, ko, zh-cn&quot;         mean in this context? We believe it means that, in drawing a         Han character, the Taiwanese variant (presumably traditional         Han) is preferred, followed by the Japanese, Korean, and         mainland Chinese (presumably simplified Han) variants. It does         *NOT* mean &quot;mixed text containing Taiwanese, Japanese, Korean,         and mainland Chinese text with all the national variants in         each of these&quot;. </t></list> </t> <t>    Mixed CJK text, that simultaneously displays different variants    occupying the same codepoint, requires language tags embedded in the    data.  Ohta and Handa propose in RFC 1554 [RFC-1554] a MIME charset    using ISO-2022 shifts between multiple coded character sets; in    effect this is an encoding that uses coded character sets for    displaying the appropriate glyphs. </t> <t>    There is some speculation that states that mixed CJK text is    relatively infrequent, and that therefore it is acceptable to require    that such text be represented using a rich text format that can    support language tags.  In other words, that a simplifying assumption    can be made for TEXT/PLAIN in  email using ISO-10646 that will not    require multiple display representations for the same codepoint.  A    mechanism such as RFC 1554 could address this need if it was    important; although arguably RFC 1554 should really be identified as    TEXT/ISO-2022. </t> <t>    Note again that we recommend that support for language tagging SHOULD    be built into new protocols, as this will become a critical component    of the automated indexing and retrieval in information applications    of the future. </t> </section> <!-- RFC original section: (5.2:) --> <section title=\"Public identifiers\"> <t>    There is a considerable demand from the user community for the    ability to use non-ASCII characters in URL names, IMAP mailbox names,    file names, and other public identifiers. This is still an open    problem. </t> </section> <!-- RFC original section: (5.3:) --> <section title=\"Bi-directionality\"> <t>    It was realized that a consistent framework for bi-directional text    was needed but there was no attempt to work on it in this workshop. </t> </section> </section> <!-- RFC original section: (6:) --> <section title=\"Security Considerations\"> <t>    There are no security considerations associated with character sets. </t> </section> <!-- RFC original section: (7:) --> <section title=\"Conclusions\"> <t>    This paper provides a conceptual framework and a set of    recommendations which, if adopted, should provide a solid foundation    for interoperability on the Internet. There are, however, a number of    open issues which will need to be addressed to provide ever better    use of text on the Internet. </t> </section> <!-- RFC original section: (8:) --> <section title=\"Recommendations\"> <t> </t> <!-- RFC original section: (8.1:) --> <section title=\"To the IAB\"> <t>    There were a number of recommendations to the IAB about making the    standards process more aware of the need for character set    interoperability, and about the framework itself. <list> <t>    A: The IAB should trigger the examination of all RFCs to determine    the way  they handle character sets, and obsolete or annotate the    RFCs where necessary. </t> <t>    B: The IESG should trigger the recommendation of procedures to the    RFC editor  to encourage RFCs to specify character set handling if    they specify the  transmission of text. </t> <t>    C: The IAB should trigger the production of a perspectives document    on the  character set work that has gone on in the past and relate it    to the current framework. </t> <t>    D: Full ISO 10646 has a sufficiently broad repertoire, and scope for    further extension, that it is sufficient for use in Internet    Protocols (without excluding the use of existing alternatives).    There is no need for specific development of character set standards    for the Internet. </t> <t>    E: The IAB should encourage the IRTF to create a research group to    explore the open issues of character sets on the Internet. This group    should set its sights much higher than this workshop did. </t> <t>    F: The IANA (perhaps with the help of an IETF or IRTF group) should    develop  procedures for the registration of new character sets for    use in the Internet. </t> <t>    G: Register UTF-8 as a Character Encoding Scheme for MIME. </t> <t>    H: The current use of the &quot;x-*&quot; format for distinguishing    experimental tags should be continued for private use among    consenting parties. All other namespaces should be allocated by IANA. </t> <t>    I: Application protocol RFCs SHOULD include a section on    &quot;multilingual Considerations&quot;. </t> <t>    J: Application Protocol RFCs SHOULD indicate how to transfer &apos;on the    wire&apos; all characters in the character sets they use. They SHOULD also    specify how to transfer other information that applications may need    to know about the data. </t> <t>    K: The IESG should trigger a set of extensions to RFC 1522 to allow    language tagging of the free text parts of message headers. </t></list> </t> </section> <!-- RFC original section: (8.2:) --> <section title=\"For new Internet protocols\"> <t>    New protocols do not suffer from the need to be compatible with old    7-bit pipes.  New protocol specifications SHOULD use ISO 10646 as the    base charset unless there is an overriding need to use a different    base character set. </t> <t>    New protocols SHOULD use values from the IANA registries when    referring to parameter values.  The way these values are carried in    the protocols is protocol dependent; if the protocol uses RFC-822-    like headers, the header names already in use SHOULD be used. </t> <t>    For protocols with only a single choice for each component, the    protocol  should use the most general specification and should be    specified with reference to the registered value in the protocol    standard. </t> <t>    Protocols SHOULD tag text streams with the language of the text. </t> </section> <!-- RFC original section: (8.3:) --> <section title=\"For the registration of new character sets\"> <t>    Ned Freed will be releasing a new MIME registration document in    conjunction with this paper. </t> <!-- RFC original section: (8.3.1:) --> <section title=\"A definition table for a coded character set\"> <t>    A definition table for a coded character set A must for each    character C that is in the repertoire of A give: <list> <t>    a) if C is present in ISO 10646, the code value (in hexadecimal form)         for that character. </t> <t>    b) If C is not present in ISO 10646, but may be constructed using ISO         10646 combining characters, the series of code values (in         hexadecimal form) used to construct that character. </t> <t>    c) if C is not present in ISO 10646, a textual description of the         character,  and a reference to its origin. </t></list> </t> </section> <!-- RFC original section: (8.3.2:) --> <section title=\"A definition of a character encoding scheme\"> <t>    A definition of a character encoding scheme consists of: <list> <t>    -  A description of an algorithm which transforms every possible         sequence of octets to either a sequence of pairs &lt;CCS, code         value&gt; or to the  error state &quot;illegal octet sequence&quot; </t> <t>    -  Specifications, either by reference to CCS&apos;s registered by IANA or       in text, of each CCS upon which this CES is based. </t></list> </t> </section> </section> </section> </middle> <back> <!-- RFC original section: (Appendix A:) --> <section title=\"\"> <t> </t> <!-- RFC original section: (A-1:) --> <section title=\"IETF Protocols\"> <t>    The following list describes how various existing protocols handle    multiple character set information. <list> <t>    Email <list> <t>       SMTP <list> <t>         See 8.2. ESMTP makes it easy to negotiate the use of alternate         language and encoding if it is needed. </t></list> </t> <t>       Headers <list> <t>         RFC 1522 forms an adequate framework for supporting text; UTF-8         alone is not a possible solution, because the mail pathways are         assumed to be 7-bit &apos;forever&apos;. However, RFC 1522 should be         extended to allow language tagging of the free text parts of         message headers. </t></list> </t> <t>       Bodies <list> <t>         Selection of charset parameters for Email text bodies is         reasonably well covered by the charset= parameter on Text/* MIME         types.  Language is defined by the Content-language header of         RFC 1766.  Other information will have to be added using body         part headers; due to the way MIME differentiates between body         part headers and message headers, these will all have to have         names starting with Content- . </t></list> </t></list> </t> <t>    NetNews <list> <t>       NNTP <list> <t>         See 8.2. No strong tradition for negotiation of encoding in NNTP         exists. </t></list> </t> <t>       NetNews Messages <list> <t>         These should be able to leverage off the mechanisms defined for         Email.  One difference is that nearly all NNTP channels are 8-         bit clean; some NNTP newsgroups have a tradition of using 8-bit         charsets in both headers and bodies. Defining character set         default on a per newsgroup basis might be a suitable approach. </t></list> </t></list> </t> <t>    RTCP <list> <t>         The identifiers carried as information about parties are already         defined to be in UTF-8. </t></list> </t> <t>    FTP <list> <t>       Protocol <list> <t>         See 8.2. The common use of welcome banners in the login response         means that there might be strong reason here to allow client and         server to negotiate a language different from the default for         greetings and error messages. This should be a simple protocol         extension. </t></list> </t> <t>       Filenames <list> <t>         Many fileservers now how have the capability of using non-ASCII         characters in filenames, while the &quot;dir&quot; and &quot;get&quot; commands of         are defined in terms of US-ASCII only. One possible solution         would be to define a &quot;UTF-8&quot; mode for the transfer of filenames         and directory information; this would need to be a negotiated         facility, with fallback to US-ASCII if not negotiated. The         important point here is consistency between all implementations;         a single charset is better here than the ability to handle         multiple charsets. </t></list> </t></list> </t> <t>    World Wide Web <list> <t>       HTTP <list> <t>         See 8.2. The single-shot stype of HTTP makes negotiation more         complex than it would otherwise be. </t></list> </t> <t>       HTML <list> <t>         Internationalization of HTML [I18N] seems fairly well covered in         the current &quot;I18N&quot; document. It needs review to see if it needs         more specific details in order to carry application information         apart from the language. </t></list> </t></list> </t> <t>    URLs <list> <t>         URLs are &quot;input identifiers&quot;, and powerful arguments should be         made if they are ever to be anything but US-ASCII. </t></list> </t> <t>    IMAP <list> <t>         IMAP&apos;s information objects are MIME Email objects, and therefore         are able to use that standard&apos;s methods. However, IMAP folder         names are local identifiers; there is strong reason to allow         non-ASCII characters in these. A UTF-8 negotiation might be the         most appropriate thing, however, UTF-8 is awkward to use.         Unfortunately, UTF-7 isn&apos;t suitable because it conflicts with         popular hierarchy delimiters. The most recent IMAP work in         progress specification describes a modified UTF-7 which avoids         this problem. </t></list> </t> <t>    DNS <list> <t>         DNS names are the prime example of identifiers that need to stay         in US-ASCII for global interoperability. However, some DNS         information, in particular TXT records, may represent         information (such as names) that is outside the ASCII range. A         single solution is the best; problems resulting from UTF-8         should be investigated. </t></list> </t> <t>    WHOIS++ <list> <t>         WHOIS++ version 1 is defined to use ISO 8859-1. The next version         will use UTF-8. The currently designed changes will also allow         the specification of individual attributes on attribute names;         these will make the passing of application information about the         values (such as language) easier. No immediate action seems         necessary. </t></list> </t> <t>    WHOIS <list> <t>         This has been a stable protocol for so many years now that it         seems unwise to suggest that it be modified. Furthermore,         compatible extensions exist in RWHOIS and WHOIS++; modification         should rather be made to these protocols than to the WHOIS         protocol itself. </t></list> </t> <t>    Telnet <list> <t>         This is a prime example of protocol where character set support         is necessary and nonexistent. The current work in progress on         character set negotiation in Telnet seems adequate to the task;         the question of passing other application data that might be         useful is still open. </t></list> </t></list> </t> </section> <!-- RFC original section: (A-2:) --> <section title=\"Non-IETF protocols\"> <t>    For these protocols, the IETF does not have any power to change them.    However, the guidelines developed by the workshop may still be useful    as input to the further development of the protocols. <list> <t>    Gopher: Gopher, Gopher+ </t> <t>    Prospero (Archie) </t> <t>    NFS:  Filesystem </t> <t>    CORBA, Finger, GEDI, IRC, ISO 10160/1, Kerberos, LPR, RSTAT, RWhois,    SGML, TFTP, X11, X.500, Z39.50 </t></list> </t> </section> </section> <!-- RFC original section: (Appendix B:) --> <section title=\"Acronyms\"> <figure><artwork>    ASCII       American National Standard Code for Information Character                  Sets    CCS         Coded Character Sets    CEN ENV     European Committee for Standardisation (CEN) European                  pre-standard (ENV)    CES         Character Encoding Scheme    CJK         Chinese Japanese Korean    CORBA       Common Object Request Broker Architecture    CTE         Content Transfer Encoding    DNS         Domain Name Service    ESMTP       Extended SMTP    FTP         File Transfer Protocol    HTML        Hypertext Transfer Protocol    I18N        Internationalization (or 18 characters between the first                  (I) and last (n)character)    IAB         Internet Activities Board    IANA        Internet Assigned Numbers Authority    IESG        Internet Engineering Steering Group    IETF        Internet Engineering Task Force    IMAP        Internet Message Access Protocol    IRC         Internet Relay Chat    IRTF        Internet Research Task Force    ISI         Information Sciences Institute    ISO         International Standards Organization    MIME        Multipurpose Internet Mail Extensions    NFS         Networked File Server    NNTP        Net News Transfer Protocol    POSIX       Portable Operating System Interface    RFC         Request for Comments (Internet standards documents)    RPC         Remote Procedure Call    RSTAT       Remote Statistics    RTCP        Real-Time Transport Control Protocol    Rwhois      Referral Whois    SGML        Standard Generalized Mark-up Language    SMTP        Simple Mail Transfer Protocol    TES         Transfer Encoding Syntax    TFTP        Trivial File Transfer Protocol    URL         Uniform Resource Locator    UTF         Universal Text/Translation Format </artwork></figure> </section> <!-- RFC original section: (Appendix C:) --> <section title=\"Glossary\"> <t>    Bi-directionality -  A property of some text where text written right-          to- left (Arabic or Hebrew) and text written left-to-right          (e.g. Latin) are intermixed in one and the same line. </t> <t>    Character - A single graphic symbol represented by sequence of one or         more bytes. </t> <t>    Character Encoding Scheme - The mapping from a coded character set to         an encoding which may be more suitable for specific purpose. For         example, UTF-8 is a character encoding scheme for ISO 10646. </t> <t>    Character Set - An enumerated group of symbols (e.g., letters, numbers         or glyphs) </t> <t>    Coded Character Set - The mapping from a set of integers to the         characters of a character set. </t> <t>    Culture - Preferences in the display of text based on cultural norms,         such as spelling and word choice. </t> <t>    Language - The words and combinations of words the constitute a system         of expression and communication among people with a shared         history or set of traditions. </t> <t>    Layout - Information needed to display text to the user, similar to         the presentation layer in the ISO telecommunications model. </t> <t>    Locale - The attributes of communication, such as language, character         set and cultural conventions. </t> <t>    On-the-wire -  The data that actually gets put into packets for         transmission to other computers. </t> <t>    Transfer Encoding Syntax -  The mapping from a coded character set         which has been encoded in a Character Encoding Scheme to an         encoding which may be more suitable for transmission using         specific protocols. For example, Base64 is a transfer encoding         syntax. </t> </section> <!-- RFC original section: (Appendix D:) --> <section title=\"References\"> <t> [*]  Non-ASCII character </t> <t> [ASCII]  ANSI X3.4:1986  &quot;Coded  Character Sets - 7 Bit American      National Standard Code for Information Interchange (7-bit ASCII)&quot; </t> <t> [Base64]  Freed, N., and N. Borenstein, &quot;Multipurpose Internet      Mail Extensions (MIME) Part One: Format of Internet Message      Bodies&quot;, RFC 2045, November 1996. </t> <t> [CEN]  see http://tobbi.iti.is/TC304/welcome.html for current status. </t> <t> [HTML]  Berners-Lee, T., and D. Connolly, &quot;Hypertext Markup Language -      2.0&quot;, RFC 1866, November 1995. </t> <t> [HTTP]  Berners-Lee, T., Fielding, R., and H. Nielsen, &quot;Hypertext      Transfer Protocol -- HTTP/1.0&quot;, RFC 1945, May 1996. </t> <t> [I18N]  Yergeau, F., et.al.,  &quot;Internationalization of the Hypertext      Markup Language&quot;, RFC 2070, January 1997. </t> <t> [IANA] Reynolds, J., and J. Postel, &quot;Assigned Numbers&quot;, STD 2, RFC      1700, ISI, October 1994. </t> <t> [ISO-2022]  ISO/IEC 2022:1994,  &quot;Information technology -- Character      Code Structure and Extension Techniques&quot;,  JTC1/SC2. </t> <t> [ISO-7498]  ISO/IEC 7498-1:1994,  &quot;Information technology - Open Systems      Interconnection - Basic Reference Model:  The Basic Model&quot;. </t> <t> [ISO-8859]  Information Processing -- 8-bit Single-Byte Coded Graphic      Character Sets -- Part 1: Latin Alphabet no. 1,      ISO 8859-1:1987(E). Part 2: Latin Alphabet no. 2, ISO 8859-2      1987(E). Part 3: Latin Alphabet no. 3, ISO 8859-3:1988(E).      Part 4: Latin Alphabet no. 4, ISO 8859-4, 1988(E). Part 5:      Latin/Cyrillic Alphabet ISO 8859-5, 1988(E). Part 6:      Latin/Arabic Alphabet, ISO 8859-6, 1987(E). Part 7: Latin/Greek      Alphabet, ISO 8859-7, 1987(E). Part 8: Latin/Hebrew Alphabet, ISO      8859-8-1988(E).Part 9: Latin Alphabet no. 5, ISO 8859-9, 1990(E).      Part 10: Latin Alphabet no. 6, ISO 8859-10:1992(E). </t> <t> [ISO-10646]  ISO/IEC 10646-1:1993(E ),  &quot;Information technology --      Universal Multiple-Octet Coded Character Set (UCS) -- Part 1:      Architecture and Basic Multilingual Plane&quot;.  JTC1/SC2, 1993 </t> <t> [MIME]  See [Base64] </t> <t> [POSIX]  Institute of Electrical and Electronics Engineers.  &quot;IEEE      standard interpretations for IEEE standard portable operating      systems interface for computer environments&quot;. IEEE Std 1003.1      -1988/Int, 1992 edition.  Sponsor, Technical Committee on Operating      Systems of the IEEE Computer Society.  New York, NY: Institute of      Electrical and Electronic Engineers, 1992. </t> </section> <!-- RFC original section: (Appendix E:) --> <section title=\"Recommended reading\"> <t> </t> </section> <!-- RFC original section: (Appendix F:) --> <section title=\"Workshop attendee list\"> <t>    These people were participants on the workshop mailing list.    An * indicates that the person attended the workshop in person. </t> <figure><artwork>      Glenn Adams &lt;glenn@spyglass.com&gt;    * Joan Aliprand &lt;joan@unicode.org&gt;    * Harald Alvestrand &lt;Harald.T.Alvestrand@uninett.no&gt;    * Ran Atkinson &lt;ran@cisco.com&gt;    * Bert Bos &lt;bert@w3.org&gt;    * Brian Carpenter &lt;brian@dxcoms.cern.ch&gt;    * Mark Crispin &lt;mrc@panda.com&gt;      Makx Dekkers &lt;dekkers@pica.nl&gt;      Robert Elz &lt;kre@munnari.oz.au&gt;      Patrik Faltstrom &lt;paf@paf.se&gt;    * Zhu Haifeng &lt;zhf@net.tsinghua.edu.cn&gt;      Keniichi Handa&lt;handa@etl.go.jp&gt;      Olle Jarnefors &lt;ojarnef@admin.kth.se&gt;      Borka Jerman-Blazic &lt;borka@e5.ijs.si&gt;      John Klensin &lt;klensin@mail1.reston.mci.net&gt;    * Larry Masinter &lt;masinter@parc.xerox.com&gt;    * Rick McGowan &lt;Rick_McGowan@next.com&gt;    * Keith Moore &lt;moore+charsets@cs.utk.edu&gt;    * Lisa Moore &lt;lisam@vnet.ibm.com&gt;      Ruth Moulton &lt;ruth@muswell.demon.co.uk&gt;    * Cecilia Preston &lt;cecilia@well.com&gt;    * Joyce K. Reynolds &lt;jkrey@isi.edu&gt;    * Keld Simonsen &lt;keld@dkuug.dk&gt;    * Gary Smith &lt;Gary_Smith@oclc.org&gt;    * Peter Svanberg &lt;psv@nada.kth.se&gt;    * Chris Weider &lt;cweider@microsoft.com &gt; </artwork></figure> </section> </back> </rfc> ", 
    "identity": {
        "subtype": "", 
        "is_error": false, 
        "version": "", 
        "protocol": "", 
        "language": "", 
        "service": "", 
        "has_dataset": false, 
        "has_metadata": false
    }, 
    "digest": "3933b1ee9e65d57c5f69e41f9331a0c7", 
    "source_url": "http://xml2rfc.tools.ietf.org/public/rfc/xml/rfc2130.xml"
}