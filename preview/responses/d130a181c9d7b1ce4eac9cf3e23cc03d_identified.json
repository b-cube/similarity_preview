{
    "content": "<?xml version='1.0' encoding='ISO-8859-1'?>  <!DOCTYPE uridef[   <!ENTITY rdf \"http://www.w3.org/1999/02/22-rdf-syntax-ns\">   <!ENTITY rdfs \"http://www.w3.org/2000/01/rdf-schema\">   <!ENTITY owl \"http://www.w3.org/2002/07/owl\">   <!ENTITY xsd \"http://www.w3.org/2001/XMLSchema\">   <!ENTITY time \"http://www.ai.sri.com/daml/ontologies/time/Time.owl\">   <!ENTITY service \"http://www.daml.org/services/owl-s/0.9/Service.owl\">   <!ENTITY grounding \"http://www.daml.org/services/owl-s/0.9/Grounding.owl\">   <!ENTITY process \"http://www.daml.org/services/owl-s/0.9/Process.owl\">   <!ENTITY DEFAULT \"http://www.daml.org/services/owl-s/0.9/Process.owl\"> ]>  <!-- This document uses entity types as a shorthand for URIs. For a version with unexpanded entities, try loading this source into Internet Explorer.   -->  <rdf:RDF   xmlns:rdf= \"&rdf;#\"   xmlns:rdfs= \"&rdfs;#\"   xmlns:owl = \"&owl;#\"   xmlns:xsd=  \"&xsd;#\"   xmlns:service= \"&service;#\"   xmlns:process= \"&process;#\"   xmlns:grounding= \"&process;#\"   xmlns= \"&DEFAULT;#\">   <owl:Ontology rdf:about=\"\">   <owl:versionInfo>     $Id: Process.owl,v 1.32 2003/09/19 05:06:47 martin Exp $   </owl:versionInfo>   <rdfs:comment>     Upper-level DAML ontology for Processes.     Part of the DAML-S effort; see http://www.daml.org/services/.   </rdfs:comment>   <owl:imports rdf:resource=\"http://www.w3.org/2002/07/owl\"/>   <owl:imports rdf:resource=\"http://www.ai.sri.com/daml/ontologies/time/Time.owl\"/>   <owl:imports rdf:resource=\"http://www.daml.org/services/owl-s/0.9/Service.owl\"/> </owl:Ontology>  <!--######################################################     Preliminaries     ######################################################-->  <rdf:Property rdf:ID=\"sameValuesAs\">   <rdfs:comment>     -- 0.7: This is deprecated, in favor of sameValues, defined further below.     -- The remaining comments are retained from the 0.6 release:     This is a \"place-holder\" for now, which needs further work.     The domain and range will be properties.     \"X sameValuesAs Y\" is used to indicate that properties X and Y take     the same values within a given context; that is, within an execution     instance of some process.  This is used simply to indicate such things     as the binding of output property X of a subprocess with input property     Y of a subsequent subprocess, within the same parent process.   </rdfs:comment> </rdf:Property>  <rdf:Property rdf:ID=\"listOfInstancesOf\">   <rdfs:domain rdf:resource=\"&owl;#Class\"/>   <rdfs:range rdf:resource=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#List\"/>   <rdfs:comment>     The range is a list of classes.      This property is defined similarly to DAML+OIL properties having List     as range, such as owl:oneOf and owl:intersectionOf, and is meant     to be used similarly, with parseType=collection.      \"Class listOfInstancesOf X Y Z\" (for example) is used to indicate the class     of lists having an instance of class X as their first member, an instance      of class Y as their second member, and an instance of class Z as their     third member.      An instance of listOfInstancesOf represents an anonymous class, as      explained here:       http://www.daml.org/services/owl-s/0.9/listOfInstancesOf.html.      Note that listOfInstancesOf is provided as \"syntactic sugar\"; that is,      it isn't required to express the intended anonymous class definition.       It is provided to allow for shorter, more readable expressions in process      definitions.      There are some unresolved concerns about the use of this     property, which are also explained in the HTML document.   </rdfs:comment> </rdf:Property>  <owl:Class rdf:ID=\"Condition\">   <rdfs:comment>     This is a \"place-holder\" for now, which awaits further work from     the DAML/OIL community.  An instance of Condition is a logical     formula that evaluates to true or false.  Eventually we expect     this to be defined elsewhere, as part of a DAML+OIL extension allowing     for logical expressions.   </rdfs:comment> </owl:Class>  <!--   A conditional effect is an effect that only occurs when a condition is true.  In the buy-book example ceCondition would be something like \"inStock(book)\" and the ceEffect would be something like \"purchased(book)\".  It is encoded by the class ConditionalEffect. ConditionalEffect simply bundles a condition and an effect, using two properties, the condtion (ceCondition) of the conditional effect, and the effect (ceEffect) of the conditional effect.    An *un*conditional effect is simply a subclass of a conditional effect, where the condition is just the value true.   -->  <owl:Class rdf:ID=\"ConditionalEffect\">   <owl:subClassOf rdf:resource=\"&owl;#Thing\"/> </owl:Class>   <rdf:Property rdf:ID=\"ceCondition\">  <rdfs:comment> The condition of a conditional effect. </rdfs:comment>   <rdfs:domain rdf:resource=\"#ConditionalEffect\"/>   <rdfs:range rdf:resource=\"#Condition\"/> </rdf:Property>  <rdf:Property rdf:ID=\"ceEffect\">   <rdfs:domain rdf:resource=\"#ConditionalEffect\"/>   <rdfs:range rdf:resource=\"&owl;#Thing\"/> </rdf:Property>  <owl:Class rdf:ID=\"UnConditionalEffect\">   <rdfs:comment>     An UnConditionalEffect has no condition.   </rdfs:comment>   <owl:intersectionOf rdf:parseType=\"Collection\">     <owl:Class rdf:about=\"#ConditionalEffect\"/>     <owl:Restriction owl:cardinality=\"0\">       <owl:onProperty rdf:resource=\"#ceCondition\"/>     </owl:Restriction>   </owl:intersectionOf> </owl:Class>   <!--   Similarly to ConditionalEffect, ConditionalOutput bundles a condition and an ouput thing.   -->  <owl:Class rdf:ID=\"ConditionalOutput\">   <owl:subClassOf rdf:resource=\"&owl;#Thing\"/> </owl:Class>  <rdf:Property rdf:ID=\"coCondition\">  <rdfs:comment> The condition of a conditional output </rdfs:comment>   <rdfs:domain rdf:resource=\"#ConditionalOutput\"/>   <rdfs:range rdf:resource=\"#Condition\"/> </rdf:Property>  <rdf:Property rdf:ID=\"coOutput\">   <rdfs:domain rdf:resource=\"#ConditionalOutput\"/>   <rdfs:range rdf:resource=\"&owl;#Thing\"/> </rdf:Property>   <owl:Class rdf:ID=\"UnConditionalOutput\">   <rdfs:comment>     An UnConditionalOutput has no condition.   </rdfs:comment>   <owl:intersectionOf rdf:parseType=\"Collection\">     <owl:Class rdf:about=\"#ConditionalOutput\"/>     <owl:Restriction owl:cardinality=\"0\">       <owl:onProperty rdf:resource=\"#coCondition\"/>     </owl:Restriction>   </owl:intersectionOf> </owl:Class>   <!-- Power Sets -->  <owl:Class rdf:ID=\"ProcessPowerSet\">   <rdfs:comment>     This is the power set of Process (defined below); that is, the set     of all subsets of Process.  This class is needed as the range     of certain properties.     </rdfs:comment>   <owl:sameClassAs>     <owl:Restriction>       <owl:onProperty rdf:resource=\"&rdfs;#subClassOf\"/>       <owl:hasValue rdf:resource=\"#Process\"/>     </owl:Restriction>   </owl:sameClassAs> </owl:Class>  <owl:Class rdf:ID=\"AtomicProcessPowerSet\">   <rdfs:comment>     This is the power set of AtomicProcess (defined below); that is, the set     of all subsets of AtomicProcess.  This class is needed as the range     of certain properties.    </rdfs:comment>   <owl:sameClassAs>     <owl:Restriction>       <owl:onProperty rdf:resource=\"&rdfs;#subClassOf\"/>       <owl:hasValue rdf:resource=\"#AtomicProcess\"/>     </owl:Restriction>   </owl:sameClassAs> </owl:Class>  <owl:Class rdf:ID=\"ParameterPowerSet\">   <rdfs:comment>     This is the power set of parameter (defined below);     that is, the set of all subproperties of parameter.       This class is needed as the range of certain properties.    </rdfs:comment>   <owl:sameClassAs>     <owl:Restriction>       <owl:onProperty rdf:resource=\"&rdfs;#subPropertyOf\"/>       <owl:hasValue rdf:resource=\"#parameter\"/>     </owl:Restriction>   </owl:sameClassAs> </owl:Class>  <owl:Class rdf:ID=\"InputPowerSet\">   <rdfs:comment>     This is the power set of input (defined below);     that is, the set of all subproperties of input.       This class is needed as the range of certain properties.    </rdfs:comment>   <owl:sameClassAs>     <owl:Restriction>       <owl:onProperty rdf:resource=\"&rdfs;#subPropertyOf\"/>       <owl:hasValue rdf:resource=\"#input\"/>     </owl:Restriction>   </owl:sameClassAs> </owl:Class>  <owl:Class rdf:ID=\"OutputPowerSet\">   <rdfs:comment>     This is the power set of output (defined below);     that is, the set of all subproperties of output.       This class is needed as the range of certain properties.    </rdfs:comment>   <owl:sameClassAs>     <owl:Restriction>       <owl:onProperty rdf:resource=\"&rdfs;#subPropertyOf\"/>       <owl:hasValue rdf:resource=\"#output\"/>     </owl:Restriction>   </owl:sameClassAs> </owl:Class>  <owl:Class rdf:ID=\"PreconditionPowerSet\">   <rdfs:comment>     This is the power set of precondition (defined below);     that is, the set of all subproperties of precondition.       This class is needed as the range of certain properties.    </rdfs:comment>   <owl:sameClassAs>     <owl:Restriction>       <owl:onProperty rdf:resource=\"&rdfs;#subPropertyOf\"/>       <owl:hasValue rdf:resource=\"#precondition\"/>     </owl:Restriction>   </owl:sameClassAs> </owl:Class>  <owl:Class rdf:ID=\"EffectPowerSet\">   <rdfs:comment>     This is the power set of effect (defined below);     that is, the set of all subproperties of effect.       This class is needed as the range of certain properties.    </rdfs:comment>   <owl:sameClassAs>     <owl:Restriction>       <owl:onProperty rdf:resource=\"&rdfs;#subPropertyOf\"/>       <owl:hasValue rdf:resource=\"#effect\"/>     </owl:Restriction>   </owl:sameClassAs> </owl:Class>  <!--######################################################     Connection to upper level Service ontology      ######################################################-->  <owl:Class rdf:ID=\"ProcessModel\">   <rdfs:comment>     A ServiceModel describes how a Service works, and     a ProcessModel is a type of ServiceModel (the only     type being defined for DAML-S).     See also the introductory comments to Service.daml.     </rdfs:comment>   <rdfs:subClassOf rdf:resource=\"&service;#ServiceModel\"/>  </owl:Class>  <owl:ObjectProperty rdf:ID=\"hasProcess\">   <rdfs:comment>     It is important to understand that DAML-S conceptualizes a specific process     as a *class*, each of whose instances is a particular use/invocation of the     process.  Thus, each specific process (such as BuyBook in Congo.daml) is     a *subclass*, rather than an instance, of Process.  This is why the range     of hasProcess is specified as ProcessPowerSet (which is the class of     all subclasses of Process).     In the case of a composite process, indicates the top-level process class.   </rdfs:comment>   <rdfs:domain rdf:resource=\"#ProcessModel\"/>   <rdfs:range rdf:resource=\"#ProcessPowerSet\"/> </owl:ObjectProperty>  <owl:Class rdf:ID=\"ProcessControlModel\">   <rdfs:comment>     A ProcessControlModel is used to monitor and control execution of      a Process. This is just a \"stub\" for now; will be developed further     in future releases of DAML-S.   </rdfs:comment> </owl:Class>  <owl:ObjectProperty rdf:ID=\"hasControlModel\">   <rdfs:domain rdf:resource=\"#ProcessModel\"/>   <rdfs:range rdf:resource=\"#ProcessControlModel\"/> </owl:ObjectProperty>  <owl:Class rdf:about=\"#ProcessModel\">   <rdfs:comment>     A ProcessModel can have at most one Process and one ProcessControlModel.   </rdfs:comment>   <rdfs:subClassOf>     <owl:Restriction owl:maxCardinality=\"1\">       <owl:onProperty rdf:resource=\"#hasProcess\"/>     </owl:Restriction>   </rdfs:subClassOf>   <rdfs:subClassOf>     <owl:Restriction owl:maxCardinality=\"1\">       <owl:onProperty rdf:resource=\"#hasControlModel\"/>     </owl:Restriction>   </rdfs:subClassOf> </owl:Class>  <!--######################################################     Processes     ######################################################-->  <owl:Class rdf:ID=\"Process\">   <rdfs:comment> The most general class of processes </rdfs:comment>   <owl:disjointUnionOf rdf:parseType=\"Collection\">     <owl:Class rdf:about=\"#AtomicProcess\"/>     <owl:Class rdf:about=\"#SimpleProcess\"/>     <owl:Class rdf:about=\"#CompositeProcess\"/>   </owl:disjointUnionOf> </owl:Class>  <!--  Processes can have a name, parameters, preconditions, and (conditional) effects.  Input, (conditional) output, and participant are subproperties of parameter. Each input, output, parameter, precondition or effect is a property of process, left unrestricted at this level (it ranges over \"Thing\").   Note: The basic attributes are similar to the PDDL definition of events with the addition of input, output and participant attributes.  Processes can also be at an instant (atTime) or during an interval (during).  -->  <rdf:Property rdf:ID=\"name\">   <rdfs:domain rdf:resource=\"#Process\"/>   <rdfs:range rdf:resource=\"http://www.w3.org/2000/01/rdf-schema#Literal\"/> </rdf:Property>  <owl:Class rdf:about=\"#Process\">   <rdfs:comment>     A Process can have at most one name, but names need not be unique.   </rdfs:comment>   <rdfs:subClassOf>     <owl:Restriction owl:maxCardinality=\"1\">       <owl:onProperty rdf:resource=\"#name\"/>     </owl:Restriction>   </rdfs:subClassOf> </owl:Class>  <!--  Parameters are properties of processes.  There are three common and important subtypes of parameter in the top level ontology: input, output, and participant, all of which are declared below.  Specific processes will further specialize these properties by restricting the range appropriately using subPropertyOf.  For example, the credit card number input of a buying event would be restricted to have a range of type integer.  -->  <rdf:Property rdf:ID=\"parameter\">   <rdfs:domain rdf:resource=\"#Process\"/>   <rdfs:range  rdf:resource=\"&owl;#Thing\"/> </rdf:Property>  <!-- An input is a type of parameter and is a property of a process. The top level ontology doesn't restrict them at all. An input can be any kind of daml object (Thing).  Specific processes will specialize this property by restricting the range appropriately; such as required inputs, derivable inputs, etc.  -->  <rdf:Property rdf:ID=\"input\">    <rdfs:subPropertyOf rdf:resource=\"#parameter\"/>    <owl:range rdf:resource=\"&owl;#Thing\"/> </rdf:Property>  <!-- An output is a type of parameter and is a property of a process. An output can be conditional.  For example, in a book buying service, the output of a LocateBook program would be different depending upon whether the book is in stock or not. In the trivial case (no conditions to be distinguished), the range of the output property can be restricted to the subclass UnConditionalOutput.   -->  <rdf:Property rdf:ID=\"output\">   <rdfs:subPropertyOf rdf:resource=\"#parameter\"/>    <rdfs:range rdf:resource=\"#ConditionalOutput\"/> </rdf:Property>    <!-- A participant is a type of parameter and is a property of a process. The top level ontology doesn't restrict them at all. A participant can be any kind of daml object (Thing).  Specific processes will specialize this property by restricting the range to types of agents, objects, entities, etc.  -->  <rdf:Property rdf:ID=\"participant\">     <rdfs:subPropertyOf rdf:resource=\"#parameter\"/> </rdf:Property>  <!--  Precondition is a property of Process.  Specific processes will specialize this property by restricting the range appropriately using subPropertyOf; such as knowledge preconditions (agent knows credit card number) or world precondition (baud rate > 56Kb)  -->  <rdf:Property rdf:ID=\"precondition\">     <rdfs:domain rdf:resource=\"#Process\"/>   <rdfs:range  rdf:resource=\"#Condition\"/> </rdf:Property>  <!--   Effect is a property of process, having the range ConditionalEffect. Processes will have conditional effects.  For example, if the book is in stock (condition), it will be purchased (effect) after executing the buy-book process.  In the trivial case (no conditions to be distinguished), the range of the effect property can be restricted to the subclass UnConditionalEffect.   -->  <rdf:Property rdf:ID=\"effect\"> <rdfs:domain rdf:resource=\"#Process\"/> <rdfs:range  rdf:resource=\"#ConditionalEffect\"/> </rdf:Property>  <!-- Bookkeeping Properties. These properties are specified for processes and are mostly unrestricted at this level. The are useful for tracking, workflow enactment, and database management.   -->  <rdf:Property rdf:ID=\"address\">  <rdfs:comment>    Address is a machine name, leave it unrestricted for now  </rdfs:comment>    <rdfs:domain rdf:resource=\"#Process\"/> </rdf:Property>  <rdf:Property rdf:ID=\"docRead\">  <rdfs:comment>    Documents that are read by the Process (could be a database, an html form,   whatever), range is left unrestricted at this level.  </rdfs:comment>    <rdfs:domain rdf:resource=\"#Process\"/> </rdf:Property>  <rdf:Property rdf:ID=\"docUpdate\">  <rdfs:comment>    Documents that are updated by the Process (could be a database, an html form,   whatever), range is left unrestricted at this level.  </rdfs:comment>    <rdfs:domain rdf:resource=\"#Process\"/> </rdf:Property>  <rdf:Property rdf:ID=\"docWrite\">  <rdfs:comment>    Documents that are written to by the Process (could be a database,   an html form or other); range is left unrestricted at this level.  </rdfs:comment>   <rdfs:domain rdf:resource=\"#Process\"/> </rdf:Property>  <!--######################################################     Atomic and Simple Processes     ######################################################-->  <!--   Atomic processes are the basic units of implementation.  To interact with an atomic process involves (at most) 2 messages: one carrying its inputs, and one carrying its outputs.  (Note, however, that messages are not explicitly defined in this ontology, but rather are specified by the Grounding.)  An atomic process is a \"black box\" representation; that is, no description is given of how the process works (apart from inputs, outputs, preconditions, and effects).  To be used, an atomic process must be associated with a Grounding. This association is expressed indirectly, by means of a Grounding instance, which is declared independently of the process.  Thus, to get to the grounding for a given atomic process, navigate from the process to the service object (via \"describes\"), and then from the service object to its grounding (via \"supports\").  The grounding contains a relation mapping atomic processes to their groundings.  -->  <owl:Class rdf:ID=\"AtomicProcess\">   <owl:subClassOf rdf:resource=\"#Process\"/> </owl:Class>  <!--   Simple processes provide an (optional) level of abstraction.  They describe themselves in the same way as Atomic processes, but, unlike atomics, they give additional characterization of how they work, in terms of other processes (using the \"expandsTo\" and \"realizedBy\" properties).  They are not directly callable.  A simple process can be thought of as a \"view\" on either an atomic or a composite process.  Simple processes provide a means of characterizing other processes at varying levels of granularity, for purposes of planning and reasoning.  Future releases will allow for a formal specification of a mapping between a simple process and the process that it abstracts.  -->  <owl:Class rdf:ID=\"SimpleProcess\">   <owl:subClassOf rdf:resource=\"#Process\"/> </owl:Class>   <!--   A simple process that abstracts an atomic process is \"realized by\" that process.  -->  <owl:ObjectProperty rdf:ID=\"realizedBy\">   <rdfs:domain rdf:resource=\"#SimpleProcess\"/>   <rdfs:range rdf:resource=\"#AtomicProcess\"/>   <owl:inverseOf rdf:resource=\"#realizes\"/> </owl:ObjectProperty>  <owl:ObjectProperty rdf:ID=\"realizes\">   <rdfs:domain rdf:resource=\"#AtomicProcess\"/>   <rdfs:range rdf:resource=\"#SimpleProcess\"/>   <owl:inverseOf rdf:resource=\"#realizedBy\"/> </owl:ObjectProperty>  <!--   There are two fundamental relations that can hold between simple processes and composite processes. One pertains to \"expanding\" a process to its underlying CompositeProcess (zoom-in) and the other corresponds to \"collapsing\" a composite process into a simple process (zoom-out).  -->  <owl:ObjectProperty rdf:ID=\"expandsTo\">   <rdfs:domain rdf:resource=\"#SimpleProcess\"/>   <rdfs:range rdf:resource=\"#CompositeProcess\"/>   <owl:inverseOf rdf:resource=\"#collapsesTo\"/> </owl:ObjectProperty>  <owl:ObjectProperty rdf:ID=\"collapsesTo\">   <rdfs:domain rdf:resource=\"#CompositeProcess\"/>   <rdfs:range rdf:resource=\"#SimpleProcess\"/>   <owl:inverseOf rdf:resource=\"#expandsTo\"/> </owl:ObjectProperty>  <owl:ObjectProperty rdf:ID=\"expand\">   <rdfs:comment>This is a deprecated usage; expandsTo is preferred.</rdfs:comment>   <owl:samePropertyAs rdf:resource=\"#expandsTo\"/> </owl:ObjectProperty>  <owl:ObjectProperty rdf:ID=\"collapse\">   <rdfs:comment>This is a deprecated usage; collapsesTo is preferred.</rdfs:comment>   <owl:samePropertyAs rdf:resource=\"#collapsesTo\"/> </owl:ObjectProperty>  <!--######################################################     Composite Processes and Control Constructs     ######################################################-->  <!--   Composite processes are composed of subprocesses, and specify constraints on the ordering and conditional execution of these subprocesses.  These constraints are captured by the \"composedOf\" property, which is required for a composite process.  Composite processes bottom out in non-composite (atomic and/or simple) processes.  -->  <owl:Class rdf:ID=\"CompositeProcess\">   <rdfs:comment>     A CompositeProcess must have exactly 1 composedOf property.   </rdfs:comment>   <owl:intersectionOf rdf:parseType=\"Collection\">       <owl:Class rdf:about=\"#Process\"/>       <owl:Restriction owl:cardinality=\"1\">          <owl:onProperty rdf:resource=\"#composedOf\"/>       </owl:Restriction>   </owl:intersectionOf> </owl:Class>  <owl:ObjectProperty rdf:ID=\"composedOf\">   <rdfs:domain rdf:resource=\"#CompositeProcess\"/>   <rdfs:range rdf:resource=\"#ControlConstruct\"/> </owl:ObjectProperty>  <owl:DatatypeProperty rdf:ID=\"invocable\">     <rdfs:comment>     Invocable is a flag that tells whether the CompositeProcess bottoms      out in atomic processes.  (If so, it is \"invocable\".)   </rdfs:comment>   <rdfs:domain rdf:resource=\"#CompositeProcess\"/>   <rdfs:range  rdf:resource=\"&xsd;#boolean\"/> </owl:DatatypeProperty>  <rdf:Property rdf:ID=\"computedInput\">     <rdfs:comment>     A computed input is a single expression that characterizes the     inputs required by a composite process, and the conditions under     which they are required.  This expression may, if needed, tie     together 2 or more inputs; for example, \"either a credit card number,     or a bank account number must be given\", or \"if product     id starts with 'M', no shipping method need be given\".     Additionally, this expression may refer to things other than inputs;     for example; \"if user's credit rating is 'excellent' or better,     Social Security number is not required\", or \"if product weight     is less than 1 lb., no shipping myth did need be given\".      A \"computed\" input is so named because it is meant to be computed     automatically by some tool, by inspecting the makeup of the composite      process.      The language used to represent a computed input is not specified     here, and will be the subject of future work; hence, the use of Thing     as range.  It will require expressiveness greater than that of     DAML+OIL.   </rdfs:comment>   <rdfs:domain rdf:resource=\"#CompositeProcess\"/>   <rdfs:range  rdf:resource=\"&owl;#Thing\"/> </rdf:Property>  <rdf:Property rdf:ID=\"computedOutput\">     <rdfs:comment>     A computed output is a single expression that characterizes the     outputs required by a composite process, and the conditions under     which they are required.  See comment for computedInput.   </rdfs:comment>   <rdfs:domain rdf:resource=\"#CompositeProcess\"/>   <rdfs:range  rdf:resource=\"&owl;#Thing\"/> </rdf:Property>  <rdf:Property rdf:ID=\"computedPrecondition\">     <rdfs:comment>     A computed precondition is a single expression that characterizes the     preconditions of a composite process, based on the preconditions     of its sub processes.   </rdfs:comment>   <rdfs:domain rdf:resource=\"#CompositeProcess\"/>   <rdfs:range  rdf:resource=\"&owl;#Thing\"/> </rdf:Property>  <rdf:Property rdf:ID=\"computedEffect\">     <rdfs:comment>     A computed effect is a single expression that characterizes the     effects of a composite process, based on the effects     of its sub processes.   </rdfs:comment>   <rdfs:domain rdf:resource=\"#CompositeProcess\"/>   <rdfs:range  rdf:resource=\"&owl;#Thing\"/> </rdf:Property>  <owl:Class rdf:about=\"#CompositeProcess\">   <rdfs:comment>     A CompositeProcess can have at most one invocable property. Similarly for     computedInput, computedOutput, computedEffect, and     computedPrecondition.   </rdfs:comment>   <rdfs:subClassOf>     <owl:Restriction owl:maxCardinality=\"1\">       <owl:onProperty rdf:resource=\"#invocable\"/>     </owl:Restriction>   </rdfs:subClassOf>   <rdfs:subClassOf>     <owl:Restriction owl:maxCardinality=\"1\">       <owl:onProperty rdf:resource=\"#computedInput\"/>     </owl:Restriction>   </rdfs:subClassOf>   <rdfs:subClassOf>     <owl:Restriction owl:maxCardinality=\"1\">       <owl:onProperty rdf:resource=\"#computedOutput\"/>     </owl:Restriction>   </rdfs:subClassOf>   <rdfs:subClassOf>     <owl:Restriction owl:maxCardinality=\"1\">       <owl:onProperty rdf:resource=\"#computedEffect\"/>     </owl:Restriction>   </rdfs:subClassOf>   <rdfs:subClassOf>     <owl:Restriction owl:maxCardinality=\"1\">       <owl:onProperty rdf:resource=\"#computedPrecondition\"/>     </owl:Restriction>   </rdfs:subClassOf> </owl:Class>  <!--       ControlConstruct Class  Here, we specify a minimal set of control constructs that can be used to specify a variety of web services. The minimal initial set are Sequence, Split, Split + Join, Unordered, Condition, If-Then-Else, Repeat-While, Repeat-Until.  -->  <owl:Class rdf:ID=\"ControlConstruct\"> </owl:Class>  <rdf:Property rdf:ID=\"components\">  <rdfs:comment>    The components propery of a control construct holds   a specific arrangement of subprocesses or control constructs.    The range is declared at each subclass of ControlConstruct.  </rdfs:comment>   <rdfs:domain rdf:resource=\"#ControlConstruct\"/> </rdf:Property>  <!-- ProcessComponent Class -->  <owl:Class rdf:ID=\"ProcessComponent\">   <rdfs:comment>     A ProcessComponent is either a Process or a ControlConstruct.       </rdfs:comment>   <owl:unionOf rdf:parseType=\"Collection\">     <owl:Class rdf:about=\"#Process\"/>     <owl:Class rdf:about=\"#ControlConstruct\"/>   </owl:unionOf> </owl:Class>  <!-- currentProcessComponent and nextProcessComponent were properties      defined to explicitly describe the control flow of a composite process.      These constructs are (virtually) unused in DAML-S 0.9.  -->           <rdf:Property rdf:ID=\"currentProcessComponent\">  <rdfs:comment>     Attribute to keep a pointer to the current process component.  </rdfs:comment>   <rdfs:domain rdf:resource=\"#ControlConstruct\"/>  <rdfs:range rdf:resource=\"#ProcessComponent\"/> </rdf:Property>  <rdf:Property rdf:ID=\"nextProcessComponent\">  <rdfs:comment>     Attribute to keep a pointer to the next process component.  </rdfs:comment>   <rdfs:domain rdf:resource=\"#ControlConstruct\"/>  <rdfs:range rdf:resource=\"#ProcessComponent\"/> </rdf:Property>    <owl:Class rdf:about=\"#ControlConstruct\">   <rdfs:comment>     A ControlConstruct can have at most one currentProcessComponent and     one nextProcessComponent property.   </rdfs:comment>   <rdfs:subClassOf>     <owl:Restriction owl:maxCardinality=\"1\">       <owl:onProperty rdf:resource=\"#currentProcessComponent\"/>     </owl:Restriction>   </rdfs:subClassOf>   <rdfs:subClassOf>     <owl:Restriction owl:maxCardinality=\"1\">       <owl:onProperty rdf:resource=\"#nextProcessComponent\"/>     </owl:Restriction>   </rdfs:subClassOf> </owl:Class>  <!-- Collections of Process Components -->  <owl:Class rdf:ID=\"ProcessComponentBag\"> <rdfs:comment> A multiset of ProcessComponents </rdfs:comment>   <rdfs:subClassOf rdf:resource=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#List\"/>   <rdfs:subClassOf>    <owl:Restriction>     <owl:onProperty rdf:resource=\"&owl;#item\"/>     <owl:allValuesFrom rdf:resource=\"#ProcessComponent\"/>    </owl:Restriction>   </rdfs:subClassOf> </owl:Class>  <!--   Daml does not make any distinction between bags and lists.  We redefine the ProcessComponentList class, rather than use sameClassAs, so as to make that distinction.  -->  <owl:Class rdf:ID=\"ProcessComponentList\"> <rdfs:comment> A list of ProcessComponents </rdfs:comment>   <rdfs:subClassOf rdf:resource=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#List\"/>   <rdfs:subClassOf>    <owl:Restriction>     <owl:onProperty rdf:resource=\"&owl;#item\"/>       <owl:allValuesFrom rdf:resource=\"#ProcessComponent\"/>    </owl:Restriction>   </rdfs:subClassOf> </owl:Class>  <!--  The various control constructs that can be used for specfifying and composing processes. The minimal initial set are Sequence, Split, Fork + Join, Unordered, Condition, If-Then-Else,Iterate, Repeat-While and Repeat-Until  -->  <!-- The sequence class.  Sequence is defined as having a list of component processes that specify the body. The Preconditions, parameters and effects of the sequence are not defined in the minimal version.  An obvious extension would be to define the effect of the sequence to be the union of the effect of the individual members, and the parameters of the sequence to be the union of the parameters of individual members. However, some implementations may decide to use the last event's effects as the effect of the sequence, etc.   -->  <owl:Class rdf:ID=\"Sequence\">   <rdfs:subClassOf rdf:resource=\"#ControlConstruct\"/>   <rdfs:subClassOf>     <owl:Restriction>       <owl:onProperty rdf:resource=\"#components\"/>       <owl:allValuesFrom rdf:resource=\"#ProcessComponentList\"/>     </owl:Restriction>   </rdfs:subClassOf> </owl:Class>  <!-- Split.  Here the process consists of concurrent execution of a bunch of sub-processes.  No further specification about waiting, synchronization, etc. Similar to other ontologies' use of fork or Parallel, which we define using the sameClassAs relation.  -->  <owl:Class rdf:ID=\"Split\">   <rdfs:subClassOf rdf:resource=\"#ControlConstruct\"/>   <rdfs:subClassOf>     <owl:Restriction>       <owl:onProperty rdf:resource=\"#components\"/>       <owl:allValuesFrom rdf:resource=\"#ProcessComponentBag\"/>     </owl:Restriction>   </rdfs:subClassOf> </owl:Class>  <owl:Class rdf:ID=\"Concurrent\">   <owl:sameClassAs rdf:resource=\"#Split\"/> </owl:Class>  <owl:Class rdf:ID=\"Parallel\">   <owl:sameClassAs rdf:resource=\"#Split\"/> </owl:Class>  <!--  Split and Join.  Here the process consists of concurrent execution of a bunch of sub-processes.  with barrier synchroniztion. With Split and Split and Join, we can define processes which have partial synchronization (ex. split all and join some subset) -->  <owl:Class rdf:ID=\"Split-Join\">   <rdfs:subClassOf rdf:resource=\"#ControlConstruct\"/>   <rdfs:subClassOf>     <owl:Restriction>       <owl:onProperty rdf:resource=\"#components\"/>       <owl:allValuesFrom rdf:resource=\"#ProcessComponentBag\"/>     </owl:Restriction>   </rdfs:subClassOf> </owl:Class>  <owl:Class rdf:ID=\"Fork-join\">   <owl:sameClassAs rdf:resource=\"#Split-Join\"/> </owl:Class>  <owl:Class rdf:ID=\"Concurrent-Sync\">   <owl:sameClassAs rdf:resource=\"#Split-Join\"/> </owl:Class>  <owl:Class rdf:ID=\"Parallel-Sync\">   <owl:sameClassAs rdf:resource=\"#Split-Join\"/> </owl:Class>  <!-- end Split + Join  -->  <!--   Allows the process components (specified as a bag) to be executed in some unspecified order, or concurrently.  All components must be executed.  As with Split+Join, completion of all components is required.  Note that, while the unordered construct itself gives no constraints on the order of execution, nevertheless, in some cases, there may be constraints associated with subcomponents, which must be respected.  -->  <owl:Class rdf:ID=\"Unordered\">   <rdfs:subClassOf rdf:resource=\"#ControlConstruct\"/>   <rdfs:subClassOf>     <owl:Restriction>       <owl:onProperty rdf:resource=\"#components\"/>       <owl:allValuesFrom rdf:resource=\"#ProcessComponentBag\"/>     </owl:Restriction>   </rdfs:subClassOf> </owl:Class>  <owl:Class rdf:ID=\"Any-Order\">   <owl:sameClassAs rdf:resource=\"#Unordered\"/> </owl:Class>  <!-- end Unordered -->  <!-- Choice Choice is the selection among a bag of Processes. The choose property, takes a choice bag and returns  a chosen bag. The cardinality of the bag can be specified through a restriction to get choose(n) (0<n<=|bag|). -->  <owl:Class rdf:ID=\"Choice\">   <rdfs:subClassOf rdf:resource=\"#ControlConstruct\"/>   <rdfs:subClassOf>     <owl:Restriction>       <owl:onProperty rdf:resource=\"#components\"/>       <owl:allValuesFrom rdf:resource=\"#ProcessComponentBag\"/>     </owl:Restriction>   </rdfs:subClassOf> </owl:Class>  <!--  note given Chosen and ChooseFrom, we can define both a control operator such as sequence or unordered (ex. choose and do chosen in sequence, or choose and do chosen in parallel) as well as a class that restricts the size of the Process Bag that corresponds to the \"components\" of the chosen and chooseFrom subprocesses using cardinality, mincardinality, maxcardinality to get choose at least n from m, choose n from m, and choose at most n from m, etc.   These extensions are left as an exercises to the reader :) -->  <rdf:Property rdf:ID=\"chooseFrom\">    <rdfs:domain rdf:resource=\"#Choice\"/>    <rdfs:range rdf:resource =\"#ProcessComponentBag\"/> </rdf:Property>  <rdf:Property rdf:ID=\"chosen\">    <rdfs:domain rdf:resource=\"#Choice\"/>    <rdfs:range rdf:resource =\"#ProcessComponent\"/> </rdf:Property>  <!-- This version does not distinguish choice from alternative -->  <owl:Class rdf:ID=\"Alternative\">   <owl:sameClassAs rdf:resource=\"#Choice\"/> </owl:Class>  <!-- end choice -->  <!-- TestConditions are processes that have a relation whose domain is a process and whose range is a binary value. Usually correspond to test actions, but may be world states, resource levels, timeouts or other things affecting the evolution of processes. Could be subtyped from a test process.. -->  <owl:Class rdf:ID=\"TestCondition\">   <rdfs:subClassOf rdf:resource=\"#Process\"/> </owl:Class>  <!--Condition Value is an output of the condition test process. The output value could be true or false, depending on the result of the test-->  <owl:ObjectProperty rdf:ID=\"conditionValue\">   <rdfs:subPropertyOf rdf:resource=\"#output\"/>    <rdfs:domain rdf:resource=\"#TestCondition\"/>    <rdfs:range  rdf:resource =\"#TestValue\"/> </owl:ObjectProperty>  <!--  For now, we make TestValue a boolean, may need to change to be more general, with one possible subclassing scheme as a boolean -->  <owl:Class rdf:ID=\"TestValue\">   <owl:oneOf rdf:parseType=\"Collection\">     <TestValue rdf:ID=\"True\"/>     <TestValue rdf:ID=\"False\"/>   </owl:oneOf> </owl:Class>  <!-- end condition Class -->  <!-- IF then Else Class is a ControlConstruct that consists of a Condition, a then and an else process-->  <owl:Class rdf:ID=\"If-Then-Else\">   <rdfs:subClassOf rdf:resource=\"#ControlConstruct\"/>   <rdfs:subClassOf>     <owl:Restriction>       <owl:onProperty rdf:resource=\"#components\"/>       <owl:allValuesFrom rdf:resource=\"#ProcessComponentBag\"/>     </owl:Restriction>   </rdfs:subClassOf> </owl:Class>  <rdf:Property rdf:ID=\"ifCondition\">  <rdfs:comment> The if condition of an if-then-else</rdfs:comment>    <rdfs:domain rdf:resource=\"#If-Then-Else\"/>   <rdfs:range rdf:resource=\"#Condition\"/> </rdf:Property>  <rdf:Property rdf:ID=\"then\">   <rdfs:domain rdf:resource=\"#If-Then-Else\"/>   <rdfs:range rdf:resource=\"#ProcessComponent\"/> </rdf:Property>  <rdf:Property rdf:ID=\"else\">   <rdfs:domain rdf:resource=\"#If-Then-Else\"/>   <rdfs:range rdf:resource=\"#ProcessComponent\"/>  </rdf:Property>  <!--   Iterate is a ControlConstruct.  In the future we will constrain it to say that its currentProcessComponent property has the same unique range as its nextProcessComponent property, but we leave this out of DAML-S 0.9.  Note that when we do this, iterate will never terminate. The termination of such a loop condition could be specified with a whileCondition or an untilCondition as below.  -->  <owl:Class rdf:ID=\"Iterate\">   <rdfs:subClassOf rdf:resource=\"#ControlConstruct\"/>   <rdfs:subClassOf>     <owl:Restriction>       <owl:onProperty rdf:resource=\"#components\"/>       <owl:allValuesFrom rdf:resource=\"#ProcessComponentBag\"/>     </owl:Restriction>   </rdfs:subClassOf> </owl:Class>  <owl:Class rdf:ID=\"Repeat\">  <owl:sameClassAs rdf:resource=\"#Iterate\"/> </owl:Class>  <!--  The Repeat-While class specializes the ControlConstruct class where the with properties \"whileCondition\" (range of type Condition) and ``whileProcess'' (range of type Repeat).  No committments are made about whether this is aysnchronous (w/o priortized interrupts) or synchronous (with specific polling/busy-wait strategies), etc.  This is left for the particular execution model to specify.  Once currentProcessComponent and nextProcessComponent are used to constrain Iterate, one could create Repeat-While and Repeat-Until as sublass of Iterate. -->  <rdf:Property rdf:ID=\"whileCondition\">   <rdfs:domain rdf:resource=\"#Repeat-While\"/>   <rdfs:range rdf:resource=\"#Condition\"/> </rdf:Property>  <rdf:Property rdf:ID=\"whileProcess\">   <rdfs:domain rdf:resource=\"#Repeat-While\"/>   <rdfs:range rdf:resource=\"#ProcessComponent\"/> </rdf:Property>  <owl:Class rdf:ID=\"Repeat-While\">  <rdfs:comment> The repeat while construct</rdfs:comment>   <rdfs:subClassOf rdf:resource=\"#ControlConstruct\"/> </owl:Class>  <!--  The Repeat-Until class specializes the ControlConstruct class where the with properties \"untilCondition\" (range of type Condition) and ``untilProcess'' (range of type Reapeat).  No committments are made about whether this is aysnchronous (w/o priortized interrupts) or synchronous (with specific polling/busy-wait strategies), etc.  This is left for the particular execution model to specify.   -->  <rdf:Property rdf:ID=\"untilCondition\">   <rdfs:domain rdf:resource=\"#Repeat-Until\"/>   <rdfs:range rdf:resource=\"#Condition\"/> </rdf:Property>  <rdf:Property rdf:ID=\"untilProcess\">   <rdfs:domain rdf:resource=\"#Repeat-Until\"/>   <rdfs:range rdf:resource=\"#ProcessComponent\"/> </rdf:Property>   <owl:Class rdf:ID=\"Repeat-Until\">   <rdfs:comment> The repeat until process</rdfs:comment>    <rdfs:subClassOf rdf:resource=\"#ControlConstruct\"/> </owl:Class>   <!--######################################################     Argument Bindings     ######################################################-->  <!--  Property \"sameValues\" and Class \"ValueOf\" are used to denote that two or more properties of (potentially, different subprocesses of) a ProcessComponent should have the same values when the process is instantiated.  For instance, these are used to state that the input to one subprocess should be the output of the previous one within a sequence, or that some output or effect of an atomic process should make reference to values that were specified as inputs to that same process.  -->  <rdf:Property rdf:ID=\"sameValues\">   <owl:domain rdf:resource=\"#ProcessComponent\"/>   <rdfs:comment>The range is to be a list of ValueOf.</rdfs:comment>    <owl:range rdf:resource=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#List\"/> </rdf:Property>  <owl:Class rdf:ID=\"ValueOf\"/>  <!-- This property indicates the class (a Process) having the referenced       property -->  <rdf:Property rdf:ID=\"atClass\">   <rdfs:domain rdf:resource=\"#ValueOf\"/>   <rdfs:range  rdf:resource=\"&owl;#Class\"/> </rdf:Property>  <!-- The property (usually a parameter) whose values are       referred to. --> <rdf:Property rdf:ID=\"theProperty\">   <rdfs:domain rdf:resource=\"#ValueOf\"/>    <rdfs:range  rdf:resource=\"&owl;#Property\"/> </rdf:Property>  <!--######################################################     Process Control     ######################################################-->  <!--  Minimal Support for Process Control. We expect the ontology below to grow significantly to support process control and execution monitoring.  -->  <rdf:Property rdf:ID=\"currentStatus\">   <rdfs:domain rdf:resource=\"#ProcessComponent\"/>   <rdfs:range rdf:resource=\"#ProcessControlStatus\"/> </rdf:Property>  <owl:Class rdf:ID=\"ProcessControlStatus\">   <owl:oneOf rdf:parseType=\"Collection\">     <owl:Thing rdf:ID=\"Ready\"/>     <owl:Thing rdf:ID=\"Ongoing\"/>     <owl:Thing rdf:ID=\"Suspended\"/>     <owl:Thing rdf:ID=\"Aborted\"/>     <owl:Thing rdf:ID=\"Canceled\"/>     <owl:Thing rdf:ID=\"Completed\"/>   </owl:oneOf> </owl:Class>   <!-- Optional Properties that relate to the start, end, and duration of a process.  These are a minimal set, defined in terms of an external time ontology. -->  <owl:ObjectProperty rdf:ID=\"startTime\">      <rdfs:comment> Start time for the Event </rdfs:comment>    <rdfs:domain rdf:resource=\"#ProcessComponent\"/>   <rdfs:range rdf:resource=\"&time;#Instant\"/>  </owl:ObjectProperty>  <owl:ObjectProperty rdf:ID=\"endTime\">   <rdfs:comment> End time for the Event </rdfs:comment>    <rdfs:domain rdf:resource=\"#ProcessComponent\"/>   <rdfs:range rdf:resource=\"&time;#Instant\"/> </owl:ObjectProperty>  <owl:ObjectProperty rdf:ID=\"during\">  <rdfs:comment> Event/Process is during Interval, the exact time                  interval over which the event occurs   </rdfs:comment>    <rdfs:domain rdf:resource=\"#ProcessComponent\"/>   <rdfs:range rdf:resource=\"&time;#Interval\"/> </owl:ObjectProperty>  <!-- timeouts are defined over intervals -->  <owl:ObjectProperty rdf:ID=\"timeout\">   <rdfs:domain rdf:resource=\"#ProcessComponent\"/>   <rdfs:range rdf:resource=\"&time;#Interval\"/> </owl:ObjectProperty>  <!-- We may need absolute timeout (like calender time or timeOfDay, so we allow for the timeoutAbsolute property -->  <owl:ObjectProperty rdf:ID=\"timeoutAbsolute\">   <rdfs:domain rdf:resource=\"#ProcessComponent\"/>   <rdfs:range rdf:resource=\"&time;#Interval\"/> </owl:ObjectProperty>  <owl:Class rdf:about=\"#ProcessComponent\">   <rdfs:comment>     A ProcessComponent can have at most one of each of the restricted properties.   </rdfs:comment>   <rdfs:subClassOf>     <owl:Restriction owl:maxCardinality=\"1\">       <owl:onProperty rdf:resource=\"#startTime\"/>     </owl:Restriction>   </rdfs:subClassOf>   <rdfs:subClassOf>     <owl:Restriction owl:maxCardinality=\"1\">       <owl:onProperty rdf:resource=\"#endTime\"/>     </owl:Restriction>   </rdfs:subClassOf>   <rdfs:subClassOf>     <owl:Restriction owl:maxCardinality=\"1\">       <owl:onProperty rdf:resource=\"#during\"/>     </owl:Restriction>   </rdfs:subClassOf>   <rdfs:subClassOf>     <owl:Restriction owl:maxCardinality=\"1\">       <owl:onProperty rdf:resource=\"#timeout\"/>     </owl:Restriction>   </rdfs:subClassOf>   <rdfs:subClassOf>     <owl:Restriction owl:maxCardinality=\"1\">       <owl:onProperty rdf:resource=\"#timeoutAbsolute\"/>     </owl:Restriction>   </rdfs:subClassOf> </owl:Class>  </rdf:RDF>       ", 
    "identity": {
        "subtype": "dataset", 
        "is_error": false, 
        "version": "", 
        "protocol": "RDF", 
        "language": "", 
        "service": "", 
        "has_dataset": false, 
        "has_metadata": false
    }, 
    "digest": "d130a181c9d7b1ce4eac9cf3e23cc03d", 
    "source_url": "http://www.daml.org/services/owl-s/0.9/Process.owl"
}